---
title: MySQL数据表中记录不存在则插入，存在则更新/不操作 - iCloud - CSDN博客
updated: 2019-02-15 10:51:21Z
created: 2019-02-15 10:51:21Z
source: https://blog.csdn.net/lycloud/article/details/24932961
---

转

MySQL数据表中记录不存在则插入，存在则更新/不操作

2014年05月03日 20:16:43

lyCloud

阅读数：21058

本文整理自 

http://blog.csdn.net/langeldep/article/details/6241155

http://www.jb51.net/article/15627.htm

感谢原作者

我们在开发数据库相关的逻辑过程中， 经常检查表中是否已经存在这样的一条记录， 如果存在则更新或者不做操作， 如果没有存在记录，则需要插入一条新的记录。有不同的方法可以完成这一逻辑。

 1. 通过两条SQL语句

1
SELECT

COUNT
(*)
FROM
 xxx
WHERE

ID
=xxx;
2

3
if (x == 0)
4
   
INSERT

INTO
 xxx
VALUES
;
5
else
6
   
UPDATE
 xxx
SET
 ;

但是这样操作在性能上有所损失， 代码结构感觉有点丑陋。

2. 运用 INSERT IGNORE语句

官方文档如下：

MySQL provides many extentions to SQL which help performance in many common use scenarios. Among these are 
INSERT
 ... SELECT
, 
INSERT
 ... ON DUPLICATE KEY UPDATE
, and 
REPLACE
.

I rarely hesitate to use the above since they are so convenient and provide real performance benefits in many situations. MySQL has other keywords which are more dangerous, however, and should
 be used sparingly. These include
INSERT
 DELAYED
, which tells MySQL that it is not important to insert the data immediately (say, e.g., in a logging situation). The problem with this is that under high load situations the
 insert might be delayed indefinitely, causing the insert queue to baloon. You can also give MySQL 
index
 hints
 about which indices to use. MySQL gets it right most of the time and when it doesn't it is usually because of a bad scheme or poorly written query.

重要的就是上面提到的 :

INSERT ... SELECT

INSERT ... ON DUPLICATE KEY UPDATE

INSERT ... ON DUPLICATE REPLACE

比如想往表中插入一条数据，如果表中没有该条数据才插入，如果已经存在该条数据就不插入。

首先，在创建表时，将不需要重复的字段设置为unique，然后在插入时，使用insert ignore语句。

例如：（数据库用的是mysql5）

创建一张表用来存储用户并插入数据：

1
create

table
 user_info
2
(
3
   uid mediumint(
10
)
unsigned

NOT

NULL
 auto_increment primary
key
,
4
   last_name
char
(
20
)
not

null
,
5
   first_name
char
(
20
)
not

null
,
6
  
unique
 ( last_name, first_name)
7
);
8
alter

table
 anser
add

UNIQUE
 (last_name,first_name)
9
insert

ignore

into
 user_info (last_name,first_name)
values
 (
'x'
,
'y'
);

这样一来，如果表中已经存在last_name='x'且first_name='y'的数据，就不会插入，如果没有就会插入一条
新数据
。

3. 运用 INSERT…SELECT方法

示例一：插入多条记录 
假设有一个主键为 client_id 的 clients 表，可以使用下面的语句：

1
INSERT

INTO
 clients
2
(client_id, client_name, client_type)
3
SELECT
 supplier_id, supplier_name,
'advertising'

4
FROM
 suppliers
5
WHERE

not

exists
 (
select
 *
from
 clients
6
where
 clients.client_id = suppliers.supplier_id);
示例二：插入单条记录
 
1
INSERT

INTO
 clients
2
(client_id, client_name, client_type)
3
SELECT

10345
,
'IBM'
,
'advertising'

4
FROM
 dual
5
WHERE

not

exists
 (
select
 *
from
 clients
6
where
 clients.client_id =
10345
);

使用 dual 做表名可以让你在 select 语句后面直接跟上要插入字段的值，即使这些值还不存在当前表中。

4. mysql 记录不存在时插入 记录存在则更新的实现方法

1
mysql>
truncate

`200702`
;
2
Query OK, 0 rows affected (0.01 sec)
3
mysql>
select
 *
from

`200702`
;
4
Empty
set
 (
0.01
 sec)<span
id
=
"more-22"
></span>
5
mysql>
insert

into

`200702`
 (
`domain`
,
`2nd_domain`
,
`tld`
,
`query_ns1`
,
`query_ns2`
,
`report_date`
)
values
 (
'
dnspod
.com'
,
'dnspod'
,
'com'
,
1000
,
2000
,
'2007-02-04'
)
ON

DUPLICATE

KEY

UPDATE

`query_ns1`
 =
`query_ns1`
 +
1000
,
`query_ns2`
 =
`query_ns2`
 +
2000
;
6
Query OK, 1 row affected (0.00 sec)
7

8
mysql>
select
 *
from

`200702`
;
9
+
----+------------+------------+------+-----------+-----------+-----------+-----------+-------------+
10
| id | domain | 2nd_domain | tld | query_ns1 | query_ns2 | query_ns3 | query_ns4 | report_date |
11
+
----+------------+------------+------+-----------+-----------+-----------+-----------+-------------+
12
| 1 | dnspod.com | dnspod | com | 1000 | 2000 | 0 | 0 | 2007-02-04 |
13
+
----+------------+------------+------+-----------+-----------+-----------+-----------+-------------+
14
1 row in
set
 (
0.00
 sec)
15

16
mysql>
insert

into

`200702`
 (
`domain`
,
`2nd_domain`
,
`tld`
,
`query_ns1`
,
`query_ns2`
,
`report_date`
)
values
 (
'dnspod.com'
,
'dnspod'
,
'com'
,
1000
,
2000
,
'2007-02-04'
)
ON

DUPLICATE

KEY

UPDATE

`query_ns1`
 =
`query_ns1`
 +
1000
,
`query_ns2`
 =
`query_ns2`
 +
2000
;
17
Query OK, 2 rows affected (0.01 sec)
18

19
mysql>
select
 *
from

`200702`
;
20
+
----+------------+------------+------+-----------+-----------+-----------+-----------+-------------+
21
| id | domain | 2nd_domain | tld | query_ns1 | query_ns2 | query_ns3 | query_ns4 | report_date |
22
+
----+------------+------------+------+-----------+-----------+-----------+-----------+-------------+
23
| 1 | dnspod.com | dnspod | com | 2000 | 4000 | 0 | 0 | 2007-02-04 |
24
+
----+------------+------------+------+-----------+-----------+-----------+-----------+-------------+
25
1 row in
set
 (
0.01
 sec)
26
mysql>
当然，建表的时候，千万别忘记了给domain做一个unique 
UNIQUE KEY `domain` (`domain`,`report_date`) 

5 
INSERT 中 ON DUPLICATE KEY UPDATE的使用 
如果您指定了ON DUPLICATE KEY UPDATE，并且插入行后会导致在一个UNIQUE索引或PRIMARY KEY中出现重复值，则执行旧行UPDATE。例如，如果列a被定义为UNIQUE，并且包含值1，则以下两个语句具有相同的效果：mysql> INSERT INTO table (a,b,c)
 VALUES (1,2,3) 
         -> ON DUPLICATE KEY UPDATE c=c+1; 
mysql> UPDATE table SET c=c+1 WHERE a=1; 
如果行作为新记录被插入，则受影响行的值为1；如果原有的记录被更新，则受影响行的值为2。 
注释：如果列b也是唯一列，则INSERT与此UPDATE语句相当： 
mysql> UPDATE table SET c=c+1 WHERE a=1 OR b=2 LIMIT 1; 
如果a=1 OR b=2与多个行向匹配，则只有一个行被更新。通常，您应该尽量避免对带有多个唯一关键字的表使用ON DUPLICATE KEY子句。 
您可以在UPDATE子句中使用VALUES(col_name)函数从INSERT...UPDATE语句的INSERT部分引用列值。换句话说，如果没有发生重复关键字冲突，则UPDATE子句中的VALUES(col_name)可以引用被插入的col_name的值。本函数特别适用于多行插入。VALUES()函数只在INSERT...UPDATE语句中有意义，其它时候会返回NULL。 
示例： 
mysql> INSERT INTO table (a,b,c) VALUES (1,2,3),(4,5,6) 
         -> ON DUPLICATE KEY UPDATE c=VALUES(a)+VALUES(b); 
本语句与以下两个语句作用相同： 
mysql> INSERT INTO table (a,b,c) VALUES (1,2,3) 
         -> ON DUPLICATE KEY UPDATE c=3; 
mysql> INSERT INTO table (a,b,c) VALUES (4,5,6) 
         -> ON DUPLICATE KEY UPDATE c=9; 
当您使用ON DUPLICATE KEY UPDATE时，DELAYED选项被忽略。 
6 . 
REPLACE语句 
　　我们在使用数据库时可能会经常遇到这种情况。如果一个表在一个字段上建立了唯一索引，当我们再向这个表中使用已经存在的键值插入一条记录，那将会抛出一个主键冲突的错误。当然，我们可能想用新记录的值来覆盖原来的记录值。如果使用传统的做法，必须先使用DELETE语句删除原先的记录，然后再使用INSERT插入新的记录。而在MySQL中为我们提供了一种新的解决方案，这就是REPLACE语句。使用REPLACE插入一条记录时，如果不重复，REPLACE就和INSERT的功能一样，如果有重复记录，REPLACE就使用新记录的值来替换原来的记录值。 
　　使用REPLACE的最大好处就是可以将DELETE和INSERT
合二为一
，形成一个原子操作。这样就可以不必考虑在同时使用DELETE和INSERT时添加事务等复杂操作了。 
　　在使用REPLACE时，表中必须有唯一索引，而且这个索引所在的字段不能允许空值，否则REPLACE就和INSERT完全一样的。 
　　在执行REPLACE后，系统返回了所影响的行数，如果返回1，说明在表中并没有重复的记录，如果返回2，说明有一条重复记录，系统自动先调用了DELETE删除这条记录，然后再记录用INSERT来插入这条记录。如果返回的值大于2，那说明有多个唯一索引，有多条记录被删除和插入。 
　　REPLACE的语法和INSERT非常的相似，如下面的REPLACE语句是插入或更新一条记录。 
　　REPLACE INTO users (id,name,age) VALUES(123, '赵本山', 50); 
　 
　　插入多条记录： 
　　REPLACE INTO users(id, name, age) 
　　VALUES(123, '赵本山', 50), (134,'Mary',15); 
　　REPLACE也可以使用SET语句 
　　REPLACE INTO users SET id = 123, name = '赵本山', age = 50; 
　　上面曾提到REPLACE可能影响3条以上的记录，这是因为在表中有超过一个的唯一索引。在这种情况下，REPLACE将考虑每一个唯一索引，并对每一个索引对应的重复记录都删除，然后插入这条新记录。假设有一个table1表，有3个字段a, b, c。它们都有一个唯一索引。 
　　CREATE TABLE table1(a INT NOT NULL UNIQUE,b INT NOT NULL UNIQUE,c INT NOT NULL UNIQUE); 
　　假设table1中已经有了3条记录 
　　a b c 
　　1 1 1 
　　2 2 2 
　　3 3 3 
　　下面我们使用REPLACE语句向table1中插入一条记录。 
　　REPLACE INTO table1(a, b, c) VALUES(1,2,3); 
　　返回的结果如下 
　　Query OK, 4 rows affected (0.00 sec) 
　　在table1中的记录如下 
　　a b c 
　　1 2 3 
　　我们可以看到，REPLACE将原先的3条记录都删除了，然后将（1, 2, 3）插入。 
总结：虽然没有具体测试，感觉第一种最费资源了（只是感觉），不过你要是没有主键的话也只能用他了。第二种和第三种的区别是：1)insert是先尝试插入，若主键存在则更新。REPLACE是先尝试插入，若主键存在则删除原纪录再插入。2)如果有多个唯一关键字发生冲突(不同关键字的冲突发生在不同记录),比如现在有2个字段2条记录冲突了(没条记录冲突一个字段)，则insert是选择排序后在前面的一条进行更新，REPLACE是删除那两条记录，然后插入新记录。本人的一点小见解，如有错误，欢迎指正。
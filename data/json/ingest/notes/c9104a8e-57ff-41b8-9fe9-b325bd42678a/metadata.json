{
  "ingest_source": {
    "id": "e428d8c8-b4ec-4550-ab91-670fd6451891",
    "source_type": "evernote_html",
    "source_path": "/Users/tang/workbench/article-classifier/backups/2023年6月/IT技术/MySQL最常用分组聚合函数.html",
    "collected_at": "2025-11-09T20:05:13.274797Z",
    "external_id": null,
    "title_hint": null,
    "language_hint": "en",
    "captured_at": null,
    "checksum": "e6895190197d7974bd3fe841fc4d59fc16e9a129830f6b0f39c92c8bf35035a7",
    "status": "pending",
    "notes": {
      "batch_id": null
    }
  },
  "note": {
    "id": "c9104a8e-57ff-41b8-9fe9-b325bd42678a",
    "ingest_source_id": "e428d8c8-b4ec-4550-ab91-670fd6451891",
    "canonical_title": "MySQL最常用分组聚合函数",
    "language": "en",
    "ingested_at": "2025-11-09T20:05:13.274801Z",
    "created_at": null,
    "status": "active",
    "importance": 0,
    "attributes": {
      "source_filename": "MySQL最常用分组聚合函数.html"
    }
  },
  "variants": [
    {
      "id": "df614ded-931a-4074-85b1-af5ce1cfe603",
      "note_id": "c9104a8e-57ff-41b8-9fe9-b325bd42678a",
      "variant_type": "raw_html",
      "version": 1,
      "created_by": "evernote_ingest:v0",
      "created_at": "2025-11-09T20:05:13.274804Z",
      "content": "---\ntitle: MySQL最常用分组聚合函数\nupdated: 2022-09-09 12:26:51Z\ncreated: 2022-08-21 15:17:51Z\nauthor: tangyongfeng\ntags:\n  - mysql\n---\n\n\n\n<en-note><div><p ALIGN=\"left\"><span>一、</span><span><span>聚合函数</span>（<span>aggregation function</span>）<span>---也就是组函数</span></span></p><p ALIGN=\"left\"><span>　　<span>在一个行的集合（一组行）上进行操作，对每个组给一个结果。</span></span></p><p ALIGN=\"left\"><span>常用的组函数：</span></p><div><table BORDER=\"1\" CELLSPACING=\"0\" CELLPADDING=\"0\"><tr><td COLSPAN=\"1\" ROWSPAN=\"1\" VALIGN=\"top\"><p ALIGN=\"left\"><a SHAPE=\"rect\" HREF=\"https://www.cnblogs.com/geaozhang/p/6745147.html#sum-avg\" TARGET=\"_blank\" REL=\"noopener\"><span>AVG([<span>distinct</span>] expr)</span></a></p></td><td COLSPAN=\"1\" ROWSPAN=\"1\" VALIGN=\"top\"><p ALIGN=\"left\"><span>求平均值</span></p></td></tr><tr><td COLSPAN=\"1\" ROWSPAN=\"1\" VALIGN=\"top\"><p ALIGN=\"left\"><a SHAPE=\"rect\" HREF=\"https://www.cnblogs.com/geaozhang/p/6745147.html#count\" TARGET=\"_blank\" REL=\"noopener\"><span>COUNT({*|[<span>distinct</span>] } expr)</span></a></p></td><td COLSPAN=\"1\" ROWSPAN=\"1\" VALIGN=\"top\"><p ALIGN=\"left\"><span>统计行的数量</span></p></td></tr><tr><td COLSPAN=\"1\" ROWSPAN=\"1\" VALIGN=\"top\"><p ALIGN=\"left\"><a SHAPE=\"rect\" HREF=\"https://www.cnblogs.com/geaozhang/p/6745147.html#max-min\" TARGET=\"_blank\" REL=\"noopener\"><span>MAX([<span>distinct</span>] expr)</span></a></p></td><td COLSPAN=\"1\" ROWSPAN=\"1\" VALIGN=\"top\"><p ALIGN=\"left\"><span>求最大值</span></p></td></tr><tr><td COLSPAN=\"1\" ROWSPAN=\"1\" VALIGN=\"top\"><p ALIGN=\"left\"><a SHAPE=\"rect\" HREF=\"https://www.cnblogs.com/geaozhang/p/6745147.html#max-min\" TARGET=\"_blank\" REL=\"noopener\"><span>MIN([<span>distinct</span>] expr)</span></a></p></td><td COLSPAN=\"1\" ROWSPAN=\"1\" VALIGN=\"top\"><p ALIGN=\"left\"><span>求最小值</span></p></td></tr><tr><td COLSPAN=\"1\" ROWSPAN=\"1\" VALIGN=\"top\"><p ALIGN=\"left\"><a SHAPE=\"rect\" HREF=\"https://www.cnblogs.com/geaozhang/p/6745147.html#sum-avg\" TARGET=\"_blank\" REL=\"noopener\"><span>SUM([<span>distinct</span>] expr)</span></a></p></td><td COLSPAN=\"1\" ROWSPAN=\"1\" VALIGN=\"top\"><p ALIGN=\"left\"><span>求累加和</span></p></td></tr></table></div><p ALIGN=\"left\"><span>　　①每个组函数接收一个参数</span></p><p ALIGN=\"left\"><span>　　②默认情况下，<span>组函数<span>忽略列值为null的行</span>，不参与计算</span></span></p><p ALIGN=\"left\"><span>　　③有时，会使用关键字distinct剔除字段值重复的条数</span></p><p ALIGN=\"left\"><span>注意：</span></p><p ALIGN=\"left\"><span>　　1）当使用组函数的select语句中没有group by子句时，中间结果集中的所有行自动形成一组，然后计算组函数；</span></p><p ALIGN=\"left\"><span>　　2）组函数<span>不允许嵌套</span>，例如：count(max(&hellip;))；</span></p><p ALIGN=\"left\"><span>　　3）组函数的参数可以是<span>列或是函数表达式</span>；</span></p><p ALIGN=\"left\"><span>　　4）一个SELECT子句中可出现多个聚集函数。</span></p><p ALIGN=\"left\">&nbsp;</p><p ALIGN=\"left\"><span>实验演示用表：</span></p><div><pre XML:SPACE=\"preserve\"><span>mysql&gt; select * from salary_tab;\n+--------+---------+\n| userid | salary  |\n+--------+---------+\n|      1 | 1000.00 |\n|      2 | 2000.00 |\n|      3 | 3000.00 |\n|      4 |    NULL |\n|      5 | 1000.00 |\n+--------+---------+\n5 rows in set (0.00 sec)</span><span>&nbsp;</span></pre></div><div><pre XML:SPACE=\"preserve\"><span>mysql&gt; use TENNIS</span><br CLEAR=\"none\"/><span>mysql&gt;<span> show tables;\n</span>+-------------------+\n| Tables_in_TENNIS  |\n+-------------------+\n| COMMITTEE_MEMBERS |\n| MATCHES           |\n| PENALTIES         |\n| PLAYERS           |\n| TEAMS             |\n+-------------------+\n<span>5</span> rows <span>in</span> <span>set</span> (<span>0.00</span> sec)</span></pre></div><p ALIGN=\"left\">&nbsp;</p><p ALIGN=\"left\"><span><a SHAPE=\"rect\" REL=\"noopener\" NAME=\"count\"></a>1、count函数</span></p><p ALIGN=\"left\"><span>①count(*)：返回表中满足where条件的行的数量</span></p><div><pre XML:SPACE=\"preserve\"><span>mysql&gt; <span>select</span> count(*) <span>from</span> salary_tab <span>where</span> salary=<span>&apos;</span><span>1000</span><span>&apos;</span><span>;\n</span>+----------+\n| count(*) |\n+----------+\n|        <span>2</span> |\n+----------+<span>\n\nmysql</span>&gt; <span>select</span> count(*) <span>from</span><span> salary_tab;　　<span>#没有条件，默认统计表数据行数\n</span></span>+----------+\n| count(*) |\n+----------+\n|        <span>5</span> |\n+----------+</span></pre></div><p ALIGN=\"left\"><span>②<span>count(列)：</span>返回列值非空的行的数量</span></p><div><pre XML:SPACE=\"preserve\"><span>mysql&gt; <span>select</span> count(salary) <span>from</span><span> salary_tab;\n</span>+---------------+\n| count(salary) |\n+---------------+\n|             <span>4</span> |\n+---------------+</span></pre></div><p ALIGN=\"left\"><span>③<span>count(<span>distinct</span> 列)：</span>返回列值非空的、并且列值不重复的行的数量</span></p><div><pre XML:SPACE=\"preserve\"><span>mysql&gt; <span>select</span> count(<span>distinct</span> salary) <span>from</span><span> salary_tab;\n</span>+------------------------+\n| count(<span>distinct</span> salary) |\n+------------------------+\n|                      <span>3</span> |\n+------------------------+</span></pre></div><p><span>④<span>count(expr)</span>：根据表达式统计数据</span></p><div><pre XML:SPACE=\"preserve\"><span>mysql<span>&gt;</span> <span>select</span> <span>*</span> <span>from</span><span> TT;\n</span><span>+</span><span>--</span><span>----+------------+</span>\n<span>|</span> UNIT <span>|</span> DATE       <span>|</span>\n<span>+</span><span>--</span><span>----+------------+</span>\n<span>|</span> a    <span>|</span> <span>2018</span><span>-</span><span>04</span><span>-</span><span>03</span> <span>|</span>\n<span>|</span> a    <span>|</span> <span>2017</span><span>-</span><span>12</span><span>-</span><span>12</span> <span>|</span>\n<span>|</span> b    <span>|</span> <span>2018</span><span>-</span><span>01</span><span>-</span><span>01</span> <span>|</span>\n<span>|</span> b    <span>|</span> <span>2018</span><span>-</span><span>04</span><span>-</span><span>03</span> <span>|</span>\n<span>|</span> c    <span>|</span> <span>2016</span><span>-</span><span>06</span><span>-</span><span>06</span> <span>|</span>\n<span>|</span> d    <span>|</span> <span>2018</span><span>-</span><span>03</span><span>-</span><span>03</span> <span>|</span>\n<span>+</span><span>--</span><span>----+------------+</span>\n<span>6</span> rows <span>in</span> <span>set</span> (<span>0.00</span><span> sec)\n\nmysql</span><span>&gt;</span> <span>select</span> UNIT <span>as</span> <span>&apos;</span><span>单位</span><span>&apos;</span><span>,\n    </span><span>-&gt;</span>     <span>COUNT</span>(TO_DAYS(DATE)<span>=</span>TO_DAYS(NOW()) <span>or</span> <span>null</span>) <span>as</span> <span>&apos;</span><span>今日统计</span><span>&apos;</span><span>,\n    </span><span>-&gt;</span>     <span>COUNT</span>(<span>YEAR</span>(DATE)<span>=</span><span>YEAR</span>(NOW()) <span>or</span> <span>null</span>) <span>as</span> <span>&apos;</span><span>今年统计</span><span>&apos;</span>\n    <span>-&gt;</span> <span>from</span><span> v_jjd\n    </span><span>-&gt;</span> <span>group</span> <span>by</span><span> JJDW;\n</span><span>+</span><span>--</span><span>----+----------+----------+</span>\n<span>|</span> 单位  <span>|</span> 今日统计  <span>|</span> 今年统计  <span>|</span>\n<span>+</span><span>--</span><span>----+----------+----------+</span>\n<span>|</span> a    <span>|</span>        <span>1</span> <span>|</span>        <span>1</span> <span>|</span>\n<span>|</span> b    <span>|</span>        <span>1</span> <span>|</span>        <span>2</span> <span>|</span>\n<span>|</span> c    <span>|</span>        <span>0</span> <span>|</span>        <span>0</span> <span>|</span>\n<span>|</span> d    <span>|</span>        <span>0</span> <span>|</span>        <span>1</span> <span>|</span>\n<span>+</span><span>--</span><span>----+----------+----------+</span>\n<span>4</span> rows <span>in</span> <span>set</span> (<span>0.00</span> sec)</span></pre></div><p>&nbsp;</p><p ALIGN=\"left\"><span><span><a SHAPE=\"rect\" REL=\"noopener\" NAME=\"max-min\"></a>2、max和min函数</span>---统计列中的最大最小值</span></p><div><pre XML:SPACE=\"preserve\"><span>mysql&gt; <span>select</span> max(salary) <span>from</span><span> salary_tab;\n</span>+-------------+\n| max(salary) |\n+-------------+\n|     <span>3000.00</span> |\n+-------------+<span>\n\nmysql</span>&gt; <span>select</span> min(salary) <span>from</span><span> salary_tab;\n</span>+-------------+\n| min(salary) |\n+-------------+\n|     <span>1000.00</span> |\n+-------------+</span></pre></div><p ALIGN=\"left\"><span><span>注意：</span>如果统计的列中只有NULL值，那么MAX和MIN就返回NULL</span></p><p ALIGN=\"left\"><span>&nbsp;</span></p><p ALIGN=\"left\"><span><span><a SHAPE=\"rect\" REL=\"noopener\" NAME=\"sum-avg\"></a>3、sum和avg函数</span>---求和与求平均</span></p><p ALIGN=\"left\"><span>！！表中列值为null的行不参与计算</span></p><div><pre XML:SPACE=\"preserve\"><span>mysql&gt; <span>select</span> sum(salary) <span>from</span><span> salary_tab;\n</span>+-------------+\n| sum(salary) |\n+-------------+\n|     <span>7000.00</span> |\n+-------------+<span>\n\nmysql</span>&gt; <span>select</span> avg(salary) <span>from</span><span> salary_tab;\n</span>+-------------+\n| avg(salary) |\n+-------------+\n| <span>1750.000000</span> |\n+-------------+<span>\n\nmysql</span>&gt; <span>select</span> avg(ifnull(salary,<span>0</span>)) <span>from</span><span> salary_tab;\n</span>+-----------------------+\n| avg(ifnull(salary,<span>0</span>)) |\n+-----------------------+\n|           <span>1400.000000</span> |\n+-----------------------+</span></pre></div><p ALIGN=\"left\"><span><span>注意：</span>要想列值为NULL的行也参与组函数的计算，必须使用<span>IFNULL函数对NULL值做转换</span>。</span></p><p ALIGN=\"left\"><span>&nbsp;</span></p><p ALIGN=\"left\"><span>&nbsp;</span></p><p ALIGN=\"left\"><span>二、分组SELECT</span></p><div><pre XML:SPACE=\"preserve\"><span><span>SELECT select_expr [, select_expr ...]\n\n    [FROM table_references\n\n      [PARTITION partition_list]\n\n    [WHERE where_condition]\n\n    [GROUP BY {col_name </span>| expr |<span> position}\n\n      [ASC </span>|<span> DESC], ... [WITH ROLLUP]]\n\n    [HAVING where_condition]\n\n    [ORDER BY {col_name </span>| expr |<span> position}\n\n      [ASC </span>|<span> DESC], ...]\n\n[LIMIT {[offset,] row_count </span>| row_count OFFSET offset}]</span></pre></div><p ALIGN=\"left\"><span>分组SELECT的<span>基本格式：</span></span></p><p ALIGN=\"left\"><span>　　select<span>&nbsp;</span><span>[聚合函数]</span><span>&nbsp;</span><span>字段名</span><span>&nbsp;</span>from 表名</span></p><p ALIGN=\"left\"><span>　　　　[where 查询条件]</span></p><p ALIGN=\"left\"><span>　　　　[group by<span>&nbsp;</span><span>字段名</span>]</span></p><p ALIGN=\"left\"><span>　　　　<span>[having 过滤条件]</span></span></p><p ALIGN=\"left\"><span>1、group by子句</span></p><p ALIGN=\"left\"><span>　　根据给定列或者表达式的每一个不同的值将表中的行分成不同的组，使用组函数返回每一组的统计信息</span></p><p ALIGN=\"left\"><span>规则：</span></p><p ALIGN=\"left\"><span>　　①<span>出现在SELECT子句中的单独的列，必须出现在GROUP BY子句中作为分组列</span></span></p><p ALIGN=\"left\"><span>　　②<span>分组列可以不出现在SELECT子句中</span></span></p><p ALIGN=\"left\"><span>　　③分组列可出现在SELECT子句中的一个复合表达式中</span></p><p ALIGN=\"left\"><span>　　④如果GROUP BY后面是一个复合表达式，那么在SELECT子句中，它必须整体作为一个表达式的一部分才能使用。</span></p><p ALIGN=\"left\"><span>1）指定<span>一个列</span>进行分组</span></p><div><pre XML:SPACE=\"preserve\"><span>mysql&gt; <span>select</span> salary,count(*) <span>from</span><span> salary_tab\n    </span>-&gt; <span>where</span> salary&gt;=<span>2000</span>\n    -&gt;<span> group by salary;   &lt;---------重点是这句\n</span>+---------+----------+\n| salary  | count(*) |\n+---------+----------+\n| <span>2000.00</span> |        <span>1</span> |\n| <span>3000.00</span> |        <span>1</span> |\n+---------+----------+</span></pre></div><p ALIGN=\"left\"><span>2）指定<span>多个分组列</span>，&lsquo;大组中再分小组&rsquo;</span></p><div><pre XML:SPACE=\"preserve\"><span>mysql&gt; <span>select</span> userid,count(salary) <span>from</span><span> salary_tab\n    </span>-&gt; <span>where</span> salary&gt;=<span>2000</span>\n    -&gt;<span> group by salary,userid;   \n</span>+--------+---------------+\n| userid | count(salary) |\n+--------+---------------+\n|      <span>2</span> |             <span>1</span> |\n|      <span>3</span> |             <span>1</span> |\n+--------+---------------+</span></pre></div><p ALIGN=\"left\"><span>3）根据<span>表达式</span>分组</span></p><div><pre XML:SPACE=\"preserve\"><span>mysql&gt; <span>select</span> year(payment_date),count(*<span>)\n    </span>-&gt; <span>from</span><span> PENALTIES\n    </span>-&gt;<span> group by year(payment_date);\n</span>+--------------------+----------+\n| year(payment_date) | count(*) |\n+--------------------+----------+\n|               <span>1980</span> |        <span>3</span> |\n|               <span>1981</span> |        <span>1</span> |\n|               <span>1982</span> |        <span>1</span> |\n|               <span>1983</span> |        <span>1</span> |\n|               <span>1984</span> |        <span>2</span> |\n+--------------------+----------+\n<span>5</span> rows <span>in</span> <span>set</span> (<span>0.00</span> sec)</span></pre></div><p ALIGN=\"left\"><span>4）带有<span>排序的分组</span>：如果分组列和排序列相同，则可以合并group by和order by子句</span></p><div><pre XML:SPACE=\"preserve\"><span>mysql&gt; <span>select</span> teamno,count(*<span>)\n    </span>-&gt; <span>from</span><span> MATCHES\n    </span>-&gt;<span> group by teamno\n    </span>-&gt;<span> order by teamno desc;\n</span>+--------+----------+\n| teamno | count(*) |\n+--------+----------+\n|      <span>2</span> |        <span>5</span> |\n|      <span>1</span> |        <span>8</span> |\n+--------+----------+\n<span>2</span> rows <span>in</span> <span>set</span> (<span>0.00</span><span> sec)\n\nmysql</span>&gt; <span>select</span> teamno,count(*<span>)\n    </span>-&gt; <span>from</span><span> MATCHES\n    </span>-&gt;<span> group by teamno desc;　　<span>#可以把desc(或者asc)包含到group by子句中简化\n</span></span>+--------+----------+\n| teamno | count(*) |\n+--------+----------+\n|      <span>2</span> |        <span>5</span> |\n|      <span>1</span> |        <span>8</span> |\n+--------+----------+\n<span>2</span> rows <span>in</span> <span>set</span> (<span>0.00</span> sec)</span></pre></div><p><span><span>对于分组聚合</span><span>注意</span>：</span></p><p><span>　　通过select在返回集字段中，这些字段<span>要么就要包含在group by语句后面<span>，作为分组的依据</span></span>，<span>要么就要被包含在聚合函数中</span>。我们可以将group by操作想象成如下的一个过程：首先系统根据select语句得到一个结果集，然后根据分组字段，将具有相同分组字段的记录归并成了一条记录。这个时候剩下的那些不存在与group by语句后面作为分组依据的字段就很有可能出现多个值，但是目前一种分组情况只有一条记录，一个数据格是无法放入多个数值的，所以这个时候就需要通过一定的处理将这些多值的列转化成单值，然后将其放在对应的数据格中，那么完成这个步骤的就是前面讲到的聚合函数，这也就是为什么这些函数叫聚合函数了。</span></p><p ALIGN=\"left\">&nbsp;</p><p ALIGN=\"left\"><span>2、GROUP_CONCAT()函数</span></p><p ALIGN=\"left\"><span>　　函数的值等于属于一个组的指定列的所有值，<span>以逗号隔开</span>，并且以字符串表示。</span></p><p ALIGN=\"left\"><span>例1：对于每个球队，得到其编号和所有球员的编号</span></p><div><pre XML:SPACE=\"preserve\"><span>mysql&gt; <span>select</span><span> teamno,group_concat(playerno)\n    </span>-&gt; <span>from</span><span> MATCHES\n    </span>-&gt;<span> group by teamno;\n</span>+--------+------------------------+\n| teamno | group_concat(playerno) |\n+--------+------------------------+\n|      <span>1</span> | <span>6</span>,<span>6</span>,<span>6</span>,<span>44</span>,<span>83</span>,<span>2</span>,<span>57</span>,<span>8</span>     |\n|      <span>2</span> | <span>27</span>,<span>104</span>,<span>112</span>,<span>112</span>,<span>8</span>       |\n+--------+------------------------+\n<span>2</span> rows <span>in</span> <span>set</span> (<span>0.01</span> sec)</span></pre></div><p ALIGN=\"left\"><span><span>如果没有group by子句，group_concat返回一列的所有值</span></span></p><p ALIGN=\"left\"><span>例2：得到所有的罚款编号列表</span></p><div><pre XML:SPACE=\"preserve\"><span>mysql&gt; <span>select</span><span> group_concat(paymentno)\n    </span>-&gt; <span>from</span><span> PENALTIES;\n</span>+-------------------------+\n| group_concat(paymentno) |\n+-------------------------+\n| <span>1</span>,<span>2</span>,<span>3</span>,<span>4</span>,<span>5</span>,<span>6</span>,<span>7</span>,<span>8</span>         |\n+-------------------------+\n<span>1</span> row <span>in</span> <span>set</span> (<span>0.00</span> sec)</span></pre></div><p>&nbsp;</p><p ALIGN=\"left\"><span><span>3、with rollup子句：</span>用来要求在一条group by子句中<span>进行多个不同的分组</span></span></p><p ALIGN=\"left\"><span><span>用的比较少点</span>，但是有时可以根据具体的需求使用</span></p><p ALIGN=\"left\"><span>　　如果有子句GROUP BY E1,E2,E3,E4 WITH ROLLUP</span></p><p ALIGN=\"left\"><span>　　那么将分别执行以下分组：<span>[E1,E2,E3,E4]、[E1,E2,E3]、[E1,E2]、[E1]、[]</span></span></p><p ALIGN=\"left\"><span><span>注意：</span>[ ]表示所有行都分在一组中</span></p><p ALIGN=\"left\"><span>示例：按照球员的性别和居住城市，统计球员的总数；统计每个性别球员的总数；统计所有球员的总数</span></p><div><pre XML:SPACE=\"preserve\"><span>mysql&gt; <span>select</span> sex,town,count(*<span>)\n    </span>-&gt; <span>from</span><span> PLAYERS\n    </span>-&gt;<span> group by sex,town with rollup;\n</span>+-----+-----------+----------+\n| sex | town      | count(*) |\n+-----+-----------+----------+\n| F   | Eltham    |        <span>2</span> |\n| F   | Inglewood |        <span>1</span> |\n| F   | Midhurst  |        <span>1</span> |\n| F   | Plymouth  |        <span>1</span> |\n| F   | NULL      |        <span>5</span> |\n| M   | Douglas   |        <span>1</span> |\n| M   | Inglewood |        <span>1</span> |\n| M   | Stratford |        <span>7</span> |\n| M   | NULL      |        <span>9</span> |\n| NULL | NULL      |       <span>14</span> |\n+-----+-----------+----------+\n<span>10</span> rows <span>in</span> <span>set</span> (<span>0.00</span> sec)</span></pre></div><p>&nbsp;</p><p ALIGN=\"left\"><span><span>4、HAVING子句</span>：</span><span>对分组结果进行过滤</span></p><p ALIGN=\"left\"><span>注意：</span></p><p ALIGN=\"left\"><span>　　不能使用WHERE子句对分组后的结果进行过滤</span></p><p ALIGN=\"left\"><span>　　不能在WHERE子句中使用组函数，仅用于过滤行</span></p><div><pre XML:SPACE=\"preserve\"><span>mysql&gt; <span>select</span><span> playerno\n    </span>-&gt; <span>from</span><span> PENALTIES\n    </span>-&gt; <span>where</span> count(*)&gt;<span>1</span>\n    -&gt;<span> group by playerno;\nERROR </span><span>1111</span> (HY000): Invalid use of group function</span></pre></div><p ALIGN=\"left\"><span>因为<span>WHERE子句比GROUP BY<span>先执行</span></span>，而组函数<span>必须在分完组之后</span>才执行，且<span>分完组后</span><span>必须使用having子句</span>进行结果集的过滤。</span></p><p ALIGN=\"left\"><span>基本语法：</span></p><div><pre XML:SPACE=\"preserve\"><span><span>SELECT   select_expr [, select_expr ...]\n\n   FROM  table_name\n\n   [WHERE where_condition]\n\n   [GROUP BY {col_name </span>| expr} [ASC |<span> DESC], ... [WITH ROLLUP]]\n\n[HAVING where_condition]</span></span></pre></div><p ALIGN=\"left\"><span>！！！having子语句与where子语句区别：</span></p><p ALIGN=\"left\"><span>　　where子句在<span>分组前</span>对记录进行过滤；</span></p><p ALIGN=\"left\"><span>　　having子句在<span>分组后</span>对记录进行过滤</span></p><div><pre XML:SPACE=\"preserve\"><span>mysql&gt; <span>select</span> salary,count(*) <span>from</span><span> salary_tab\n    </span>-&gt; <span>where</span> salary&gt;=<span>2000</span>\n    -&gt;<span> group by salary\n    </span>-&gt; having count(*)&gt;=<span>0</span><span>;\n</span>+---------+----------+\n| salary  | count(*) |\n+---------+----------+\n| <span>2000.00</span> |        <span>1</span> |\n| <span>3000.00</span> |        <span>1</span> |\n+---------+----------+</span></pre></div><p ALIGN=\"left\"><span>1）HAVING可以单独使用而不和GROUP BY配合,如果只有HAVING子句而没有GROUP BY，表中所有的行分为一组</span></p><p ALIGN=\"left\"><span>2）HAVING子句中可以使用组函数</span></p><p ALIGN=\"left\"><span>3）<span>HAVING子句中的列，要么出现在一个组函数中，要么出现在GROUP BY子句中(否则出错)</span></span></p><div><pre XML:SPACE=\"preserve\"><span>mysql&gt; <span>select</span> town,count(*<span>)\n    </span>-&gt; <span>from</span><span> PLAYERS\n    </span>-&gt;<span> group by town\n    </span>-&gt; having birth_date&gt;<span>&apos;</span><span>1970-01-01</span><span>&apos;</span><span>;\nERROR </span><span>1054</span> (42S22): Unknown column <span>&apos;</span><span>birth_date</span><span>&apos;</span> <span>in</span> <span>&apos;</span><span>having clause</span><span>&apos;</span><span>\nmysql</span>&gt; <span>select</span> town,count(*<span>)\n    </span>-&gt; <span>from</span><span> PLAYERS\n    </span>-&gt;<span> group by town\n    </span>-&gt; having town <span>in</span> (<span>&apos;</span><span>Eltham</span><span>&apos;</span>,<span>&apos;</span><span>Midhurst</span><span>&apos;</span><span>);\n</span>+----------+----------+\n| town     | count(*) |\n+----------+----------+\n| Eltham   |        <span>2</span> |\n| Midhurst |        <span>1</span> |\n+----------+----------+\n<span>2</span> rows <span>in</span> <span>set</span> (<span>0.00</span> sec)</span></pre></div><p>&nbsp;</p><p ALIGN=\"left\"><span>&nbsp;</span></p><p ALIGN=\"left\"><span>三、集合查询操作</span></p><p ALIGN=\"left\"><span>　　union用于把两个或者多个select查询的结果集合并成一个</span></p><div><pre XML:SPACE=\"preserve\"><span><span>SELECT ...\n\nUNION [ALL </span>|<span> <span>DISTINCT</span>]\n\nSELECT ...\n\n[UNION [ALL </span>|<span> <span>DISTINCT</span>]\n\nSELECT ...]</span></span></pre></div><p ALIGN=\"left\"><span>默认情况下，<span>UNION = UNION <span>DISTINCT</span></span></span></p><p ALIGN=\"left\"><span>　　①进行合并的两个查询，其SELECT列表必须在数量和对应列的数据类型上保持一致；</span></p><p ALIGN=\"left\"><span>　　②默认会去掉两个查询结果集中的重复行；默认结果集不排序；</span></p><p ALIGN=\"left\"><span>　　③最终结果集的列名来自于第一个查询的SELECT列表</span></p><p ALIGN=\"left\"><span><span>UNION&nbsp; ALL</span>不去掉结果集中重复的行</span></p><p ALIGN=\"left\"><span><span>注：</span>联合查询结果使用第一个select语句中的字段名</span></p><div><pre XML:SPACE=\"preserve\"><span>mysql&gt; <span>select</span> * <span>from</span><span> t1;\n</span>+------+------+\n| num  | addr |\n+------+------+\n|  <span>123</span> | abc  |\n|  <span>321</span> | cba  |\n+------+------+\n<span>2</span> rows <span>in</span> <span>set</span> (<span>0.00</span><span> sec)\n\nmysql</span>&gt; <span>select</span> * <span>from</span><span> t2;\n</span>+------+------+\n| id   | name |\n+------+------+\n|    <span>1</span> | a    |\n|    <span>2</span> | A    |\n+------+------+\n<span>2</span> rows <span>in</span> <span>set</span> (<span>0.00</span><span> sec)\n\nmysql</span>&gt; <span>select</span> * <span>from</span><span> t1\n    </span>-&gt;<span> union\n    </span>-&gt; <span>select</span> * <span>from</span><span> t2;\n</span>+------+------+\n| num  | addr |\n+------+------+\n|  <span>123</span> | abc  |\n|  <span>321</span> | cba  |\n|    <span>1</span> | a    |\n|    <span>2</span> | A    |\n+------+------+\n<span>4</span> rows <span>in</span> <span>set</span> (<span>0.00</span> sec)</span></pre></div><p ALIGN=\"left\"><span>如果要对合并后的整个结果集进行排序，<span>ORDER BY子句只能出现在最后面的查询中</span></span></p><p ALIGN=\"left\"><span>注意：</span></p><p ALIGN=\"left\"><span>　　<span>在去重操作时</span>，如果列值中包含<span>NULL值</span>，认为它们是<span>相等的</span></span></p><br CLEAR=\"none\"/></div></en-note>      ",
      "content_path": null,
      "diff_base_variant_id": null,
      "metadata": {
        "checksum": "e6895190197d7974bd3fe841fc4d59fc16e9a129830f6b0f39c92c8bf35035a7",
        "path": "/Users/tang/workbench/article-classifier/backups/2023年6月/IT技术/MySQL最常用分组聚合函数.html"
      }
    },
    {
      "id": "fedf9296-30c2-42f6-ab24-2d43ead1dbae",
      "note_id": "c9104a8e-57ff-41b8-9fe9-b325bd42678a",
      "variant_type": "clean_text",
      "version": 1,
      "created_by": "evernote_ingest:v0",
      "created_at": "2025-11-09T20:05:13.274807Z",
      "content": "---\ntitle: MySQL最常用分组聚合函数\nupdated: 2022-09-09 12:26:51Z\ncreated: 2022-08-21 15:17:51Z\nauthor: tangyongfeng\ntags:\n  - mysql\n---\n\n一、\n聚合函数\n（\naggregation function\n）\n---也就是组函数\n　　\n在一个行的集合（一组行）上进行操作，对每个组给一个结果。\n常用的组函数：\nAVG([\ndistinct\n] expr)\n求平均值\nCOUNT({*|[\ndistinct\n] } expr)\n统计行的数量\nMAX([\ndistinct\n] expr)\n求最大值\nMIN([\ndistinct\n] expr)\n求最小值\nSUM([\ndistinct\n] expr)\n求累加和\n　　①每个组函数接收一个参数\n　　②默认情况下，\n组函数\n忽略列值为null的行\n，不参与计算\n　　③有时，会使用关键字distinct剔除字段值重复的条数\n注意：\n　　1）当使用组函数的select语句中没有group by子句时，中间结果集中的所有行自动形成一组，然后计算组函数；\n　　2）组函数\n不允许嵌套\n，例如：count(max(…))；\n　　3）组函数的参数可以是\n列或是函数表达式\n；\n　　4）一个SELECT子句中可出现多个聚集函数。\n \n实验演示用表：\nmysql> select * from salary_tab;\n+--------+---------+\n| userid | salary  |\n+--------+---------+\n|      1 | 1000.00 |\n|      2 | 2000.00 |\n|      3 | 3000.00 |\n|      4 |    NULL |\n|      5 | 1000.00 |\n+--------+---------+\n5 rows in set (0.00 sec)\n \nmysql> use TENNIS\nmysql>\n show tables;\n\n+-------------------+\n| Tables_in_TENNIS  |\n+-------------------+\n| COMMITTEE_MEMBERS |\n| MATCHES           |\n| PENALTIES         |\n| PLAYERS           |\n| TEAMS             |\n+-------------------+\n\n5\n rows\nin\n\nset\n (\n0.00\n sec)\n \n1、count函数\n①count(*)：返回表中满足where条件的行的数量\nmysql>\nselect\n count(*)\nfrom\n salary_tab\nwhere\n salary=\n'\n1000\n'\n;\n\n+----------+\n| count(*) |\n+----------+\n|       \n2\n |\n+----------+\n\nmysql\n>\nselect\n count(*)\nfrom\n salary_tab;　　\n#没有条件，默认统计表数据行数\n\n+----------+\n| count(*) |\n+----------+\n|       \n5\n |\n+----------+\n②\ncount(列)：\n返回列值非空的行的数量\nmysql>\nselect\n count(salary)\nfrom\n salary_tab;\n\n+---------------+\n| count(salary) |\n+---------------+\n|            \n4\n |\n+---------------+\n③\ncount(\ndistinct\n 列)：\n返回列值非空的、并且列值不重复的行的数量\nmysql>\nselect\n count(\ndistinct\n salary)\nfrom\n salary_tab;\n\n+------------------------+\n| count(\ndistinct\n salary) |\n+------------------------+\n|                     \n3\n |\n+------------------------+\n④\ncount(expr)\n：根据表达式统计数据\nmysql\n>\n\nselect\n\n*\n\nfrom\n TT;\n\n+\n--\n----+------------+\n\n|\n UNIT\n|\n DATE      \n|\n\n+\n--\n----+------------+\n\n|\n a   \n|\n\n2018\n-\n04\n-\n03\n\n|\n\n|\n a   \n|\n\n2017\n-\n12\n-\n12\n\n|\n\n|\n b   \n|\n\n2018\n-\n01\n-\n01\n\n|\n\n|\n b   \n|\n\n2018\n-\n04\n-\n03\n\n|\n\n|\n c   \n|\n\n2016\n-\n06\n-\n06\n\n|\n\n|\n d   \n|\n\n2018\n-\n03\n-\n03\n\n|\n\n+\n--\n----+------------+\n\n6\n rows\nin\n\nset\n (\n0.00\n sec)\n\nmysql\n>\n\nselect\n UNIT\nas\n\n'\n单位\n'\n,\n   \n->\n    \nCOUNT\n(TO_DAYS(DATE)\n=\nTO_DAYS(NOW())\nor\n\nnull\n)\nas\n\n'\n今日统计\n'\n,\n   \n->\n    \nCOUNT\n(\nYEAR\n(DATE)\n=\nYEAR\n(NOW())\nor\n\nnull\n)\nas\n\n'\n今年统计\n'\n\n->\n\nfrom\n v_jjd\n   \n->\n\ngroup\n\nby\n JJDW;\n\n+\n--\n----+----------+----------+\n\n|\n 单位 \n|\n 今日统计 \n|\n 今年统计 \n|\n\n+\n--\n----+----------+----------+\n\n|\n a   \n|\n       \n1\n\n|\n       \n1\n\n|\n\n|\n b   \n|\n       \n1\n\n|\n       \n2\n\n|\n\n|\n c   \n|\n       \n0\n\n|\n       \n0\n\n|\n\n|\n d   \n|\n       \n0\n\n|\n       \n1\n\n|\n\n+\n--\n----+----------+----------+\n\n4\n rows\nin\n\nset\n (\n0.00\n sec)\n \n2、max和min函数\n---统计列中的最大最小值\nmysql>\nselect\n max(salary)\nfrom\n salary_tab;\n\n+-------------+\n| max(salary) |\n+-------------+\n|    \n3000.00\n |\n+-------------+\n\nmysql\n>\nselect\n min(salary)\nfrom\n salary_tab;\n\n+-------------+\n| min(salary) |\n+-------------+\n|    \n1000.00\n |\n+-------------+\n注意：\n如果统计的列中只有NULL值，那么MAX和MIN就返回NULL\n \n3、sum和avg函数\n---求和与求平均\n！！表中列值为null的行不参与计算\nmysql>\nselect\n sum(salary)\nfrom\n salary_tab;\n\n+-------------+\n| sum(salary) |\n+-------------+\n|    \n7000.00\n |\n+-------------+\n\nmysql\n>\nselect\n avg(salary)\nfrom\n salary_tab;\n\n+-------------+\n| avg(salary) |\n+-------------+\n|\n1750.000000\n |\n+-------------+\n\nmysql\n>\nselect\n avg(ifnull(salary,\n0\n))\nfrom\n salary_tab;\n\n+-----------------------+\n| avg(ifnull(salary,\n0\n)) |\n+-----------------------+\n|          \n1400.000000\n |\n+-----------------------+\n注意：\n要想列值为NULL的行也参与组函数的计算，必须使用\nIFNULL函数对NULL值做转换\n。\n \n二、分组SELECT\nSELECT select_expr [, select_expr ...]\n\n    [FROM table_references\n\n      [PARTITION partition_list]\n\n    [WHERE where_condition]\n\n    [GROUP BY {col_name\n| expr |\n position}\n\n      [ASC\n|\n DESC], ... [WITH ROLLUP]]\n\n    [HAVING where_condition]\n\n    [ORDER BY {col_name\n| expr |\n position}\n\n      [ASC\n|\n DESC], ...]\n\n[LIMIT {[offset,] row_count\n| row_count OFFSET offset}]\n分组SELECT的\n基本格式：\n　　select\n \n[聚合函数]\n \n字段名\n \nfrom 表名\n　　　　[where 查询条件]\n　　　　[group by\n \n字段名\n]\n　　　　\n[having 过滤条件]\n1、group by子句\n　　根据给定列或者表达式的每一个不同的值将表中的行分成不同的组，使用组函数返回每一组的统计信息\n规则：\n　　①\n出现在SELECT子句中的单独的列，必须出现在GROUP BY子句中作为分组列\n　　②\n分组列可以不出现在SELECT子句中\n　　③分组列可出现在SELECT子句中的一个复合表达式中\n　　④如果GROUP BY后面是一个复合表达式，那么在SELECT子句中，它必须整体作为一个表达式的一部分才能使用。\n1）指定\n一个列\n进行分组\nmysql>\nselect\n salary,count(*)\nfrom\n salary_tab\n   \n->\nwhere\n salary>=\n2000\n\n    ->\n group by salary;   <---------重点是这句\n\n+---------+----------+\n| salary  | count(*) |\n+---------+----------+\n|\n2000.00\n |       \n1\n |\n3000.00\n |       \n1\n |\n+---------+----------+\n2）指定\n多个分组列\n，‘大组中再分小组’\nmysql>\nselect\n userid,count(salary)\nfrom\n salary_tab\n   \n->\nwhere\n salary>=\n2000\n\n    ->\n group by salary,userid;  \n\n+--------+---------------+\n| userid | count(salary) |\n+--------+---------------+\n|     \n2\n |            \n1\n |\n3\n |            \n1\n |\n+--------+---------------+\n3）根据\n表达式\n分组\nmysql>\nselect\n year(payment_date),count(*\n)\n   \n->\nfrom\n PENALTIES\n   \n->\n group by year(payment_date);\n\n+--------------------+----------+\n| year(payment_date) | count(*) |\n+--------------------+----------+\n|              \n1980\n |       \n3\n |\n1981\n |       \n1\n |\n1982\n |       \n1\n |\n1983\n |       \n1\n |\n1984\n |       \n2\n |\n+--------------------+----------+\n\n5\n rows\nin\n\nset\n (\n0.00\n sec)\n4）带有\n排序的分组\n：如果分组列和排序列相同，则可以合并group by和order by子句\nmysql>\nselect\n teamno,count(*\n)\n   \n->\nfrom\n MATCHES\n   \n->\n group by teamno\n   \n->\n order by teamno desc;\n\n+--------+----------+\n| teamno | count(*) |\n+--------+----------+\n|     \n2\n |       \n5\n |\n1\n |       \n8\n |\n+--------+----------+\n\n2\n rows\nin\n\nset\n (\n0.00\n sec)\n\nmysql\n>\nselect\n teamno,count(*\n)\n   \n->\nfrom\n MATCHES\n   \n->\n group by teamno desc;　　\n#可以把desc(或者asc)包含到group by子句中简化\n\n+--------+----------+\n| teamno | count(*) |\n+--------+----------+\n|     \n2\n |       \n5\n |\n1\n |       \n8\n |\n+--------+----------+\n\n2\n rows\nin\n\nset\n (\n0.00\n sec)\n对于分组聚合\n注意\n：\n　　通过select在返回集字段中，这些字段\n要么就要包含在group by语句后面\n，作为分组的依据\n，\n要么就要被包含在聚合函数中\n。我们可以将group by操作想象成如下的一个过程：首先系统根据select语句得到一个结果集，然后根据分组字段，将具有相同分组字段的记录归并成了一条记录。这个时候剩下的那些不存在与group by语句后面作为分组依据的字段就很有可能出现多个值，但是目前一种分组情况只有一条记录，一个数据格是无法放入多个数值的，所以这个时候就需要通过一定的处理将这些多值的列转化成单值，然后将其放在对应的数据格中，那么完成这个步骤的就是前面讲到的聚合函数，这也就是为什么这些函数叫聚合函数了。\n \n2、GROUP_CONCAT()函数\n　　函数的值等于属于一个组的指定列的所有值，\n以逗号隔开\n，并且以字符串表示。\n例1：对于每个球队，得到其编号和所有球员的编号\nmysql>\nselect\n teamno,group_concat(playerno)\n   \n->\nfrom\n MATCHES\n   \n->\n group by teamno;\n\n+--------+------------------------+\n| teamno | group_concat(playerno) |\n+--------+------------------------+\n|     \n1\n |\n6\n,\n6\n,\n6\n,\n44\n,\n83\n,\n2\n,\n57\n,\n8\n     |\n2\n |\n27\n,\n104\n,\n112\n,\n112\n,\n8\n       |\n+--------+------------------------+\n\n2\n rows\nin\n\nset\n (\n0.01\n sec)\n如果没有group by子句，group_concat返回一列的所有值\n例2：得到所有的罚款编号列表\nmysql>\nselect\n group_concat(paymentno)\n   \n->\nfrom\n PENALTIES;\n\n+-------------------------+\n| group_concat(paymentno) |\n+-------------------------+\n|\n1\n,\n2\n,\n3\n,\n4\n,\n5\n,\n6\n,\n7\n,\n8\n         |\n+-------------------------+\n\n1\n row\nin\n\nset\n (\n0.00\n sec)\n \n3、with rollup子句：\n用来要求在一条group by子句中\n进行多个不同的分组\n用的比较少点\n，但是有时可以根据具体的需求使用\n　　如果有子句GROUP BY E1,E2,E3,E4 WITH ROLLUP\n　　那么将分别执行以下分组：\n[E1,E2,E3,E4]、[E1,E2,E3]、[E1,E2]、[E1]、[]\n注意：\n[ ]表示所有行都分在一组中\n示例：按照球员的性别和居住城市，统计球员的总数；统计每个性别球员的总数；统计所有球员的总数\nmysql>\nselect\n sex,town,count(*\n)\n   \n->\nfrom\n PLAYERS\n   \n->\n group by sex,town with rollup;\n\n+-----+-----------+----------+\n| sex | town      | count(*) |\n+-----+-----------+----------+\n| F   | Eltham    |       \n2\n |\n| F   | Inglewood |       \n1\n |\n| F   | Midhurst  |       \n1\n |\n| F   | Plymouth  |       \n1\n |\n| F   | NULL      |       \n5\n |\n| M   | Douglas   |       \n1\n |\n| M   | Inglewood |       \n1\n |\n| M   | Stratford |       \n7\n |\n| M   | NULL      |       \n9\n |\n| NULL | NULL      |      \n14\n |\n+-----+-----------+----------+\n\n10\n rows\nin\n\nset\n (\n0.00\n sec)\n \n4、HAVING子句\n：\n对分组结果进行过滤\n注意：\n　　不能使用WHERE子句对分组后的结果进行过滤\n　　不能在WHERE子句中使用组函数，仅用于过滤行\nmysql>\nselect\n playerno\n   \n->\nfrom\n PENALTIES\n   \n->\nwhere\n count(*)>\n1\n\n    ->\n group by playerno;\nERROR\n1111\n (HY000): Invalid use of group function\n因为\nWHERE子句比GROUP BY\n先执行\n，而组函数\n必须在分完组之后\n才执行，且\n分完组后\n必须使用having子句\n进行结果集的过滤。\n基本语法：\nSELECT   select_expr [, select_expr ...]\n\n   FROM  table_name\n\n   [WHERE where_condition]\n\n   [GROUP BY {col_name\n| expr} [ASC |\n DESC], ... [WITH ROLLUP]]\n\n[HAVING where_condition]\n！！！having子语句与where子语句区别：\n　　where子句在\n分组前\n对记录进行过滤；\n　　having子句在\n分组后\n对记录进行过滤\nmysql>\nselect\n salary,count(*)\nfrom\n salary_tab\n   \n->\nwhere\n salary>=\n2000\n\n    ->\n group by salary\n   \n-> having count(*)>=\n0\n;\n\n+---------+----------+\n| salary  | count(*) |\n+---------+----------+\n|\n2000.00\n |       \n1\n |\n3000.00\n |       \n1\n |\n+---------+----------+\n1）HAVING可以单独使用而不和GROUP BY配合,如果只有HAVING子句而没有GROUP BY，表中所有的行分为一组\n2）HAVING子句中可以使用组函数\n3）\nHAVING子句中的列，要么出现在一个组函数中，要么出现在GROUP BY子句中(否则出错)\nmysql>\nselect\n town,count(*\n)\n   \n->\nfrom\n PLAYERS\n   \n->\n group by town\n   \n-> having birth_date>\n'\n1970-01-01\n'\n;\nERROR\n1054\n (42S22): Unknown column\n'\nbirth_date\n'\n\nin\n\n'\nhaving clause\n'\n\nmysql\n>\nselect\n town,count(*\n)\n   \n->\nfrom\n PLAYERS\n   \n->\n group by town\n   \n-> having town\nin\n (\n'\nEltham\n'\n,\n'\nMidhurst\n'\n);\n\n+----------+----------+\n| town     | count(*) |\n+----------+----------+\n| Eltham   |       \n2\n |\n| Midhurst |       \n1\n |\n+----------+----------+\n\n2\n rows\nin\n\nset\n (\n0.00\n sec)\n \n三、集合查询操作\n　　union用于把两个或者多个select查询的结果集合并成一个\nSELECT ...\n\nUNION [ALL\n|\n\nDISTINCT\n]\n\nSELECT ...\n\n[UNION [ALL\n|\n\nDISTINCT\n]\n\nSELECT ...]\n默认情况下，\nUNION = UNION\nDISTINCT\n　　①进行合并的两个查询，其SELECT列表必须在数量和对应列的数据类型上保持一致；\n　　②默认会去掉两个查询结果集中的重复行；默认结果集不排序；\n　　③最终结果集的列名来自于第一个查询的SELECT列表\nUNION  ALL\n不去掉结果集中重复的行\n注：\n联合查询结果使用第一个select语句中的字段名\nmysql>\nselect\n *\nfrom\n t1;\n\n+------+------+\n| num  | addr |\n+------+------+\n| \n123\n | abc  |\n| \n321\n | cba  |\n+------+------+\n\n2\n rows\nin\n\nset\n (\n0.00\n sec)\n\nmysql\n>\nselect\n *\nfrom\n t2;\n\n+------+------+\n| id   | name |\n+------+------+\n|   \n1\n | a    |\n|   \n2\n | A    |\n+------+------+\n\n2\n rows\nin\n\nset\n (\n0.00\n sec)\n\nmysql\n>\nselect\n *\nfrom\n t1\n   \n->\n union\n   \n->\nselect\n *\nfrom\n t2;\n\n+------+------+\n| num  | addr |\n+------+------+\n| \n123\n | abc  |\n| \n321\n | cba  |\n|   \n1\n | a    |\n|   \n2\n | A    |\n+------+------+\n\n4\n rows\nin\n\nset\n (\n0.00\n sec)\n如果要对合并后的整个结果集进行排序，\nORDER BY子句只能出现在最后面的查询中\n注意：\n　　\n在去重操作时\n，如果列值中包含\nNULL值\n，认为它们是\n相等的",
      "content_path": null,
      "diff_base_variant_id": null,
      "metadata": {
        "language": "en",
        "length": 10153,
        "rule_count": 2,
        "applied_rules": [
          {
            "rule_id": "dedupe_lines",
            "description": "Collapse adjacent duplicate lines",
            "note": "collapsed duplicate adjacent lines"
          },
          {
            "rule_id": "whitespace",
            "description": "Normalize whitespace",
            "note": "collapsed whitespace"
          }
        ]
      }
    }
  ],
  "extractions": [],
  "journal": {
    "id": "cf3cc045-3591-42f6-a5db-5b3c92b21731",
    "note_id": "c9104a8e-57ff-41b8-9fe9-b325bd42678a",
    "stage": "ingest",
    "agent_id": "evernote_ingest:v0",
    "started_at": "2025-11-09T20:05:13.274812Z",
    "finished_at": "2025-11-09T20:05:13.274813Z",
    "status": "success",
    "input_ref": {
      "task_id": "9324692f-8317-4932-ae1a-e97f4c9c8ee4",
      "source_path": "/Users/tang/workbench/article-classifier/backups/2023年6月/IT技术/MySQL最常用分组聚合函数.html",
      "checksum": "e6895190197d7974bd3fe841fc4d59fc16e9a129830f6b0f39c92c8bf35035a7"
    },
    "output_ref": {
      "ingest_source": "e428d8c8-b4ec-4550-ab91-670fd6451891",
      "note": "c9104a8e-57ff-41b8-9fe9-b325bd42678a",
      "variants": [
        "df614ded-931a-4074-85b1-af5ce1cfe603",
        "fedf9296-30c2-42f6-ab24-2d43ead1dbae"
      ]
    },
    "error_detail": null
  }
}
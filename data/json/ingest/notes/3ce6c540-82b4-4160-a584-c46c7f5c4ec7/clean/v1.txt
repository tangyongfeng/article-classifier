---
title: Linux系统无线网络抓包程序(分析手机WIFI MAC地址)-echojb.com
updated: 2018-11-09 08:42:57Z
created: 2018-11-09 08:42:57Z
source: http://www.echojb.com/wireless/2017/01/17/304182.html
---

Linux系统无线网络抓包程序(分析手机WIFI MAC地址)

首先要介绍ieee802.11的帧格式，只有知道帧格式才能正确解析对应字段，拿到我们感兴趣的信息。其次介绍Linux raw socket编程抓包。最后解析ieee802.11数据包，从而获取到MAC地址。实际上，从数据包中可以得到很多信息，这些信息就是后续需要继续进行的事了。
一、ieee802.11帧格式
ieee802.11帧格式如下图所示：

二、C实现socket抓包
 Linux系统抓包使用SOCK_RAW方式，类型为ETH_P_ALL(表示抓取所有类型的帧，不管是IP帧还是ARP帧)。下面给出代码重要函数代码片段。为减小文章篇幅，保留主要代码函数，至于完整代码，请参阅文章后面的附录。
1、设置混杂模式
抓包工具都会开启混杂模式(promisc)，下面是代码：
// 混杂模式
bool set_promisc_mode(const char* eth, bool promisc)
{
    int org_errno = 0;
    int fd;
    struct ifreq ifreq;

    if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
        return false;

    memset(&ifreq, 0, sizeof(ifreq));
    strncpy(ifreq.ifr_name, eth, IF_NAMESIZE - 1);

    ioctl(fd, SIOCGIFFLAGS, &ifreq);

    // check if eth is up
    if (!(ifreq.ifr_flags & IFF_UP))
    {
        printf("%s is not up yet.n", eth);
        return false;
    }

    if (promisc)
        ifreq.ifr_flags |= IFF_PROMISC;
    else
        ifreq.ifr_flags &= ~IFF_PROMISC;

    ioctl(fd, SIOCSIFFLAGS, &ifreq);

    if (close(fd))
        return false;

    return true;
}
2、初始化socket
初始化socket包括创建RAW socket，绑定指定网卡。
int init_socket(const char* eth)
{
    int ret = 0;
    int fd = -1;

    // 混杂模式
    if (!set_promisc_mode(eth, true))
    {
        //printf("set %s to promisc mode failed.n", eth);
        return -1;
    }

    // 注意与下面绑定时协议一致
    fd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));

    // 绑定网卡
    struct ifreq req;
    strcpy(req.ifr_name, eth);
    ioctl(fd, SIOCGIFINDEX, &req);

    struct sockaddr_ll addr;
    addr.sll_family = PF_PACKET;
    addr.sll_ifindex = req.ifr_ifindex;
    addr.sll_protocol = htons(ETH_P_ALL);
    ret = bind(fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_ll));
   
    return fd;
}

3、获取网卡信息

int get_hwinfo(int fd, char* eth, unsigned char* mac)
{
    struct ifreq ifr;

    memset(&ifr, 0, sizeof(ifr));
    strncpy(ifr.ifr_name, eth, IFNAMSIZ - 1);
    ifr.ifr_name[IFNAMSIZ - 1] = '';

    if (ioctl(fd, SIOCGIFHWADDR, &ifr) < 0)
    {
        printf("Could not get arptypen");
        return -1;
    }
    printf("ARPTYPE %dn", ifr.ifr_hwaddr.sa_family);
    memcpy(mac, ifr.ifr_hwaddr.sa_data, 6);
    return ifr.ifr_hwaddr.sa_family;
}

注意，函数返回的sa_family十分重要，它是判断抓取的帧类型的依据。跟踪SIOCGIFHWADDR调用过程，发现内核驱动将dev->dev_addr赋值给ifr->ifr_hwaddr.sa_data，而dev->type赋值给ifr->ifr_hwaddr.sa_family。
4、接收数据
一般网络接收数据都会使用select模型，使用recv即可收到内核传递的数据。
int receive_packet(int socket)
{
    int ret = 0;

    struct timeval tv;

    static fd_set read_fds;

    tv.tv_sec = 0;
    tv.tv_usec = 100;

    FD_ZERO(&read_fds);
    FD_SET(socket, &read_fds);

    ret = select(socket+1, &read_fds, NULL, NULL, &tv);

    if (ret == -1 && errno == EINTR) /* interrupted */
        return -1;
    if (ret == 0)
        return -1;
    else if (ret < 0)
        return -1;

    if (FD_ISSET(socket, &read_fds))
    {
        memset(buffer, '', BUFFER_SIZE);
        ret = recv(socket, buffer, BUFFER_SIZE, MSG_DONTWAIT);
        if (ret <= 0)
            return -1;
        //printf("--recv len: %dn", ret);
        if (debug_level)
        {
            dump(buffer, ret);
            printf("====================n");
        }
        if (arphrd == 1)
            parse_packet(buffer, ret); // ieee802.3包
        else if (arphrd == 802 || arphrd == 803) // ieee802.11包
            parse_packet_wlan(buffer, ret);
    }

    return 0;
}
三、解析
下图是笔者手机发的probe request帧截图(使用tcpdump抓包，再用wireshark查看)。

1、radiotap头部
radiotap包含大量有用信息，比如SSI信号强度。但我们暂时不需要，直接跳过。它的结构体定义如下：
// radiotap头部
// radiotap官网：http://www.radiotap.org/
struct ieee80211_radiotap_header {
        uint8_t        it_version;     /* set to 0 */
        uint8_t        it_pad;
        uint16_t       it_len;         /* entire length */
        uint32_t       it_present;     /* fields present */
} __attribute__((__packed__));

其中的it_len成员表示整个radiotap头部的大小。因此在代码中直接使用it_len作偏移量计算出ieee802.11头部地址。

2、ieee802.11头部
ieee802.11头部结构体如下：
// 802.11帧头
struct wlan_frame {
 uint16_t fc;
 uint16_t duration;
 uint8_t addr1[6];
 uint8_t addr2[6];
 uint8_t addr3[6];
 uint16_t seq;
 union {
 uint16_t qos;
 uint8_t addr4[6];
 struct {
 uint16_t qos;
 uint32_t ht;
 } __attribute__ ((packed)) ht;
 struct {
 uint8_t addr4[6];
 uint16_t qos;
 uint32_t ht;
 } __attribute__ ((packed)) addr4_qos_ht;
 } u;
} __attribute__ ((packed));
从前面的图示知道，addr1为接收方(Receiver)MAC地址，addr2为发送者(Transmitter)MAC地址，addr3为BSSID。不同类型的帧，Receiver和Transmitter不同，对于probe request类型帧来说，Transmitter地址即为所需要的MAC号——因为probe都是广播，目标地址都是ff。

下面是解析ieee802.11的函数代码：

int parse_packet_wlan(const char* buffer, int len)
{
    int hdrlen = 0;
    uint16_t fc = 0;
 uint8_t* ra = NULL;
 uint8_t* ta = NULL;
 uint8_t* bssid = NULL;
   
    struct ieee80211_radiotap_header* radiotap_header = NULL;
    struct wlan_frame* wh = NULL;
   
    if (buffer == NULL)
    {
        return -1;
    }

    radiotap_header = (struct ieee80211_radiotap_header*)buffer;
    // it_len表示整个radiotap信息，包括头部，因此直接跳过到ieee80211头部
    int radiotap_len = radiotap_header->it_len;
    wh = (struct wlan_frame*)(buffer+radiotap_len);
   
    fc = le16toh(wh->fc); // 传输格式为little endian，要转换成host格式
    int wlan_type = (fc & 0xfc);
    int type = (fc & 0xc)>>2;
    int stype = (fc & 0xf0)>>4;
 //printf("fc:0x%x wlan_type 0x%x - type 0x%x - stype 0x%x n", fc, wlan_type, type, stype);
   
    // 数据帧
    if (type == 0x02)
    {
       
    }
    // 控制帧
    else if (type == 0x01)
    {
       
    }
    // 管理帧
    else if (type == 0x0)
    {
        if (stype == 0x04) // probe帧
        {
            ra = wh->addr1;
            ta = wh->addr2;
            bssid = wh->addr3;
            if (ta)
                printf("SRC MAC: [" MACFMT "] --> ", MAC2ADDR(ta));
            if (ra)
                printf("DST MAC: [" MACFMT "]", MAC2ADDR(ra));
            if (bssid)
                printf(" BSSID MAC: [" MACFMT "]", MAC2ADDR(bssid));
            printf("n");   
        }
    else
    {
        printf("unknown frame.n");
        return -1;
    }

    return 0;
}
看上去十分简单，因为我们只需要其中一种帧的MAC地址信息，其它一概忽视。 

下图是扫描probe得到的MAC地址，并且根据OUI查出MAC所属组织名称(代码需修改)：
 
修改后的版本演示结果如下(代码需修改)：

附代码：





A+

分享到：
百度云收藏
QQ空间
百度
贴吧
新浪
微信
天涯
邮件分享
复制网址
.

Date：2017-01-17

Tag：
程序
　
手机
　
WIFI
　
分析
　
MAC
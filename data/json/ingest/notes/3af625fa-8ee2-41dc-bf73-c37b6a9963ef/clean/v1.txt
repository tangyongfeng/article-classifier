---
title: hynnet/openwrt-mt7620
updated: 2018-11-14 06:47:42Z
created: 2018-11-14 06:47:42Z
source: >-
  https://github.com/hynnet/openwrt-mt7620/blob/master/staging_dir/target-mipsel_r2_uClibc-0.9.33.2/usr/include/wireless.h
tags:
  - ioctl
  - openwrt
  - wifi
---

1

/*

2

 * This file define a set of standard wireless extensions

3

 *

4

 * Version : 21 14.3.06

5

 *

6

 * Authors : Jean Tourrilhes - HPL - <jt@hpl.hp.com>

7

 * Copyright (c) 1997-2005 Jean Tourrilhes, All Rights Reserved.

8

*/

9

10

#
ifndef
 _LINUX_WIRELESS_H

11

#
define

_LINUX_WIRELESS_H

12

13

/*
************************* DOCUMENTATION *************************
*/

14

/*

15

 * Initial APIs (1996 -> onward) :

16

 * -----------------------------

17

 * Basically, the wireless extensions are for now a set of standard ioctl

18

 * call + /proc/net/wireless

19

 *

20

 * The entry /proc/net/wireless give statistics and information on the

21

 * driver.

22

 * This is better than having each driver having its entry because

23

 * its centralised and we may remove the driver module safely.

24

 *

25

 * Ioctl are used to configure the driver and issue commands.  This is

26

 * better than command line options of insmod because we may want to

27

 * change dynamically (while the driver is running) some parameters.

28

 *

29

 * The ioctl mechanimsm are copied from standard devices ioctl.

30

 * We have the list of command plus a structure descibing the

31

 * data exchanged...

32

 * Note that to add these ioctl, I was obliged to modify :

33

 * # net/core/dev.c (two place + add include)

34

 * # net/ipv4/af_inet.c (one place + add include)

35

 *

36

 * /proc/net/wireless is a copy of /proc/net/dev.

37

 * We have a structure for data passed from the driver to /proc/net/wireless

38

 * Too add this, I've modified :

39

 * # net/core/dev.c (two other places)

40

 * # include/linux/netdevice.h (one place)

41

 * # include/linux/proc_fs.h (one place)

42

 *

43

 * New driver API (2002 -> onward) :

44

 * -------------------------------

45

 * This file is only concerned with the user space API and common definitions.

46

 * The new driver API is defined and documented in :

47

 * # include/net/iw_handler.h

48

 *

49

 * Note as well that /proc/net/wireless implementation has now moved in :

50

 * # net/core/wireless.c

51

 *

52

 * Wireless Events (2002 -> onward) :

53

 * --------------------------------

54

 * Events are defined at the end of this file, and implemented in :

55

 * # net/core/wireless.c

56

 *

57

 * Other comments :

58

 * --------------

59

 * Do not add here things that are redundant with other mechanisms

60

 * (drivers init, ifconfig, /proc/net/dev, ...) and with are not

61

 * wireless specific.

62

 *

63

 * These wireless extensions are not magic : each driver has to provide

64

 * support for them...

65

 *

66

 * IMPORTANT NOTE : As everything in the kernel, this is very much a

67

 * work in progress. Contact me if you have ideas of improvements...

68

*/

69

70

/*
**************************** INCLUDES ****************************
*/

71

72

/*
 This header is used in user-space, therefore need to be sanitised

73

 * for that purpose. Those includes are usually not compatible with glibc.

74

 * To know which includes to use in user-space, check iwlib.h.
*/

75

#
ifdef
 __KERNEL__

76

#
include

<
linux/types.h
>

/*
 for "caddr_t" et al
*/

77

#
include

<
linux/socket.h
>

/*
 for "struct sockaddr" et al
*/

78

#
include

<
linux/if.h
>

/*
 for IFNAMSIZ and co...
*/

79

#
endif

/*
 __KERNEL__
*/

80

81

/*
**************************** VERSION ****************************
*/

82

/*

83

 * This constant is used to know the availability of the wireless

84

 * extensions and to know which version of wireless extensions it is

85

 * (there is some stuff that will be added in the future...)

86

 * I just plan to increment with each new version.

87

*/

88

#
define

WIRELESS_EXT

21

89

90

/*

91

 * Changes :

92

 *

93

 * V2 to V3

94

 * --------

95

 * Alan Cox start some incompatibles changes. I've integrated a bit more.

96

 * - Encryption renamed to Encode to avoid US regulation problems

97

 * - Frequency changed from float to struct to avoid problems on old 386

98

 *

99

 * V3 to V4

100

 * --------

101

 * - Add sensitivity

102

 *

103

 * V4 to V5

104

 * --------

105

 * - Missing encoding definitions in range

106

 * - Access points stuff

107

 *

108

 * V5 to V6

109

 * --------

110

 * - 802.11 support (ESSID ioctls)

111

 *

112

 * V6 to V7

113

 * --------

114

 * - define IW_ESSID_MAX_SIZE and IW_MAX_AP

115

 *

116

 * V7 to V8

117

 * --------

118

 * - Changed my e-mail address

119

 * - More 802.11 support (nickname, rate, rts, frag)

120

 * - List index in frequencies

121

 *

122

 * V8 to V9

123

 * --------

124

 * - Support for 'mode of operation' (ad-hoc, managed...)

125

 * - Support for unicast and multicast power saving

126

 * - Change encoding to support larger tokens (>64 bits)

127

 * - Updated iw_params (disable, flags) and use it for NWID

128

 * - Extracted iw_point from iwreq for clarity

129

 *

130

 * V9 to V10

131

 * ---------

132

 * - Add PM capability to range structure

133

 * - Add PM modifier : MAX/MIN/RELATIVE

134

 * - Add encoding option : IW_ENCODE_NOKEY

135

 * - Add TxPower ioctls (work like TxRate)

136

 *

137

 * V10 to V11

138

 * ----------

139

 * - Add WE version in range (help backward/forward compatibility)

140

 * - Add retry ioctls (work like PM)

141

 *

142

 * V11 to V12

143

 * ----------

144

 * - Add SIOCSIWSTATS to get /proc/net/wireless programatically

145

 * - Add DEV PRIVATE IOCTL to avoid collisions in SIOCDEVPRIVATE space

146

 * - Add new statistics (frag, retry, beacon)

147

 * - Add average quality (for user space calibration)

148

 *

149

 * V12 to V13

150

 * ----------

151

 * - Document creation of new driver API.

152

 * - Extract union iwreq_data from struct iwreq (for new driver API).

153

 * - Rename SIOCSIWNAME as SIOCSIWCOMMIT

154

 *

155

 * V13 to V14

156

 * ----------

157

 * - Wireless Events support : define struct iw_event

158

 * - Define additional specific event numbers

159

 * - Add "addr" and "param" fields in union iwreq_data

160

 * - AP scanning stuff (SIOCSIWSCAN and friends)

161

 *

162

 * V14 to V15

163

 * ----------

164

 * - Add IW_PRIV_TYPE_ADDR for struct sockaddr private arg

165

 * - Make struct iw_freq signed (both m & e), add explicit padding

166

 * - Add IWEVCUSTOM for driver specific event/scanning token

167

 * - Add IW_MAX_GET_SPY for driver returning a lot of addresses

168

 * - Add IW_TXPOW_RANGE for range of Tx Powers

169

 * - Add IWEVREGISTERED & IWEVEXPIRED events for Access Points

170

 * - Add IW_MODE_MONITOR for passive monitor

171

 *

172

 * V15 to V16

173

 * ----------

174

 * - Increase the number of bitrates in iw_range to 32 (for 802.11g)

175

 * - Increase the number of frequencies in iw_range to 32 (for 802.11b+a)

176

 * - Reshuffle struct iw_range for increases, add filler

177

 * - Increase IW_MAX_AP to 64 for driver returning a lot of addresses

178

 * - Remove IW_MAX_GET_SPY because conflict with enhanced spy support

179

 * - Add SIOCSIWTHRSPY/SIOCGIWTHRSPY and "struct iw_thrspy"

180

 * - Add IW_ENCODE_TEMP and iw_range->encoding_login_index

181

 *

182

 * V16 to V17

183

 * ----------

184

 * - Add flags to frequency -> auto/fixed

185

 * - Document (struct iw_quality *)->updated, add new flags (INVALID)

186

 * - Wireless Event capability in struct iw_range

187

 * - Add support for relative TxPower (yick !)

188

 *

189

 * V17 to V18 (From Jouni Malinen <jkmaline@cc.hut.fi>)

190

 * ----------

191

 * - Add support for WPA/WPA2

192

 * - Add extended encoding configuration (SIOCSIWENCODEEXT and

193

 *   SIOCGIWENCODEEXT)

194

 * - Add SIOCSIWGENIE/SIOCGIWGENIE

195

 * - Add SIOCSIWMLME

196

 * - Add SIOCSIWPMKSA

197

 * - Add struct iw_range bit field for supported encoding capabilities

198

 * - Add optional scan request parameters for SIOCSIWSCAN

199

 * - Add SIOCSIWAUTH/SIOCGIWAUTH for setting authentication and WPA

200

 *   related parameters (extensible up to 4096 parameter values)

201

 * - Add wireless events: IWEVGENIE, IWEVMICHAELMICFAILURE,

202

 *   IWEVASSOCREQIE, IWEVASSOCRESPIE, IWEVPMKIDCAND

203

 *

204

 * V18 to V19

205

 * ----------

206

 * - Remove (struct iw_point *)->pointer from events and streams

207

 * - Remove header includes to help user space

208

 * - Increase IW_ENCODING_TOKEN_MAX from 32 to 64

209

 * - Add IW_QUAL_ALL_UPDATED and IW_QUAL_ALL_INVALID macros

210

 * - Add explicit flag to tell stats are in dBm : IW_QUAL_DBM

211

 * - Add IW_IOCTL_IDX() and IW_EVENT_IDX() macros

212

 *

213

 * V20 to V21

214

 * ----------

215

 * - Remove (struct net_device *)->get_wireless_stats()

216

 * - Change length in ESSID and NICK to strlen() instead of strlen()+1

217

 * - Add SIOCSIWMODUL/SIOCGIWMODUL for modulation setting

218

 * - Add IW_RETRY_SHORT/IW_RETRY_LONG retry modifiers

219

 * - Add IW_POWER_SAVING power type

220

 * - Power/Retry relative values no longer * 100000

221

 * - Add bitrate flags for unicast/broadcast

222

*/

223

224

/*
*************************** CONSTANTS ***************************
*/

225

226

/*
 -------------------------- IOCTL LIST --------------------------
*/

227

228

/*
 Wireless Identification
*/

229

#
define

SIOCSIWCOMMIT

0x8B00

/*
 Commit pending changes to driver
*/

230

#
define

SIOCGIWNAME

0x8B01

/*
 get name == wireless protocol
*/

231

/*
 SIOCGIWNAME is used to verify the presence of Wireless Extensions.

232

 * Common values : "IEEE 802.11-DS", "IEEE 802.11-FH", "IEEE 802.11b"...

233

 * Don't put the name of your driver there, it's useless.
*/

234

235

/*
 Basic operations
*/

236

#
define

SIOCSIWNWID

0x8B02

/*
 set network id (pre-802.11)
*/

237

#
define

SIOCGIWNWID

0x8B03

/*
 get network id (the cell)
*/

238

#
define

SIOCSIWFREQ

0x8B04

/*
 set channel/frequency (Hz)
*/

239

#
define

SIOCGIWFREQ

0x8B05

/*
 get channel/frequency (Hz)
*/

240

#
define

SIOCSIWMODE

0x8B06

/*
 set operation mode
*/

241

#
define

SIOCGIWMODE

0x8B07

/*
 get operation mode
*/

242

#
define

SIOCSIWSENS

0x8B08

/*
 set sensitivity (dBm)
*/

243

#
define

SIOCGIWSENS

0x8B09

/*
 get sensitivity (dBm)
*/

244

245

/*
 Informative stuff
*/

246

#
define

SIOCSIWRANGE

0x8B0A

/*
 Unused
*/

247

#
define

SIOCGIWRANGE

0x8B0B

/*
 Get range of parameters
*/

248

#
define

SIOCSIWPRIV

0x8B0C

/*
 Unused
*/

249

#
define

SIOCGIWPRIV

0x8B0D

/*
 get private ioctl interface info
*/

250

#
define

SIOCSIWSTATS

0x8B0E

/*
 Unused
*/

251

#
define

SIOCGIWSTATS

0x8B0F

/*
 Get /proc/net/wireless stats
*/

252

/*
 SIOCGIWSTATS is strictly used between user space and the kernel, and

253

 * is never passed to the driver (i.e. the driver will never see it).
*/

254

255

/*
 Spy support (statistics per MAC address - used for Mobile IP support)
*/

256

#
define

SIOCSIWSPY

0x8B10

/*
 set spy addresses
*/

257

#
define

SIOCGIWSPY

0x8B11

/*
 get spy info (quality of link)
*/

258

#
define

SIOCSIWTHRSPY

0x8B12

/*
 set spy threshold (spy event)
*/

259

#
define

SIOCGIWTHRSPY

0x8B13

/*
 get spy threshold
*/

260

261

/*
 Access Point manipulation
*/

262

#
define

SIOCSIWAP

0x8B14

/*
 set access point MAC addresses
*/

263

#
define

SIOCGIWAP

0x8B15

/*
 get access point MAC addresses
*/

264

#
define

SIOCGIWAPLIST

0x8B17

/*
 Deprecated in favor of scanning
*/

265

#
define

SIOCSIWSCAN

0x8B18

/*
 trigger scanning (list cells)
*/

266

#
define

SIOCGIWSCAN

0x8B19

/*
 get scanning results
*/

267

268

/*
 802.11 specific support
*/

269

#
define

SIOCSIWESSID

0x8B1A

/*
 set ESSID (network name)
*/

270

#
define

SIOCGIWESSID

0x8B1B

/*
 get ESSID
*/

271

#
define

SIOCSIWNICKN

0x8B1C

/*
 set node name/nickname
*/

272

#
define

SIOCGIWNICKN

0x8B1D

/*
 get node name/nickname
*/

273

/*
 As the ESSID and NICKN are strings up to 32 bytes long, it doesn't fit

274

 * within the 'iwreq' structure, so we need to use the 'data' member to

275

 * point to a string in user space, like it is done for RANGE...
*/

276

277

/*
 Other parameters useful in 802.11 and some other devices
*/

278

#
define

SIOCSIWRATE

0x8B20

/*
 set default bit rate (bps)
*/

279

#
define

SIOCGIWRATE

0x8B21

/*
 get default bit rate (bps)
*/

280

#
define

SIOCSIWRTS

0x8B22

/*
 set RTS/CTS threshold (bytes)
*/

281

#
define

SIOCGIWRTS

0x8B23

/*
 get RTS/CTS threshold (bytes)
*/

282

#
define

SIOCSIWFRAG

0x8B24

/*
 set fragmentation thr (bytes)
*/

283

#
define

SIOCGIWFRAG

0x8B25

/*
 get fragmentation thr (bytes)
*/

284

#
define

SIOCSIWTXPOW

0x8B26

/*
 set transmit power (dBm)
*/

285

#
define

SIOCGIWTXPOW

0x8B27

/*
 get transmit power (dBm)
*/

286

#
define

SIOCSIWRETRY

0x8B28

/*
 set retry limits and lifetime
*/

287

#
define

SIOCGIWRETRY

0x8B29

/*
 get retry limits and lifetime
*/

288

289

/*
 Encoding stuff (scrambling, hardware security, WEP...)
*/

290

#
define

SIOCSIWENCODE

0x8B2A

/*
 set encoding token & mode
*/

291

#
define

SIOCGIWENCODE

0x8B2B

/*
 get encoding token & mode
*/

292

/*
 Power saving stuff (power management, unicast and multicast)
*/

293

#
define

SIOCSIWPOWER

0x8B2C

/*
 set Power Management settings
*/

294

#
define

SIOCGIWPOWER

0x8B2D

/*
 get Power Management settings
*/

295

/*
 Modulation bitmask
*/

296

#
define

SIOCSIWMODUL

0x8B2E

/*
 set Modulations settings
*/

297

#
define

SIOCGIWMODUL

0x8B2F

/*
 get Modulations settings
*/

298

299

/*
 WPA : Generic IEEE 802.11 informatiom element (e.g., for WPA/RSN/WMM).

300

 * This ioctl uses struct iw_point and data buffer that includes IE id and len

301

 * fields. More than one IE may be included in the request. Setting the generic

302

 * IE to empty buffer (len=0) removes the generic IE from the driver. Drivers

303

 * are allowed to generate their own WPA/RSN IEs, but in these cases, drivers

304

 * are required to report the used IE as a wireless event, e.g., when

305

 * associating with an AP.
*/

306

#
define

SIOCSIWGENIE

0x8B30

/*
 set generic IE
*/

307

#
define

SIOCGIWGENIE

0x8B31

/*
 get generic IE
*/

308

309

/*
 WPA : IEEE 802.11 MLME requests
*/

310

#
define

SIOCSIWMLME

0x8B16

/*
 request MLME operation; uses

311

  * struct iw_mlme
*/

312

/*
 WPA : Authentication mode parameters
*/

313

#
define

SIOCSIWAUTH

0x8B32

/*
 set authentication mode params
*/

314

#
define

SIOCGIWAUTH

0x8B33

/*
 get authentication mode params
*/

315

316

/*
 WPA : Extended version of encoding configuration
*/

317

#
define

SIOCSIWENCODEEXT

0x8B34

/*
 set encoding token & mode
*/

318

#
define

SIOCGIWENCODEEXT

0x8B35

/*
 get encoding token & mode
*/

319

320

/*
 WPA2 : PMKSA cache management
*/

321

#
define

SIOCSIWPMKSA

0x8B36

/*
 PMKSA cache operation
*/

322

323

/*
 -------------------- DEV PRIVATE IOCTL LIST --------------------
*/

324

325

/*
 These 32 ioctl are wireless device private, for 16 commands.

326

 * Each driver is free to use them for whatever purpose it chooses,

327

 * however the driver *must* export the description of those ioctls

328

 * with SIOCGIWPRIV and *must* use arguments as defined below.

329

 * If you don't follow those rules, DaveM is going to hate you (reason :

330

 * it make mixed 32/64bit operation impossible).

331

*/

332

#
define

SIOCIWFIRSTPRIV

0x8BE0

333

#
define

SIOCIWLASTPRIV

0x8BFF

334

/*
 Previously, we were using SIOCDEVPRIVATE, but we now have our

335

 * separate range because of collisions with other tools such as

336

 * 'mii-tool'.

337

 * We now have 32 commands, so a bit more space ;-).

338

 * Also, all 'odd' commands are only usable by root and don't return the

339

 * content of ifr/iwr to user (but you are not obliged to use the set/get

340

 * convention, just use every other two command). More details in iwpriv.c.

341

 * And I repeat : you are not forced to use them with iwpriv, but you

342

 * must be compliant with it.

343

*/

344

345

/*
 ------------------------- IOCTL STUFF -------------------------
*/

346

347

/*
 The first and the last (range)
*/

348

#
define

SIOCIWFIRST

0x8B00

349

#
define

SIOCIWLAST
 SIOCIWLASTPRIV
/*
 0x8BFF
*/

350

#
define

IW_IOCTL_IDX
(
cmd
) ((cmd) - SIOCIWFIRST)

351

352

/*
 Even : get (world access), odd : set (root access)
*/

353

#
define

IW_IS_SET
(
cmd
) (!((cmd) &
0x1
))

354

#
define

IW_IS_GET
(
cmd
) ((cmd) &
0x1
)

355

356

/*
 ----------------------- WIRELESS EVENTS -----------------------
*/

357

/*
 Those are *NOT* ioctls, do not issue request on them !!!
*/

358

/*
 Most events use the same identifier as ioctl requests
*/

359

360

#
define

IWEVTXDROP

0x8C00

/*
 Packet dropped to excessive retry
*/

361

#
define

IWEVQUAL

0x8C01

/*
 Quality part of statistics (scan)
*/

362

#
define

IWEVCUSTOM

0x8C02

/*
 Driver specific ascii string
*/

363

#
define

IWEVREGISTERED

0x8C03

/*
 Discovered a new node (AP mode)
*/

364

#
define

IWEVEXPIRED

0x8C04

/*
 Expired a node (AP mode)
*/

365

#
define

IWEVGENIE

0x8C05

/*
 Generic IE (WPA, RSN, WMM, ..)

366

  * (scan results); This includes id and

367

  * length fields. One IWEVGENIE may

368

  * contain more than one IE. Scan

369

  * results may contain one or more

370

  * IWEVGENIE events.
*/

371

#
define

IWEVMICHAELMICFAILURE

0x8C06

/*
 Michael MIC failure

372

  * (struct iw_michaelmicfailure)

373

*/

374

#
define

IWEVASSOCREQIE

0x8C07

/*
 IEs used in (Re)Association Request.

375

  * The data includes id and length

376

  * fields and may contain more than one

377

  * IE. This event is required in

378

  * Managed mode if the driver

379

  * generates its own WPA/RSN IE. This

380

  * should be sent just before

381

  * IWEVREGISTERED event for the

382

  * association.
*/

383

#
define

IWEVASSOCRESPIE

0x8C08

/*
 IEs used in (Re)Association

384

  * Response. The data includes id and

385

  * length fields and may contain more

386

  * than one IE. This may be sent

387

  * between IWEVASSOCREQIE and

388

  * IWEVREGISTERED events for the

389

  * association.
*/

390

#
define

IWEVPMKIDCAND

0x8C09

/*
 PMKID candidate for RSN

391

  * pre-authentication

392

  * (struct iw_pmkid_cand)
*/

393

394

#
define

IWEVFIRST

0x8C00

395

#
define

IW_EVENT_IDX
(
cmd
) ((cmd) - IWEVFIRST)

396

397

/*
 ------------------------- PRIVATE INFO -------------------------
*/

398

/*

399

 * The following is used with SIOCGIWPRIV. It allow a driver to define

400

 * the interface (name, type of data) for its private ioctl.

401

 * Privates ioctl are SIOCIWFIRSTPRIV -> SIOCIWLASTPRIV

402

*/

403

404

#
define

IW_PRIV_TYPE_MASK

0x7000

/*
 Type of arguments
*/

405

#
define

IW_PRIV_TYPE_NONE

0x0000

406

#
define

IW_PRIV_TYPE_BYTE

0x1000

/*
 Char as number
*/

407

#
define

IW_PRIV_TYPE_CHAR

0x2000

/*
 Char as character
*/

408

#
define

IW_PRIV_TYPE_INT

0x4000

/*
 32 bits int
*/

409

#
define

IW_PRIV_TYPE_FLOAT

0x5000

/*
 struct iw_freq
*/

410

#
define

IW_PRIV_TYPE_ADDR

0x6000

/*
 struct sockaddr
*/

411

412

#
define

IW_PRIV_SIZE_FIXED

0x0800

/*
 Variable or fixed number of args
*/

413

414

#
define

IW_PRIV_SIZE_MASK

0x07FF

/*
 Max number of those args
*/

415

416

/*

417

 * Note : if the number of args is fixed and the size < 16 octets,

418

 * instead of passing a pointer we will put args in the iwreq struct...

419

*/

420

421

/*
 ----------------------- OTHER CONSTANTS -----------------------
*/

422

423

/*
 Maximum frequencies in the range struct
*/

424

#
define

IW_MAX_FREQUENCIES

32

425

/*
 Note : if you have something like 80 frequencies,

426

 * don't increase this constant and don't fill the frequency list.

427

 * The user will be able to set by channel anyway...
*/

428

429

/*
 Maximum bit rates in the range struct
*/

430

#
define

IW_MAX_BITRATES

32

431

432

/*
 Maximum tx powers in the range struct
*/

433

#
define

IW_MAX_TXPOWER

8

434

/*
 Note : if you more than 8 TXPowers, just set the max and min or

435

 * a few of them in the struct iw_range.
*/

436

437

/*
 Maximum of address that you may set with SPY
*/

438

#
define

IW_MAX_SPY

8

439

440

/*
 Maximum of address that you may get in the

441

   list of access points in range
*/

442

#
define

IW_MAX_AP

64

443

444

/*
 Maximum size of the ESSID and NICKN strings
*/

445

#
define

IW_ESSID_MAX_SIZE

32

446

447

/*
 Modes of operation
*/

448

#
define

IW_MODE_AUTO

0

/*
 Let the driver decides
*/

449

#
define

IW_MODE_ADHOC

1

/*
 Single cell network
*/

450

#
define

IW_MODE_INFRA

2

/*
 Multi cell network, roaming, ...
*/

451

#
define

IW_MODE_MASTER

3

/*
 Synchronisation master or Access Point
*/

452

#
define

IW_MODE_REPEAT

4

/*
 Wireless Repeater (forwarder)
*/

453

#
define

IW_MODE_SECOND

5

/*
 Secondary master/repeater (backup)
*/

454

#
define

IW_MODE_MONITOR

6

/*
 Passive monitor (listen only)
*/

455

456

/*
 Statistics flags (bitmask in updated)
*/

457

#
define

IW_QUAL_QUAL_UPDATED

0x01

/*
 Value was updated since last read
*/

458

#
define

IW_QUAL_LEVEL_UPDATED

0x02

459

#
define

IW_QUAL_NOISE_UPDATED

0x04

460

#
define

IW_QUAL_ALL_UPDATED

0x07

461

#
define

IW_QUAL_DBM

0x08

/*
 Level + Noise are dBm
*/

462

#
define

IW_QUAL_QUAL_INVALID

0x10

/*
 Driver doesn't provide value
*/

463

#
define

IW_QUAL_LEVEL_INVALID

0x20

464

#
define

IW_QUAL_NOISE_INVALID

0x40

465

#
define

IW_QUAL_RCPI

0x80

/*
 Level + Noise are 802.11k RCPI
*/

466

#
define

IW_QUAL_ALL_INVALID

0x70

467

468

/*
 Frequency flags
*/

469

#
define

IW_FREQ_AUTO

0x00

/*
 Let the driver decides
*/

470

#
define

IW_FREQ_FIXED

0x01

/*
 Force a specific value
*/

471

472

/*
 Maximum number of size of encoding token available

473

 * they are listed in the range structure
*/

474

#
define

IW_MAX_ENCODING_SIZES

8

475

476

/*
 Maximum size of the encoding token in bytes
*/

477

#
define

IW_ENCODING_TOKEN_MAX

64

/*
 512 bits (for now)
*/

478

479

/*
 Flags for encoding (along with the token)
*/

480

#
define

IW_ENCODE_INDEX

0x00FF

/*
 Token index (if needed)
*/

481

#
define

IW_ENCODE_FLAGS

0xFF00

/*
 Flags defined below
*/

482

#
define

IW_ENCODE_MODE

0xF000

/*
 Modes defined below
*/

483

#
define

IW_ENCODE_DISABLED

0x8000

/*
 Encoding disabled
*/

484

#
define

IW_ENCODE_ENABLED

0x0000

/*
 Encoding enabled
*/

485

#
define

IW_ENCODE_RESTRICTED

0x4000

/*
 Refuse non-encoded packets
*/

486

#
define

IW_ENCODE_OPEN

0x2000

/*
 Accept non-encoded packets
*/

487

#
define

IW_ENCODE_NOKEY

0x0800

/*
 Key is write only, so not present
*/

488

#
define

IW_ENCODE_TEMP

0x0400

/*
 Temporary key
*/

489

490

/*
 Power management flags available (along with the value, if any)
*/

491

#
define

IW_POWER_ON

0x0000

/*
 No details...
*/

492

#
define

IW_POWER_TYPE

0xF000

/*
 Type of parameter
*/

493

#
define

IW_POWER_PERIOD

0x1000

/*
 Value is a period/duration of 
*/

494

#
define

IW_POWER_TIMEOUT

0x2000

/*
 Value is a timeout (to go asleep)
*/

495

#
define

IW_POWER_SAVING

0x4000

/*
 Value is relative (how aggressive)
*/

496

#
define

IW_POWER_MODE

0x0F00

/*
 Power Management mode
*/

497

#
define

IW_POWER_UNICAST_R

0x0100

/*
 Receive only unicast messages
*/

498

#
define

IW_POWER_MULTICAST_R

0x0200

/*
 Receive only multicast messages
*/

499

#
define

IW_POWER_ALL_R

0x0300

/*
 Receive all messages though PM
*/

500

#
define

IW_POWER_FORCE_S

0x0400

/*
 Force PM procedure for sending unicast
*/

501

#
define

IW_POWER_REPEATER

0x0800

/*
 Repeat broadcast messages in PM period
*/

502

#
define

IW_POWER_MODIFIER

0x000F

/*
 Modify a parameter
*/

503

#
define

IW_POWER_MIN

0x0001

/*
 Value is a minimum 
*/

504

#
define

IW_POWER_MAX

0x0002

/*
 Value is a maximum
*/

505

#
define

IW_POWER_RELATIVE

0x0004

/*
 Value is not in seconds/ms/us
*/

506

507

/*
 Transmit Power flags available
*/

508

#
define

IW_TXPOW_TYPE

0x00FF

/*
 Type of value
*/

509

#
define

IW_TXPOW_DBM

0x0000

/*
 Value is in dBm
*/

510

#
define

IW_TXPOW_MWATT

0x0001

/*
 Value is in mW
*/

511

#
define

IW_TXPOW_RELATIVE

0x0002

/*
 Value is in arbitrary units
*/

512

#
define

IW_TXPOW_RANGE

0x1000

/*
 Range of value between min/max
*/

513

514

/*
 Retry limits and lifetime flags available
*/

515

#
define

IW_RETRY_ON

0x0000

/*
 No details...
*/

516

#
define

IW_RETRY_TYPE

0xF000

/*
 Type of parameter
*/

517

#
define

IW_RETRY_LIMIT

0x1000

/*
 Maximum number of retries
*/

518

#
define

IW_RETRY_LIFETIME

0x2000

/*
 Maximum duration of retries in us
*/

519

#
define

IW_RETRY_MODIFIER

0x00FF

/*
 Modify a parameter
*/

520

#
define

IW_RETRY_MIN

0x0001

/*
 Value is a minimum 
*/

521

#
define

IW_RETRY_MAX

0x0002

/*
 Value is a maximum
*/

522

#
define

IW_RETRY_RELATIVE

0x0004

/*
 Value is not in seconds/ms/us
*/

523

#
define

IW_RETRY_SHORT

0x0010

/*
 Value is for short packets 
*/

524

#
define

IW_RETRY_LONG

0x0020

/*
 Value is for long packets
*/

525

526

/*
 Scanning request flags
*/

527

#
define

IW_SCAN_DEFAULT

0x0000

/*
 Default scan of the driver
*/

528

#
define

IW_SCAN_ALL_ESSID

0x0001

/*
 Scan all ESSIDs
*/

529

#
define

IW_SCAN_THIS_ESSID

0x0002

/*
 Scan only this ESSID
*/

530

#
define

IW_SCAN_ALL_FREQ

0x0004

/*
 Scan all Frequencies
*/

531

#
define

IW_SCAN_THIS_FREQ

0x0008

/*
 Scan only this Frequency
*/

532

#
define

IW_SCAN_ALL_MODE

0x0010

/*
 Scan all Modes
*/

533

#
define

IW_SCAN_THIS_MODE

0x0020

/*
 Scan only this Mode
*/

534

#
define

IW_SCAN_ALL_RATE

0x0040

/*
 Scan all Bit-Rates
*/

535

#
define

IW_SCAN_THIS_RATE

0x0080

/*
 Scan only this Bit-Rate
*/

536

/*
 struct iw_scan_req scan_type
*/

537

#
define

IW_SCAN_TYPE_ACTIVE

0

538

#
define

IW_SCAN_TYPE_PASSIVE

1

539

/*
 Maximum size of returned data
*/

540

#
define

IW_SCAN_MAX_DATA

4096

/*
 In bytes
*/

541

542

/*
 Max number of char in custom event - use multiple of them if needed
*/

543

#
define

IW_CUSTOM_MAX

256

/*
 In bytes
*/

544

545

/*
 Generic information element
*/

546

#
define

IW_GENERIC_IE_MAX

1024

547

548

/*
 MLME requests (SIOCSIWMLME / struct iw_mlme)
*/

549

#
define

IW_MLME_DEAUTH

0

550

#
define

IW_MLME_DISASSOC

1

551

552

/*
 SIOCSIWAUTH/SIOCGIWAUTH struct iw_param flags
*/

553

#
define

IW_AUTH_INDEX

0x0FFF

554

#
define

IW_AUTH_FLAGS

0xF000

555

/*
 SIOCSIWAUTH/SIOCGIWAUTH parameters (0 .. 4095)

556

 * (IW_AUTH_INDEX mask in struct iw_param flags; this is the index of the

557

 * parameter that is being set/get to; value will be read/written to

558

 * struct iw_param value field)
*/

559

#
define

IW_AUTH_WPA_VERSION

0

560

#
define

IW_AUTH_CIPHER_PAIRWISE

1

561

#
define

IW_AUTH_CIPHER_GROUP

2

562

#
define

IW_AUTH_KEY_MGMT

3

563

#
define

IW_AUTH_TKIP_COUNTERMEASURES

4

564

#
define

IW_AUTH_DROP_UNENCRYPTED

5

565

#
define

IW_AUTH_80211_AUTH_ALG

6

566

#
define

IW_AUTH_WPA_ENABLED

7

567

#
define

IW_AUTH_RX_UNENCRYPTED_EAPOL

8

568

#
define

IW_AUTH_ROAMING_CONTROL

9

569

#
define

IW_AUTH_PRIVACY_INVOKED

10

570

571

/*
 IW_AUTH_WPA_VERSION values (bit field)
*/

572

#
define

IW_AUTH_WPA_VERSION_DISABLED

0x00000001

573

#
define

IW_AUTH_WPA_VERSION_WPA

0x00000002

574

#
define

IW_AUTH_WPA_VERSION_WPA2

0x00000004

575

576

/*
 IW_AUTH_PAIRWISE_CIPHER and IW_AUTH_GROUP_CIPHER values (bit field)
*/

577

#
define

IW_AUTH_CIPHER_NONE

0x00000001

578

#
define

IW_AUTH_CIPHER_WEP40

0x00000002

579

#
define

IW_AUTH_CIPHER_TKIP

0x00000004

580

#
define

IW_AUTH_CIPHER_CCMP

0x00000008

581

#
define

IW_AUTH_CIPHER_WEP104

0x00000010

582

583

/*
 IW_AUTH_KEY_MGMT values (bit field)
*/

584

#
define

IW_AUTH_KEY_MGMT_802_1X

1

585

#
define

IW_AUTH_KEY_MGMT_PSK

2

586

587

/*
 IW_AUTH_80211_AUTH_ALG values (bit field)
*/

588

#
define

IW_AUTH_ALG_OPEN_SYSTEM

0x00000001

589

#
define

IW_AUTH_ALG_SHARED_KEY

0x00000002

590

#
define

IW_AUTH_ALG_LEAP

0x00000004

591

592

/*
 IW_AUTH_ROAMING_CONTROL values
*/

593

#
define

IW_AUTH_ROAMING_ENABLE

0

/*
 driver/firmware based roaming
*/

594

#
define

IW_AUTH_ROAMING_DISABLE

1

/*
 user space program used for roaming

595

  * control
*/

596

597

/*
 SIOCSIWENCODEEXT definitions
*/

598

#
define

IW_ENCODE_SEQ_MAX_SIZE

8

599

/*
 struct iw_encode_ext ->alg
*/

600

#
define

IW_ENCODE_ALG_NONE

0

601

#
define

IW_ENCODE_ALG_WEP

1

602

#
define

IW_ENCODE_ALG_TKIP

2

603

#
define

IW_ENCODE_ALG_CCMP

3

604

/*
 struct iw_encode_ext ->ext_flags
*/

605

#
define

IW_ENCODE_EXT_TX_SEQ_VALID

0x00000001

606

#
define

IW_ENCODE_EXT_RX_SEQ_VALID

0x00000002

607

#
define

IW_ENCODE_EXT_GROUP_KEY

0x00000004

608

#
define

IW_ENCODE_EXT_SET_TX_KEY

0x00000008

609

610

/*
 IWEVMICHAELMICFAILURE : struct iw_michaelmicfailure ->flags
*/

611

#
define

IW_MICFAILURE_KEY_ID

0x00000003

/*
 Key ID 0..3
*/

612

#
define

IW_MICFAILURE_GROUP

0x00000004

613

#
define

IW_MICFAILURE_PAIRWISE

0x00000008

614

#
define

IW_MICFAILURE_STAKEY

0x00000010

615

#
define

IW_MICFAILURE_COUNT

0x00000060

/*
 1 or 2 (0 = count not supported)

616

*/

617

618

/*
 Bit field values for enc_capa in struct iw_range
*/

619

#
define

IW_ENC_CAPA_WPA

0x00000001

620

#
define

IW_ENC_CAPA_WPA2

0x00000002

621

#
define

IW_ENC_CAPA_CIPHER_TKIP

0x00000004

622

#
define

IW_ENC_CAPA_CIPHER_CCMP

0x00000008

623

624

/*
 Event capability macros - in (struct iw_range *)->event_capa

625

 * Because we have more than 32 possible events, we use an array of

626

 * 32 bit bitmasks. Note : 32 bits = 0x20 = 2^5.
*/

627

#
define

IW_EVENT_CAPA_BASE
(
cmd
) ((cmd >= SIOCIWFIRSTPRIV) ? \

628

  (cmd - SIOCIWFIRSTPRIV +
0x60
) : \

629

  (cmd - SIOCSIWCOMMIT))

630

#
define

IW_EVENT_CAPA_INDEX
(
cmd
) (IW_EVENT_CAPA_BASE(cmd) >>
5
)

631

#
define

IW_EVENT_CAPA_MASK
(
cmd
) (
1
 << (IW_EVENT_CAPA_BASE(cmd) &
0x1F
))

632

/*
 Event capability constants - event autogenerated by the kernel

633

 * This list is valid for most 802.11 devices, customise as needed...
*/

634

#
define

IW_EVENT_CAPA_K_0
 (IW_EVENT_CAPA_MASK(
0x8B04
) | \

635

IW_EVENT_CAPA_MASK
(
0x8B06
) | \

636

  IW_EVENT_CAPA_MASK(
0x8B1A
))

637

#
define

IW_EVENT_CAPA_K_1
 (IW_EVENT_CAPA_MASK(
0x8B2A
))

638

/*
 "Easy" macro to set events in iw_range (less efficient)
*/

639

#
define

IW_EVENT_CAPA_SET
(
event_capa, cmd
) (event_capa[IW_EVENT_CAPA_INDEX(cmd)] |= IW_EVENT_CAPA_MASK(cmd))

640

#
define

IW_EVENT_CAPA_SET_KERNEL
(
event_capa
) {event_capa[
0
] |= IW_EVENT_CAPA_K_0; event_capa[
1
] |= IW_EVENT_CAPA_K_1; }

641

642

/*
 Modulations bitmasks
*/

643

#
define

IW_MODUL_ALL

0x00000000

/*
 Everything supported
*/

644

#
define

IW_MODUL_FH

0x00000001

/*
 Frequency Hopping
*/

645

#
define

IW_MODUL_DS

0x00000002

/*
 Original Direct Sequence
*/

646

#
define

IW_MODUL_CCK

0x00000004

/*
 802.11b : 5.5 + 11 Mb/s
*/

647

#
define

IW_MODUL_11B
 (IW_MODUL_DS | IW_MODUL_CCK)

648

#
define

IW_MODUL_PBCC

0x00000008

/*
 TI : 5.5 + 11 + 22 Mb/s
*/

649

#
define

IW_MODUL_OFDM_A

0x00000010

/*
 802.11a : 54 Mb/s
*/

650

#
define

IW_MODUL_11A
 (IW_MODUL_OFDM_A)

651

#
define

IW_MODUL_11AB
 (IW_MODUL_11B | IW_MODUL_11A)

652

#
define

IW_MODUL_OFDM_G

0x00000020

/*
 802.11g : 54 Mb/s
*/

653

#
define

IW_MODUL_11G
 (IW_MODUL_11B | IW_MODUL_OFDM_G)

654

#
define

IW_MODUL_11AG
 (IW_MODUL_11G | IW_MODUL_11A)

655

#
define

IW_MODUL_TURBO

0x00000040

/*
 ATH : bonding, 108 Mb/s
*/

656

/*
 In here we should define MIMO stuff. Later...
*/

657

#
define

IW_MODUL_CUSTOM

0x40000000

/*
 Driver specific
*/

658

659

/*
 Bitrate flags available
*/

660

#
define

IW_BITRATE_TYPE

0x00FF

/*
 Type of value
*/

661

#
define

IW_BITRATE_UNICAST

0x0001

/*
 Maximum/Fixed unicast bitrate
*/

662

#
define

IW_BITRATE_BROADCAST

0x0002

/*
 Fixed broadcast bitrate
*/

663

664

/*
***************************** TYPES *****************************
*/

665

666

/*
 --------------------------- SUBTYPES ---------------------------
*/

667

/*

668

 * Generic format for most parameters that fit in an int

669

*/

670

struct
 iw_param

671

{

672

  __s32 value;
/*
 The value of the parameter itself
*/

673

  __u8 fixed;
/*
 Hardware should not use auto select
*/

674

  __u8 disabled;
/*
 Disable the feature
*/

675

  __u16 flags;
/*
 Various specifc flags (if any)
*/

676

};

677

678

/*

679

 * For all data larger than 16 octets, we need to use a

680

 * pointer to memory allocated in user space.

681

*/

682

struct
 iw_point

683

{

684

void
 __user *pointer;
/*
 Pointer to the data  (in user space)
*/

685

  __u16 length;
/*
 number of fields or size in bytes
*/

686

  __u16 flags;
/*
 Optional params
*/

687

};

688

689

/*

690

 * A frequency

691

 * For numbers lower than 10^9, we encode the number in 'm' and

692

 * set 'e' to 0

693

 * For number greater than 10^9, we divide it by the lowest power

694

 * of 10 to get 'm' lower than 10^9, with 'm'= f / (10^'e')...

695

 * The power of 10 is in 'e', the result of the division is in 'm'.

696

*/

697

struct
 iw_freq

698

{

699

 __s32 m;
/*
 Mantissa
*/

700

 __s16 e;
/*
 Exponent
*/

701

 __u8 i;
/*
 List index (when in range struct)
*/

702

 __u8 flags;
/*
 Flags (fixed/auto)
*/

703

};

704

705

/*

706

 * Quality of the link

707

*/

708

struct
 iw_quality

709

{

710

 __u8 qual;
/*
 link quality (%retries, SNR,

711

    %missed beacons or better...)
*/

712

 __u8 level;
/*
 signal level (dBm)
*/

713

 __u8 noise;
/*
 noise level (dBm)
*/

714

 __u8 updated;
/*
 Flags to know if updated
*/

715

};

716

717

/*

718

 * Packet discarded in the wireless adapter due to

719

 * "wireless" specific problems...

720

 * Note : the list of counter and statistics in net_device_stats

721

 * is already pretty exhaustive, and you should use that first.

722

 * This is only additional stats...

723

*/

724

struct
 iw_discarded

725

{

726

 __u32 nwid;
/*
 Rx : Wrong nwid/essid
*/

727

 __u32 code;
/*
 Rx : Unable to code/decode (WEP)
*/

728

 __u32 fragment;
/*
 Rx : Can't perform MAC reassembly
*/

729

 __u32 retries;
/*
 Tx : Max MAC retries num reached
*/

730

 __u32 misc;
/*
 Others cases
*/

731

};

732

733

/*

734

 * Packet/Time period missed in the wireless adapter due to

735

 * "wireless" specific problems...

736

*/

737

struct
 iw_missed

738

{

739

 __u32 beacon;
/*
 Missed beacons/superframe
*/

740

};

741

742

/*

743

 * Quality range (for spy threshold)

744

*/

745

struct
 iw_thrspy

746

{

747

struct
 sockaddr addr;
/*
 Source address (hw/mac)
*/

748

struct
 iw_quality qual;
/*
 Quality of the link
*/

749

struct
 iw_quality low;
/*
 Low threshold
*/

750

struct
 iw_quality high;
/*
 High threshold
*/

751

};

752

753

/*

754

 * Optional data for scan request

755

 *

756

 * Note: these optional parameters are controlling parameters for the

757

 * scanning behavior, these do not apply to getting scan results

758

 * (SIOCGIWSCAN). Drivers are expected to keep a local BSS table and

759

 * provide a merged results with all BSSes even if the previous scan

760

 * request limited scanning to a subset, e.g., by specifying an SSID.

761

 * Especially, scan results are required to include an entry for the

762

 * current BSS if the driver is in Managed mode and associated with an AP.

763

*/

764

struct
 iw_scan_req

765

{

766

 __u8 scan_type;
/*
 IW_SCAN_TYPE_{ACTIVE,PASSIVE}
*/

767

 __u8 essid_len;

768

 __u8 num_channels;
/*
 num entries in channel_list;

769

        * 0 = scan all allowed channels
*/

770

 __u8 flags;
/*
 reserved as padding; use zero, this may

771

 * be used in the future for adding flags

772

 * to request different scan behavior
*/

773

struct
 sockaddr bssid;
/*
 ff:ff:ff:ff:ff:ff for broadcast BSSID or

774

 * individual address of a specific BSS
*/

775

776

/*

777

  * Use this ESSID if IW_SCAN_THIS_ESSID flag is used instead of using

778

  * the current ESSID. This allows scan requests for specific ESSID

779

  * without having to change the current ESSID and potentially breaking

780

  * the current association.

781

*/

782

 __u8 essid[IW_ESSID_MAX_SIZE];

783

784

/*

785

  * Optional parameters for changing the default scanning behavior.

786

  * These are based on the MLME-SCAN.request from IEEE Std 802.11.

787

  * TU is 1.024 ms. If these are set to 0, driver is expected to use

788

  * reasonable default values. min_channel_time defines the time that

789

  * will be used to wait for the first reply on each channel. If no

790

  * replies are received, next channel will be scanned after this. If

791

  * replies are received, total time waited on the channel is defined by

792

  * max_channel_time.

793

*/

794

 __u32 min_channel_time;
/*
 in TU
*/

795

 __u32 max_channel_time;
/*
 in TU
*/

796

797

struct
 iw_freq channel_list[IW_MAX_FREQUENCIES];

798

};

799

800

/*
 ------------------------- WPA SUPPORT -------------------------
*/

801

802

/*

803

 * Extended data structure for get/set encoding (this is used with

804

 * SIOCSIWENCODEEXT/SIOCGIWENCODEEXT. struct iw_point and IW_ENCODE_*

805

 * flags are used in the same way as with SIOCSIWENCODE/SIOCGIWENCODE and

806

 * only the data contents changes (key data -> this structure, including

807

 * key data).

808

 *

809

 * If the new key is the first group key, it will be set as the default

810

 * TX key. Otherwise, default TX key index is only changed if

811

 * IW_ENCODE_EXT_SET_TX_KEY flag is set.

812

 *

813

 * Key will be changed with SIOCSIWENCODEEXT in all cases except for

814

 * special "change TX key index" operation which is indicated by setting

815

 * key_len = 0 and ext_flags |= IW_ENCODE_EXT_SET_TX_KEY.

816

 *

817

 * tx_seq/rx_seq are only used when respective

818

 * IW_ENCODE_EXT_{TX,RX}_SEQ_VALID flag is set in ext_flags. Normal

819

 * TKIP/CCMP operation is to set RX seq with SIOCSIWENCODEEXT and start

820

 * TX seq from zero whenever key is changed. SIOCGIWENCODEEXT is normally

821

 * used only by an Authenticator (AP or an IBSS station) to get the

822

 * current TX sequence number. Using TX_SEQ_VALID for SIOCSIWENCODEEXT and

823

 * RX_SEQ_VALID for SIOCGIWENCODEEXT are optional, but can be useful for

824

 * debugging/testing.

825

*/

826

struct
 iw_encode_ext

827

{

828

 __u32 ext_flags;
/*
 IW_ENCODE_EXT_*
*/

829

 __u8 tx_seq[IW_ENCODE_SEQ_MAX_SIZE];
/*
 LSB first
*/

830

 __u8 rx_seq[IW_ENCODE_SEQ_MAX_SIZE];
/*
 LSB first
*/

831

struct
 sockaddr addr;
/*
 ff:ff:ff:ff:ff:ff for broadcast/multicast

832

        * (group) keys or unicast address for

833

        * individual keys
*/

834

 __u16 alg;
/*
 IW_ENCODE_ALG_*
*/

835

 __u16 key_len;

836

 __u8 key[
0
];

837

};

838

839

/*
 SIOCSIWMLME data
*/

840

struct
 iw_mlme

841

{

842

 __u16 cmd;
/*
 IW_MLME_*
*/

843

 __u16 reason_code;

844

struct
 sockaddr addr;

845

};

846

847

/*
 SIOCSIWPMKSA data
*/

848

#
define

IW_PMKSA_ADD

1

849

#
define

IW_PMKSA_REMOVE

2

850

#
define

IW_PMKSA_FLUSH

3

851

852

#
define

IW_PMKID_LEN

16

853

854

struct
 iw_pmksa

855

{

856

 __u32 cmd;
/*
 IW_PMKSA_*
*/

857

struct
 sockaddr bssid;

858

 __u8 pmkid[IW_PMKID_LEN];

859

};

860

861

/*
 IWEVMICHAELMICFAILURE data
*/

862

struct
 iw_michaelmicfailure

863

{

864

 __u32 flags;

865

struct
 sockaddr src_addr;

866

 __u8 tsc[IW_ENCODE_SEQ_MAX_SIZE];
/*
 LSB first
*/

867

};

868

869

/*
 IWEVPMKIDCAND data
*/

870

#
define

IW_PMKID_CAND_PREAUTH

0x00000001

/*
 RNS pre-authentication enabled
*/

871

struct
 iw_pmkid_cand

872

{

873

 __u32 flags;
/*
 IW_PMKID_CAND_*
*/

874

 __u32
index
;
/*
 the smaller the index, the higher the

875

 * priority
*/

876

struct
 sockaddr bssid;

877

};

878

879

/*
 ------------------------ WIRELESS STATS ------------------------
*/

880

/*

881

 * Wireless statistics (used for /proc/net/wireless)

882

*/

883

struct
 iw_statistics

884

{

885

 __u16 status;
/*
 Status

886

  * - device dependent for now
*/

887

888

struct
 iw_quality qual;
/*
 Quality of the link

889

  * (instant/mean/max)
*/

890

struct
 iw_discarded discard;
/*
 Packet discarded counts
*/

891

struct
 iw_missed miss;
/*
 Packet missed counts
*/

892

};

893

894

/*
 ------------------------ IOCTL REQUEST ------------------------
*/

895

/*

896

 * This structure defines the payload of an ioctl, and is used

897

 * below.

898

 *

899

 * Note that this structure should fit on the memory footprint

900

 * of iwreq (which is the same as ifreq), which mean a max size of

901

 * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...

902

 * You should check this when increasing the structures defined

903

 * above in this file...

904

*/

905

union
 iwreq_data

906

{

907

/*
 Config - generic
*/

908

char
 name[IFNAMSIZ];

909

/*
 Name : used to verify the presence of  wireless extensions.

910

  * Name of the protocol/provider...
*/

911

912

struct
 iw_point essid;
/*
 Extended network name
*/

913

struct
 iw_param nwid;
/*
 network id (or domain - the cell)
*/

914

struct
 iw_freq freq;
/*
 frequency or channel :

915

  * 0-1000 = channel

916

  * > 1000 = frequency in Hz
*/

917

918

struct
 iw_param sens;
/*
 signal level threshold
*/

919

struct
 iw_param bitrate;
/*
 default bit rate
*/

920

struct
 iw_param txpower;
/*
 default transmit power
*/

921

struct
 iw_param rts;
/*
 RTS threshold threshold
*/

922

struct
 iw_param frag;
/*
 Fragmentation threshold
*/

923

 __u32 mode;
/*
 Operation mode
*/

924

struct
 iw_param retry;
/*
 Retry limits & lifetime
*/

925

926

struct
 iw_point encoding;
/*
 Encoding stuff : tokens
*/

927

struct
 iw_param power;
/*
 PM duration/timeout
*/

928

struct
 iw_quality qual;
/*
 Quality part of statistics
*/

929

930

struct
 sockaddr ap_addr;
/*
 Access point address
*/

931

struct
 sockaddr addr;
/*
 Destination address (hw/mac)
*/

932

933

struct
 iw_param param;
/*
 Other small parameters
*/

934

struct
 iw_point data;
/*
 Other large parameters
*/

935

};

936

937

/*

938

 * The structure to exchange data for ioctl.

939

 * This structure is the same as 'struct ifreq', but (re)defined for

940

 * convenience...

941

 * Do I need to remind you about structure size (32 octets) ?

942

*/

943

struct
 iwreq

944

{

945

union

946

 {

947

char
 ifrn_name[IFNAMSIZ];
/*
 if name, e.g. "eth0"
*/

948

 } ifr_ifrn;

949

950

/*
 Data part (defined just above)
*/

951

union
 iwreq_data u;

952

};

953

954

/*
 -------------------------- IOCTL DATA --------------------------
*/

955

/*

956

 * For those ioctl which want to exchange mode data that what could

957

 * fit in the above structure...

958

*/

959

960

/*

961

 * Range of parameters

962

*/

963

964

struct
 iw_range

965

{

966

/*
 Informative stuff (to choose between different interface)
*/

967

 __u32 throughput;
/*
 To give an idea...
*/

968

/*
 In theory this value should be the maximum benchmarked

969

  * TCP/IP throughput, because with most of these devices the

970

  * bit rate is meaningless (overhead an co) to estimate how

971

  * fast the connection will go and pick the fastest one.

972

  * I suggest people to play with Netperf or any benchmark...

973

*/

974

975

/*
 NWID (or domain id)
*/

976

 __u32 min_nwid;
/*
 Minimal NWID we are able to set
*/

977

 __u32 max_nwid;
/*
 Maximal NWID we are able to set
*/

978

979

/*
 Old Frequency (backward compat - moved lower )
*/

980

 __u16 old_num_channels;

981

 __u8 old_num_frequency;

982

983

/*
 Wireless event capability bitmasks
*/

984

 __u32 event_capa[
6
];

985

986

/*
 signal level threshold range
*/

987

 __s32 sensitivity;

988

989

/*
 Quality of link & SNR stuff
*/

990

/*
 Quality range (link, level, noise)

991

  * If the quality is absolute, it will be in the range [0 ; max_qual],

992

  * if the quality is dBm, it will be in the range [max_qual ; 0].

993

  * Don't forget that we use 8 bit arithmetics...
*/

994

struct
 iw_quality max_qual;
/*
 Quality of the link
*/

995

/*
 This should contain the average/typical values of the quality

996

  * indicator. This should be the threshold between a "good" and

997

  * a "bad" link (example : monitor going from green to orange).

998

  * Currently, user space apps like quality monitors don't have any

999

  * way to calibrate the measurement. With this, they can split

1000

  * the range between 0 and max_qual in different quality level

1001

  * (using a geometric subdivision centered on the average).

1002

  * I expect that people doing the user space apps will feedback

1003

  * us on which value we need to put in each driver...
*/

1004

struct
 iw_quality avg_qual;
/*
 Quality of the link
*/

1005

1006

/*
 Rates
*/

1007

 __u8 num_bitrates;
/*
 Number of entries in the list
*/

1008

 __s32 bitrate[IW_MAX_BITRATES];
/*
 list, in bps
*/

1009

1010

/*
 RTS threshold
*/

1011

 __s32 min_rts;
/*
 Minimal RTS threshold
*/

1012

 __s32 max_rts;
/*
 Maximal RTS threshold
*/

1013

1014

/*
 Frag threshold
*/

1015

 __s32 min_frag;
/*
 Minimal frag threshold
*/

1016

 __s32 max_frag;
/*
 Maximal frag threshold
*/

1017

1018

/*
 Power Management duration & timeout
*/

1019

 __s32 min_pmp;
/*
 Minimal PM period
*/

1020

 __s32 max_pmp;
/*
 Maximal PM period
*/

1021

 __s32 min_pmt;
/*
 Minimal PM timeout
*/

1022

 __s32 max_pmt;
/*
 Maximal PM timeout
*/

1023

 __u16 pmp_flags;
/*
 How to decode max/min PM period
*/

1024

 __u16 pmt_flags;
/*
 How to decode max/min PM timeout
*/

1025

 __u16 pm_capa;
/*
 What PM options are supported
*/

1026

1027

/*
 Encoder stuff
*/

1028

 __u16 encoding_size[IW_MAX_ENCODING_SIZES];
/*
 Different token sizes
*/

1029

 __u8 num_encoding_sizes;
/*
 Number of entry in the list
*/

1030

 __u8 max_encoding_tokens;
/*
 Max number of tokens
*/

1031

/*
 For drivers that need a "login/passwd" form
*/

1032

 __u8 encoding_login_index;
/*
 token index for login token
*/

1033

1034

/*
 Transmit power
*/

1035

 __u16 txpower_capa;
/*
 What options are supported
*/

1036

 __u8 num_txpower;
/*
 Number of entries in the list
*/

1037

 __s32 txpower[IW_MAX_TXPOWER];
/*
 list, in bps
*/

1038

1039

/*
 Wireless Extension version info
*/

1040

 __u8 we_version_compiled;
/*
 Must be WIRELESS_EXT
*/

1041

 __u8 we_version_source;
/*
 Last update of source
*/

1042

1043

/*
 Retry limits and lifetime
*/

1044

 __u16 retry_capa;
/*
 What retry options are supported
*/

1045

 __u16 retry_flags;
/*
 How to decode max/min retry limit
*/

1046

 __u16 r_time_flags;
/*
 How to decode max/min retry life
*/

1047

 __s32 min_retry;
/*
 Minimal number of retries
*/

1048

 __s32 max_retry;
/*
 Maximal number of retries
*/

1049

 __s32 min_r_time;
/*
 Minimal retry lifetime
*/

1050

 __s32 max_r_time;
/*
 Maximal retry lifetime
*/

1051

1052

/*
 Frequency
*/

1053

 __u16 num_channels;
/*
 Number of channels [0; num - 1]
*/

1054

 __u8 num_frequency;
/*
 Number of entry in the list
*/

1055

struct
 iw_freq freq[IW_MAX_FREQUENCIES];
/*
 list
*/

1056

/*
 Note : this frequency list doesn't need to fit channel numbers,

1057

  * because each entry contain its channel index
*/

1058

1059

 __u32 enc_capa;
/*
 IW_ENC_CAPA_* bit field
*/

1060

1061

/*
 More power management stuff
*/

1062

 __s32 min_pms;
/*
 Minimal PM saving
*/

1063

 __s32 max_pms;
/*
 Maximal PM saving
*/

1064

 __u16 pms_flags;
/*
 How to decode max/min PM saving
*/

1065

1066

/*
 All available modulations for driver (hw may support less)
*/

1067

 __s32 modul_capa;
/*
 IW_MODUL_* bit field
*/

1068

1069

/*
 More bitrate stuff
*/

1070

 __u32 bitrate_capa;
/*
 Types of bitrates supported
*/

1071

};

1072

1073

/*

1074

 * Private ioctl interface information

1075

*/

1076

1077

struct
 iw_priv_args

1078

{

1079

 __u32 cmd;
/*
 Number of the ioctl to issue
*/

1080

 __u16 set_args;
/*
 Type and number of args
*/

1081

 __u16 get_args;
/*
 Type and number of args
*/

1082

char
 name[IFNAMSIZ];
/*
 Name of the extension
*/

1083

};

1084

1085

/*
 ----------------------- WIRELESS EVENTS -----------------------
*/

1086

/*

1087

 * Wireless events are carried through the rtnetlink socket to user

1088

 * space. They are encapsulated in the IFLA_WIRELESS field of

1089

 * a RTM_NEWLINK message.

1090

*/

1091

1092

/*

1093

 * A Wireless Event. Contains basically the same data as the ioctl...

1094

*/

1095

struct
 iw_event

1096

{

1097

 __u16 len;
/*
 Real lenght of this stuff
*/

1098

 __u16 cmd;
/*
 Wireless IOCTL
*/

1099

union
 iwreq_data u;
/*
 IOCTL fixed payload
*/

1100

};

1101

1102

/*
 Size of the Event prefix (including padding and alignement junk)
*/

1103

#
define

IW_EV_LCP_LEN
 (
sizeof
(
struct
 iw_event) -
sizeof
(
union
 iwreq_data))

1104

/*
 Size of the various events
*/

1105

#
define

IW_EV_CHAR_LEN
 (IW_EV_LCP_LEN + IFNAMSIZ)

1106

#
define

IW_EV_UINT_LEN
 (IW_EV_LCP_LEN +
sizeof
(__u32))

1107

#
define

IW_EV_FREQ_LEN
 (IW_EV_LCP_LEN +
sizeof
(
struct
 iw_freq))

1108

#
define

IW_EV_PARAM_LEN
 (IW_EV_LCP_LEN +
sizeof
(
struct
 iw_param))

1109

#
define

IW_EV_ADDR_LEN
 (IW_EV_LCP_LEN +
sizeof
(
struct
 sockaddr))

1110

#
define

IW_EV_QUAL_LEN
 (IW_EV_LCP_LEN +
sizeof
(
struct
 iw_quality))

1111

1112

/*
 iw_point events are special. First, the payload (extra data) come at

1113

 * the end of the event, so they are bigger than IW_EV_POINT_LEN. Second,

1114

 * we omit the pointer, so start at an offset.
*/

1115

#
define

IW_EV_POINT_OFF
 (((
char
 *) &(((
struct
 iw_point *)
NULL
)->length)) - \

1116

   (
char
 *)
NULL
)

1117

#
define

IW_EV_POINT_LEN
 (IW_EV_LCP_LEN +
sizeof
(
struct
 iw_point) - \

1118

  IW_EV_POINT_OFF)

1119

1120

#
endif

/*
 _LINUX_WIRELESS_H
*/
{
  "ingest_source": {
    "id": "4d25e2e2-8150-4dab-a495-9a75cd05d93d",
    "source_type": "evernote_html",
    "source_path": "/Users/tang/workbench/article-classifier/backups/2023年6月/IT技术/高并发下怎么做余额扣减？.html",
    "collected_at": "2025-11-09T20:05:15.551823Z",
    "external_id": null,
    "title_hint": null,
    "language_hint": "zh-cn",
    "captured_at": null,
    "checksum": "683cd82b6a0f03d5800add3e1f172ae3162ca892cfc9a49e611e66c86d2fffd5",
    "status": "pending",
    "notes": {
      "batch_id": null
    }
  },
  "note": {
    "id": "2b58da24-4db9-4e79-8873-76be86024708",
    "ingest_source_id": "4d25e2e2-8150-4dab-a495-9a75cd05d93d",
    "canonical_title": "高并发下怎么做余额扣减？",
    "language": "zh-cn",
    "ingested_at": "2025-11-09T20:05:15.551826Z",
    "created_at": null,
    "status": "active",
    "importance": 0,
    "attributes": {
      "source_filename": "高并发下怎么做余额扣减？.html"
    }
  },
  "variants": [
    {
      "id": "29faa9bd-0503-4c9a-9c95-c2f7ec23f6ef",
      "note_id": "2b58da24-4db9-4e79-8873-76be86024708",
      "variant_type": "raw_html",
      "version": 1,
      "created_by": "evernote_ingest:v0",
      "created_at": "2025-11-09T20:05:15.551829Z",
      "content": "---\ntitle: 高并发下怎么做余额扣减？\nupdated: 2021-06-28 20:15:25Z\ncreated: 2021-06-28 20:09:02Z\nauthor: tangyongfeng@gmail.com\ntags:\n  - 账户\n  - 高性能\n---\n\n\n<en-note><div><font FACE=\"Courier\">取决于是计费⾼并发，还是⽤户⾼并发。&nbsp;</font></div><div><font FACE=\"Courier\">前者是同⼀账户，同时并发多个计费请求，导致余额变化，好像⼀个银⾏账户，多个银⾏卡，同时 刷卡买东⻄；后者是多个⽤户在线，⽤各⾃的账户消费，互不影响。&nbsp;</font></div><div><font FACE=\"Courier\">就基于计费⾼并发来讨论。</font></div><div><font FACE=\"Courier\">&nbsp;曾遇到过⼀个需求，每个账户每秒有⼏百次计费请求，要求很简单，</font></div><div><font FACE=\"Courier\">&nbsp;1，⼜快⼜准。&nbsp;</font></div><div><font FACE=\"Courier\">2，余额不为负。&nbsp;</font></div><div><font FACE=\"Courier\">同⼀个字段被并发修改，很⾃然会想到⽤lock，但系统有很多其他业务逻辑，计费只是很⼩的⼀部 分，要⾜够的轻，就开始考虑尽量⽆锁的⽅案。</font></div><div><font FACE=\"Courier\">⼤概思路如下， 记录持久化，余额内存化。&nbsp;</font></div><div><font FACE=\"Courier\">余额是充值和消费的结果，在不断变化，但充值和消费是记录，⼀旦发⽣，不会再变，某时某刻花 了10块，这条记录产⽣了，就永远不会变。这类记录持久化，放在DB⾥。</font></div><div><font FACE=\"Courier\">&nbsp;有了记录，可以在任何时刻，重建余额。</font></div><div><font FACE=\"Courier\">这个余额是否需要持久化，不⼀定，还要考虑是否存在过期等。我们虽选择持久化余额，但不加锁，因为读写不发⽣在DB上，⽽是在内存⾥。</font></div><div><font FACE=\"Courier\">&nbsp;内存⾥，⽤户有两个值，⼀个是余额，⼀个是花费。</font></div><div><font FACE=\"Courier\">⽤户消费时，余额不变，花费增加。两个问 题， 为什不直接减余额呢？&nbsp;</font></div><div><font FACE=\"Courier\">不改余额，就可以保证内存⾥的余额始终和DB中的⼀致，⽽内存⾥花费始终和消费记录⼀致。</font></div><div><font FACE=\"Courier\">⽤户 的实时余额 = 余额 - 花费。&nbsp;</font></div><div><font FACE=\"Courier\">内存计费是否加锁？&nbsp;</font></div><div><font FACE=\"Courier\">余额不为负，意味着要先确认实时余额 &gt; 所需花费，才能消费，check, then update，这并不是 atomic 的，意味着存在 race condition，</font></div><div><font FACE=\"Courier\" STYLE=\"color: rgb(255, 38, 0); --inversion-type-color: simple;\">计费函数是不是⼀定要加锁呢？</font></div><div><font FACE=\"Courier\">&nbsp;如果先查余额，再扣钱，的确要加锁；但也可以先扣钱，再查余额，若⼩于0，则把钱加回来，返 回计费失败，阻⽌消费，这样就不⽤加锁了。</font></div><div><font FACE=\"Courier\"><br/></font></div><div><font FACE=\"Courier\">当然，余额和花费应选Atomic数据类型。 这样⾼并发下的余额扣减就变得⾮常的轻，对 performance ⼏乎没有影响，也满⾜了⼜快⼜准的需 求。</font></div></en-note>      ",
      "content_path": null,
      "diff_base_variant_id": null,
      "metadata": {
        "checksum": "683cd82b6a0f03d5800add3e1f172ae3162ca892cfc9a49e611e66c86d2fffd5",
        "path": "/Users/tang/workbench/article-classifier/backups/2023年6月/IT技术/高并发下怎么做余额扣减？.html"
      }
    },
    {
      "id": "1bccb108-8f95-4a97-8006-c849456e7cc6",
      "note_id": "2b58da24-4db9-4e79-8873-76be86024708",
      "variant_type": "clean_text",
      "version": 1,
      "created_by": "evernote_ingest:v0",
      "created_at": "2025-11-09T20:05:15.551832Z",
      "content": "---\ntitle: 高并发下怎么做余额扣减？\nupdated: 2021-06-28 20:15:25Z\ncreated: 2021-06-28 20:09:02Z\nauthor: tangyongfeng@gmail.com\ntags:\n  - 账户\n  - 高性能\n---\n\n取决于是计费⾼并发，还是⽤户⾼并发。 \n前者是同⼀账户，同时并发多个计费请求，导致余额变化，好像⼀个银⾏账户，多个银⾏卡，同时 刷卡买东⻄；后者是多个⽤户在线，⽤各⾃的账户消费，互不影响。 \n就基于计费⾼并发来讨论。\n 曾遇到过⼀个需求，每个账户每秒有⼏百次计费请求，要求很简单，\n 1，⼜快⼜准。 \n2，余额不为负。 \n同⼀个字段被并发修改，很⾃然会想到⽤lock，但系统有很多其他业务逻辑，计费只是很⼩的⼀部 分，要⾜够的轻，就开始考虑尽量⽆锁的⽅案。\n⼤概思路如下， 记录持久化，余额内存化。 \n余额是充值和消费的结果，在不断变化，但充值和消费是记录，⼀旦发⽣，不会再变，某时某刻花 了10块，这条记录产⽣了，就永远不会变。这类记录持久化，放在DB⾥。\n 有了记录，可以在任何时刻，重建余额。\n这个余额是否需要持久化，不⼀定，还要考虑是否存在过期等。我们虽选择持久化余额，但不加锁，因为读写不发⽣在DB上，⽽是在内存⾥。\n 内存⾥，⽤户有两个值，⼀个是余额，⼀个是花费。\n⽤户消费时，余额不变，花费增加。两个问 题， 为什不直接减余额呢？ \n不改余额，就可以保证内存⾥的余额始终和DB中的⼀致，⽽内存⾥花费始终和消费记录⼀致。\n⽤户 的实时余额 = 余额 - 花费。 \n内存计费是否加锁？ \n余额不为负，意味着要先确认实时余额 > 所需花费，才能消费，check, then update，这并不是 atomic 的，意味着存在 race condition，\n计费函数是不是⼀定要加锁呢？\n 如果先查余额，再扣钱，的确要加锁；但也可以先扣钱，再查余额，若⼩于0，则把钱加回来，返 回计费失败，阻⽌消费，这样就不⽤加锁了。\n当然，余额和花费应选Atomic数据类型。 这样⾼并发下的余额扣减就变得⾮常的轻，对 performance ⼏乎没有影响，也满⾜了⼜快⼜准的需 求。",
      "content_path": null,
      "diff_base_variant_id": null,
      "metadata": {
        "language": "zh-cn",
        "length": 931,
        "rule_count": 0,
        "applied_rules": []
      }
    }
  ],
  "extractions": [],
  "journal": {
    "id": "ee8bcba0-b836-4707-a61b-bdcd5ed44830",
    "note_id": "2b58da24-4db9-4e79-8873-76be86024708",
    "stage": "ingest",
    "agent_id": "evernote_ingest:v0",
    "started_at": "2025-11-09T20:05:15.551836Z",
    "finished_at": "2025-11-09T20:05:15.551836Z",
    "status": "success",
    "input_ref": {
      "task_id": "fc9763c2-ce9d-4de9-80cb-c52cd0c5ece1",
      "source_path": "/Users/tang/workbench/article-classifier/backups/2023年6月/IT技术/高并发下怎么做余额扣减？.html",
      "checksum": "683cd82b6a0f03d5800add3e1f172ae3162ca892cfc9a49e611e66c86d2fffd5"
    },
    "output_ref": {
      "ingest_source": "4d25e2e2-8150-4dab-a495-9a75cd05d93d",
      "note": "2b58da24-4db9-4e79-8873-76be86024708",
      "variants": [
        "29faa9bd-0503-4c9a-9c95-c2f7ec23f6ef",
        "1bccb108-8f95-4a97-8006-c849456e7cc6"
      ]
    },
    "error_detail": null
  }
}
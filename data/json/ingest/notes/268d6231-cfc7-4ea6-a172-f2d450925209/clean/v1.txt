---
title: 列表生成器
updated: 2017-12-15 08:35:25Z
created: 2017-12-15 08:16:22Z
author: tangyongfeng
tags:
  - python
  - 学习笔记
---

通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。
所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。

要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的
[]
改成
()
，就创建了一个generator：
>>> L = [x * x for x in range(10)]
>>> L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> g = (x * x for x in range(10))
>>> g
<generator object <genexpr> at 0x1022ef630>
创建
L
和
g
的区别仅在于最外层的
[]
和
()
，
L
是一个list，而
g
是一个generator。

我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？

如果要一个一个打印出来，可以通过
next()
函数获得generator的下一个返回值：

>>> next(g)
0
>>> next(g)
1
>>> next(g)
4
>>> next(g)
9
def aaa():

        return (x * x for x in range(10))

for i in aaa():

        print (i)

带有
yield
的函数不再是一个普通函数，而是一个生成器generator，可用于迭代，
yield 是一个类似 return 的关键字，迭代一次遇到yield时就返回yield后面(右边)的值。重点是：下一次迭代时，从上一次迭代遇到的yield后面的代码(下一行)开始执行。
简要理解：yield就是 return 返回一个值，并且记住这个返回的位置，下次迭代就从这个位置后(下一行)开始。

def aaa():

        yield 1

        yield 2

        yield 3

        yield 4

        yield 5

        yield 6

        yield 7

        yield 8

        yield 9

        yield 10

        yield 11

for i in aaa():

        print (i)
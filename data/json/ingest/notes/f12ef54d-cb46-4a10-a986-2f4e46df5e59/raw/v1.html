---
title: GSM Sniffing入门 | messageloop的脚印
updated: 2016-04-07 12:24:39Z
created: 2016-04-07 12:24:39Z
source: https://xmsg.org/wordpress/?p=406
tags:
  - gsm
---


<en-note><br/><div><div><div><div><h1>GSM Sniffing入门</h1><div><div></div></div></div>

&Tab;&Tab;&Tab;&Tab;&Tab;

&Tab;&Tab;&Tab;&Tab;&Tab;
&Tab;&Tab;&Tab;&Tab;&Tab;&Tab;<p>3个月前，听朋友介绍得知<a HREF="http://bb.osmocom.org/trac/wiki/Software/GettingStarted" TARGET="_blank">OsmocomBB项目</a>。此前一直以为GSM&nbsp;Sniffing需要价格昂贵的专用设备，但osmocomBB的<b>上手成本：一个25元左右的手机，外加一根USB转TTL的串口线</b>，着实让我吃了一惊（我自己前后买了3台手机和2种串口线以测试稳定性，总共花了100元不到）</p>
<p><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/microMsg_1385641853281.jpg" TARGET="_blank"></a></p><div><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/microMsg_1385641853281.jpg" TARGET="_blank"><img src="../_resources/17a06f9782ab143cf0c61f887a439927.jpg"  type="image/jpeg" hash="17a06f9782ab143cf0c61f887a439927" alt="microMsg_1385641853281" width="425" height="455" /></en-media></a></div><p></p>
<p>OsmocomBB教程想必很多人都看过了。写这篇文章的目的，一则是把我所遇到的问题列出来，避免以后或者其他人像我一样，被&ldquo;2.5mm耳机没插到位&rdquo;这种低级问题纠缠大半个月<br/>
另外，如果大家还在用GSM的2G网络，还是找机会换了吧，SMS协议在国内是明文传输的<br/>
<b><a HREF="http://bbs.pediy.com/showpost.php?p=1247137&postcount=6" TARGET="_blank">第二部分（软件篇）</a></b>重点介绍如何利用50元左右的设备，抓包并还原SMS短信内容：</p>
<p><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/gsm_sms.jpg" TARGET="_blank"></a></p><div><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/gsm_sms.jpg" TARGET="_blank"><img src="../_resources/0537bb8172d846b706b221062d02d418.jpg"  type="image/jpeg" hash="0537bb8172d846b706b221062d02d418" alt="gsm_sms" width="576" height="432" /></en-media></a></div><p></p>
<p>ps:研究GSM&nbsp;Sniffing纯属个人兴趣，能抓SMS报文只是捡了个明文传输的漏子，切勿用于非法用途。就像sylvain说的，osmocomBB并不是为抓包而实现的，如果没有足够的GSM相关知识，想实现还原语音通话内容根本就无从下手。</p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>
<p>【第一部分-硬件篇：osmocomBB环境准备与刷机】</p>
<p><b>一、硬件准备</b></p>
<p>工欲善其事，必先利其器。在开始编译osmocomBB前，需要了解运行osmocomBB需要些什么东西：</p>
<p><b>1.&nbsp;Moto&nbsp;C118</b><br/>
osmocomBB支持很多型号的手机，具体可以在官网查到：<a HREF="http://bb.osmocom.org/trac/wiki/Hardware/Phones" TARGET="_blank">http://bb.osmocom.org/trac/wiki/Hardware/Phones</a><br/>
我们的目标C118，也就是官网首推的E88系列：MotorolaC123/C121/<b>C118</b>&nbsp;(<b>E88</b>)&nbsp;&mdash;&nbsp;our&nbsp;primary&nbsp;target<br/>
你问C118有啥优势？出了官方说的支持最好，这玩意另一个优势是便宜。机器没什么讲究，直接淘宝选最便宜的买就行了；国产系统为中文，测试一样可以正常刷机。我买的机器+电池+线充(或者直接用万能充)一起30元。另外如果只有1台不建议买裸机，这个的电池完全配不到，当时我是找人30做了块才点亮机器的&hellip;</p>
<p><b>2.&nbsp;USB转串口模块</b><br/>
推荐带<b>TX/RX&nbsp;LED</b>的&nbsp;FT232模块，虽然价格略贵（淘宝上最便宜的大概28），但有指示灯可以清楚看到是否有数据传输，方便定位问题。</p>
<p>FT232模块</p>
<p><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/Cp2.jpg" TARGET="_blank"></a></p><div><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/Cp2.jpg" TARGET="_blank"><img src="../_resources/a99ff955ff9a8b8f8b0adfe0228f8b4e.jpg"  type="image/jpeg" hash="a99ff955ff9a8b8f8b0adfe0228f8b4e" alt="Cp2" width="576" height="276" /></en-media></a></div><p></p>
<p>CP2102模块&nbsp;也可以，使用前需要参考这里<a HREF="http://bb.osmocom.org/trac/wiki/Hardware/CP210xTutorial" TARGET="_blank">调整波特率</a></p>
<div>

<pre>sudo&nbsp;./cp210x-program&nbsp;-p&nbsp;-F&nbsp;eeprom.hex&nbsp;-w&nbsp;--set-baudrate&nbsp;812500:FFE2,FFF4,1&nbsp;--set-baudrate&nbsp;406250:FFC5,FFE9,1&nbsp;--set-baudrate&nbsp;203125:FF8A,FFD3,1
</pre>
</div>
<p>用cp210x-program工具看到输出里有&nbsp;800000&nbsp;Baud,&nbsp;406780&nbsp;Baud,&nbsp;203390&nbsp;Baud,&nbsp;115385&nbsp;Baud&nbsp;这几个波特率就可以使用了</p>
<p>CP2102模块，只有电源指示</p>
<p><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/Cp1.jpg" TARGET="_blank"></a></p><div><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/Cp1.jpg" TARGET="_blank"><img src="../_resources/35ebd520a3825e982f848208ac3b18b9.jpg"  type="image/jpeg" hash="35ebd520a3825e982f848208ac3b18b9" alt="Cp1" width="576" height="438" /></en-media></a></div><p></p>
<p><b>3.&nbsp;C118数据线&nbsp;(2.5mm耳机头&nbsp;转&nbsp;杜邦线)</b><br/>
注意一头是2.5mm耳机孔的，另一边是杜邦线连接串口模块。手边有2.5mm耳机插头的可以自己做一个。淘宝只有一家卖这个线的(10￥)，如果你买的是这个，请拆下电池盖观察耳机插孔是否插到位，建议买回来第一件事就是拿小刀把插头的外框狠狠的削掉一圈：</p>
<p><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/czxa.jpg" TARGET="_blank"></a></p><div><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/czxa.jpg" TARGET="_blank"><img src="../_resources/3ce23a0109d17b24a966754669841ccf.jpg"  type="image/jpeg" hash="3ce23a0109d17b24a966754669841ccf" alt="czxa" width="576" height="392" /></en-media></a></div><p></p>
<p><b>二、ArchLinux下编译osmocomBB</b><br/>
(网上其他linux编译的教程很多，如果不是用的Arch可以跳过这个部分，参考其他教程完成osmocomBB编译)</p>
<p>0.&nbsp;首先将texinfo替换成4.13a，源里面texinfo5会导致gcc的文档无法编译</p>
<div>

<pre>cd&nbsp;~
svn&nbsp;checkout&nbsp;--depth=empty&nbsp;svn://svn.archlinux.org/packages&nbsp;arch_packages
cd&nbsp;arch_packages
svn&nbsp;update&nbsp;texinfo&nbsp;-r176043
cd&nbsp;texinfo/repos/core-i686
makepkg
</pre>
</div>
<p>安装编译好的texinfo-4.13a：</p>
<div>

<pre>sudo&nbsp;pacman&nbsp;-U&nbsp;texinfo-4.13a-7-i686.pkg.tar.xz
</pre>
</div>
<p><b>1.&nbsp;安装libosmocore：</b><a HREF="http://bb.osmocom.org/trac/wiki/libosmocore" TARGET="_blank">http://bb.osmocom.org/trac/wiki/libosmocore</a></p>
<div>

<pre>cd&nbsp;~
git&nbsp;clone&nbsp;git://git.osmocom.org/libosmocore.git
cd&nbsp;libosmocore/
#&nbsp;autoreconf&nbsp;-i&nbsp;(not&nbsp;working)
</pre>
</div>
<p><b>Arch下autoreconf怎么都过不了，直接无视之继续编译，后面再修复libosmocore.so.4找不到的问题</b></p>
<div>

<pre>./configure
make
sudo&nbsp;make&nbsp;install
</pre>
</div>
<p>修复安装路径的问题，因为autoreconf失败，默认安装到了/usr/local/lib/下。需要把库手动复制到/usr/lib/里，不然运行osmocon会提示&nbsp;libosmocore.so.4&nbsp;找不到</p>
<div>

<pre>sudo&nbsp;ldconfig
sudo&nbsp;cp&nbsp;-Rf&nbsp;/usr/local/lib/*&nbsp;/usr/lib/
</pre>
</div>
<p><b>2.&nbsp;编译arm-toolchain：</b><a HREF="http://bb.osmocom.org/trac/wiki/GnuArmToolchain" TARGET="_blank">http://bb.osmocom.org/trac/wiki/GnuArmToolchain</a></p>
<div>

<pre>cd&nbsp;~
mkdir&nbsp;arm_toolchain
cd&nbsp;arm_toolchain
wget&nbsp;http://bb.osmocom.org/trac/raw-attachment/wiki/GnuArmToolchain/gnu-arm-build.2.sh
chmod&nbsp;+x&nbsp;gnu-arm-build.2.sh
mkdir&nbsp;build&nbsp;install&nbsp;src
</pre>
</div>
<p>这是官方推荐的gcc版本，速度太慢可以用迅雷拖下来放到src目录里：</p>
<div>

<pre>cd&nbsp;src/
wget&nbsp;http://ftp.gnu.org/gnu/gcc/gcc-4.5.2/gcc-4.5.2.tar.bz2
wget&nbsp;http://ftp.gnu.org/gnu/binutils/binutils-2.21.1a.tar.bz2
wget&nbsp;ftp://sources.redhat.com/pub/newlib/newlib-1.19.0.tar.gz
</pre>
</div>
<p>开始编译arm的交叉编译工具：</p>
<div>

<pre>cd&nbsp;..
<b>./gnu-arm-build.2.sh</b>
I&nbsp;will&nbsp;build&nbsp;an&nbsp;arm-elf&nbsp;cross-compiler:

&nbsp;&nbsp;<b>Prefix:&nbsp;/root/arm_toolchain/install</b>
&nbsp;&nbsp;Sources:&nbsp;/root/arm_toolchain/src
&nbsp;&nbsp;Build&nbsp;files:&nbsp;/root/arm_toolchain/build

Press&nbsp;^C&nbsp;now&nbsp;if&nbsp;you&nbsp;do&nbsp;NOT&nbsp;want&nbsp;to&nbsp;do&nbsp;this.
</pre>
</div>
<p>按回车继续，时间比较长可以先去喝杯咖啡</p>
<div>

<pre>Build&nbsp;complete!&nbsp;Add&nbsp;/root/arm_toolchain/install/bin&nbsp;to&nbsp;your&nbsp;PATH&nbsp;to&nbsp;make&nbsp;arm-elf-gcc&nbsp;and&nbsp;friends
accessible&nbsp;directly.
</pre>
</div>
<p>编译完成，按照提示导出安装目录：</p>
<div>

<pre>export&nbsp;PATH=$PATH:/root/arm_toolchain/install/bin
</pre>
</div>
<p><b>3.&nbsp;编译osmocom-bb</b></p>
<div>

<pre>git&nbsp;clone&nbsp;git://git.osmocom.org/osmocom-bb.git
cd&nbsp;osmocom-bb
git&nbsp;pull&nbsp;--rebase
git&nbsp;checkout&nbsp;-b&nbsp;gsmmap&nbsp;remotes/origin/luca/gsmmap
</pre>
</div>
<p>不建议用&nbsp;remotes/origin/sylvain/testing&nbsp;分支，这个分支不太稳定，刷机几次才能搜到1次信号</p>
<p>如果想插上SIM卡用mobile发短信，记得打开layer1的TX发送功能：</p>
<div>

<pre>vi&nbsp;src/target/firmware/Makefile
#&nbsp;Uncomment&nbsp;this&nbsp;line&nbsp;if&nbsp;you&nbsp;want&nbsp;to&nbsp;enable&nbsp;Tx&nbsp;(Transmit)&nbsp;Support.
CFLAGS&nbsp;+=-DCONFIG_TX_ENABLE
</pre>
</div>
<p><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/osmocom_tx.png" TARGET="_blank"></a></p><div><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/osmocom_tx.png" TARGET="_blank"><img src="../_resources/68088345981430bbf71b1e40fb61d478.png"  type="image/png" hash="68088345981430bbf71b1e40fb61d478" alt="osmocom_tx" width="566" height="576" /></en-media></a></div><p></p>
<p>最后编译osmocomBB：</p>
<div>

<pre>cd&nbsp;src
make
</pre>
</div>
<p><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/build.png" TARGET="_blank"></a></p><div><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/build.png" TARGET="_blank"><img src="../_resources/a4bc0ce81169450d01a42d2a283ff929.png"  type="image/png" hash="a4bc0ce81169450d01a42d2a283ff929" alt="build" width="576" height="394" /></en-media></a></div><p></p>
<p>编译成功后，参考osmocon的教程，就可以开始对C118进行软刷机了：<br/>
<a HREF="http://bb.osmocom.org/trac/wiki/osmocon" TARGET="_blank">http://bb.osmocom.org/trac/wiki/osmocon</a></p>
<div>

<pre>0.&nbsp;准备配置文件目录
$&nbsp;sudo&nbsp;mkdir&nbsp;/etc/osmocom/
$&nbsp;sudo&nbsp;touch&nbsp;/etc/osmocom/osmocom.cfg

1.&nbsp;Connect&nbsp;your&nbsp;phone
2.&nbsp;Choose&nbsp;firmware&nbsp;(../../target/firmware/board/compal_e88/layer1.compalram.bin)
3.&nbsp;Load&nbsp;firmware
$&nbsp;cd&nbsp;host/osmocon/
$&nbsp;./osmocon&nbsp;-p&nbsp;/dev/ttyUSB0&nbsp;-m&nbsp;c123xor&nbsp;../../target/firmware/board/compal_e88/layer1.compalram.bin

4.&nbsp;运行mobile，开启新的终端
$&nbsp;cd&nbsp;layer23/src/mobile
$&nbsp;./mobile&nbsp;-i&nbsp;127.0.0.1

5.&nbsp;用wireshark抓包
$&nbsp;sudo&nbsp;wireshark&nbsp;-k&nbsp;-i&nbsp;lo&nbsp;-f&nbsp;&apos;port&nbsp;4729&apos;
</pre>
</div>
<p>mobile完成的是普通电话的交互操作；相对的，在host/layer23的misc文件夹里，还有cell_log，ccch_scan等工具可以帮助抓取GSMTAP。</p>
<p>注意：使用cell_log和ccch_scan时，有个&nbsp;GSM&nbsp;ARFCN&nbsp;参数，这个是用于选择小区中频道的。如果选错了频道，会提示&nbsp;result&nbsp;=&nbsp;255（这个按mail&nbsp;list的说法是频道中没有收到控制响应）<br/>
用bcch_scan可以得到当前位置信号较强的几个频道编号，当然也可以通过mobile的输出确定最强的ARFCN，然后使用&nbsp;-a&nbsp;参数传递给ccch_scan来捕捉其上的GSMTAP。*转载请注明来自看雪论坛@PEdiy.com </p>
<p><strong>三、osmocomBB刷机及常见故障排除</strong></p>
<p>为杜绝一切连接引起的疑难杂症，刷机前先确认USB转TTL模块没有问题。</p>
<p>用一根杜邦线，把模块的TX/RX两个pin脚短接。<br/>
<a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/Cp1.jpg" TARGET="_blank"></a></p><div><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/Cp1.jpg" TARGET="_blank"><img src="../_resources/35ebd520a3825e982f848208ac3b18b9.jpg"  type="image/jpeg" hash="35ebd520a3825e982f848208ac3b18b9" alt="Cp1" width="576" height="438" /></en-media></a></div><br/>
把模块插到USB口上，此时模块的电源LED亮起，输入&nbsp;lsusb&nbsp;查看模块的连接情况：<p></p>
<div>

<pre>[root@ArchDev&nbsp;~]#&nbsp;lsusb
Bus&nbsp;001&nbsp;Device&nbsp;004:&nbsp;ID&nbsp;0403:6001&nbsp;Future&nbsp;Technology&nbsp;Devices&nbsp;International,&nbsp;Ltd&nbsp;FT232&nbsp;USB-Serial&nbsp;(UART)&nbsp;IC
</pre>
</div>
<p>说明FT232模块已经被正确识别。dmesg也能看到类似的输出</p>
<div>

<pre>[&nbsp;3939.433684]&nbsp;usb&nbsp;1-1:&nbsp;Detected&nbsp;FT232RL
[&nbsp;3939.433691]&nbsp;usb&nbsp;1-1:&nbsp;Number&nbsp;of&nbsp;endpoints&nbsp;2
[&nbsp;3939.433697]&nbsp;usb&nbsp;1-1:&nbsp;Endpoint&nbsp;1&nbsp;MaxPacketSize&nbsp;64
[&nbsp;3939.433703]&nbsp;usb&nbsp;1-1:&nbsp;Endpoint&nbsp;2&nbsp;MaxPacketSize&nbsp;64
[&nbsp;3939.433708]&nbsp;usb&nbsp;1-1:&nbsp;Setting&nbsp;MaxPacketSize&nbsp;64
[&nbsp;3939.442346]&nbsp;usb&nbsp;1-1:&nbsp;FTDI&nbsp;USB&nbsp;Serial&nbsp;Device&nbsp;converter&nbsp;now&nbsp;attached&nbsp;to&nbsp;<b>ttyUSB0</b>
</pre>
</div>
<p>CP2102模块的话，输出稍有不同：</p>
<div>

<pre>#&nbsp;lsusb
Bus&nbsp;001&nbsp;Device&nbsp;003:&nbsp;ID&nbsp;10c4:ea60&nbsp;Cygnal&nbsp;Integrated&nbsp;Products,&nbsp;Inc.&nbsp;CP210x&nbsp;UART&nbsp;Bridge&nbsp;/&nbsp;myAVR&nbsp;mySmartUSB&nbsp;light

#&nbsp;dmesg
[&nbsp;3421.303602]&nbsp;cp210x&nbsp;1-1:1.0:&nbsp;cp210x&nbsp;converter&nbsp;detected
[&nbsp;3421.554407]&nbsp;usb&nbsp;1-1:&nbsp;reset&nbsp;full-speed&nbsp;USB&nbsp;device&nbsp;number&nbsp;3&nbsp;using&nbsp;uhci_hcd
[&nbsp;3421.703370]&nbsp;usb&nbsp;1-1:&nbsp;cp210x&nbsp;converter&nbsp;now&nbsp;attached&nbsp;to&nbsp;ttyUSB0
</pre>
</div>
<p>此时使用终端工具以115385波特率连接ttyUSB0设备(有些机器是ttyUSB1，可以通过上面dmesg输出确定)。连接后，任何键入字符，应该能正确显示在终端上。</p>
<p>下面以minicom为例：</p>
<div>

<pre>sudo&nbsp;pacman&nbsp;-S&nbsp;minicom&nbsp;&nbsp;(或者apt-get&nbsp;install&nbsp;minicom)
sudo&nbsp;minicom&nbsp;-D&nbsp;/dev/ttyUSB0&nbsp;-b&nbsp;115385&nbsp;-s
</pre>
</div>
<p>在对话框中选择&rdquo;Serial&nbsp;port&nbsp;setup&rdquo;，按F键关闭&rdquo;Hardware&nbsp;Flow&nbsp;Control&rdquo;，最终配置如图所示：</p>
<p><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/minicom.png" TARGET="_blank"></a></p><div><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/minicom.png" TARGET="_blank"><img src="../_resources/37d39d2b706827bf94a535a93c344f0c.png"  type="image/png" hash="37d39d2b706827bf94a535a93c344f0c" alt="minicom" width="576" height="276" /></en-media></a></div><p></p>
<p>按回车并选&rdquo;Exit&rdquo;进入minicom主界面（当然也可以保存下配置），键盘随便敲些字符。能够成功显示键入字符，说明模块的TX/RX均正常，可以连接机器了。按Ctrl-A接着按Z，按X退出minicom</p>
<p>拔下模块接上刷机线，黑线接GND，红色和白色分别接TXD和RXD。TX/RX经常会弄反，这里LED指示灯就能派上用场了</p>
<div>

<pre>sudo&nbsp;minicom&nbsp;-D&nbsp;/dev/ttyUSB0&nbsp;-b&nbsp;115385&nbsp;-s
</pre>
</div>
<p>像刚才一样关掉&rdquo;Hardware&nbsp;Flow&nbsp;Control&rdquo;进入，将C118关机并短按电源键，连接正常的话会显示下面的内容先显示ftmtool，接着大约1秒后输出error，看到这个说明连接无误。</p>
<p><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/minicom_2.png" TARGET="_blank"></a></p><div><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/minicom_2.png" TARGET="_blank"><img src="../_resources/a1c722ce164c9a77d206a53660c26b49.png"  type="image/png" hash="a1c722ce164c9a77d206a53660c26b49" alt="minicom_2" width="346" height="178" /></en-media></a></div><p></p>
<p>已经成功了一半，下面祈祷C118的硬件没有故障。</p>
<p>参考osmocon的使用教程<a HREF="http://bb.osmocom.org/trac/wiki/osmocon" TARGET="_blank">http://bb.osmocom.org/trac/wiki/osmocon</a></p>
<p>先为osmocom创建配置文件</p>
<div>

<pre>sudo&nbsp;mkdir&nbsp;/etc/osmocom/
sudo&nbsp;touch&nbsp;/etc/osmocom/osmocom.cfg
</pre>
</div>
<p>接着确认机器型号，C118是compal_e88的固件，使用osmocon需要刷入layer1，位于<br/>
src/target/firmware/board/compal_e88/layer1.compalram.bin</p>
<div>

<pre>cd&nbsp;~/osmocom-bb/src/
cd&nbsp;host/osmocon/&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;一些在电脑上运行的工具都在host目录下
</pre>
</div>
<p>使用下面命令启动osmocon等待刷机：</p>
<div>

<pre>sudo&nbsp;./osmocon&nbsp;-p&nbsp;/dev/ttyUSB0&nbsp;-m&nbsp;c123xor&nbsp;../../target/firmware/board/compal_e88/layer1.compalram.bin
</pre>
</div>
<p>此时确保C118在关机状态，将刷机线插到底后，短按电源键：</p>
<div>

<pre>got&nbsp;1&nbsp;bytes&nbsp;from&nbsp;modem,&nbsp;data&nbsp;looks&nbsp;like:&nbsp;04&nbsp;&nbsp;.
got&nbsp;1&nbsp;bytes&nbsp;from&nbsp;modem,&nbsp;data&nbsp;looks&nbsp;like:&nbsp;81&nbsp;&nbsp;.
got&nbsp;4&nbsp;bytes&nbsp;from&nbsp;modem,&nbsp;data&nbsp;looks&nbsp;like:&nbsp;1b&nbsp;f6&nbsp;02&nbsp;00&nbsp;&nbsp;....
got&nbsp;1&nbsp;bytes&nbsp;from&nbsp;modem,&nbsp;data&nbsp;looks&nbsp;like:&nbsp;41&nbsp;&nbsp;A
got&nbsp;1&nbsp;bytes&nbsp;from&nbsp;modem,&nbsp;data&nbsp;looks&nbsp;like:&nbsp;01&nbsp;&nbsp;.
got&nbsp;1&nbsp;bytes&nbsp;from&nbsp;modem,&nbsp;data&nbsp;looks&nbsp;like:&nbsp;40&nbsp;&nbsp;@
Received&nbsp;PROMPT1&nbsp;from&nbsp;phone,&nbsp;responding&nbsp;with&nbsp;CMD
read_file(../../target/firmware/board/compal_e88/layer1.compalram.bin):&nbsp;file_size=55940,&nbsp;hdr_len=4,&nbsp;dnload_len=55947
got&nbsp;1&nbsp;bytes&nbsp;from&nbsp;modem,&nbsp;data&nbsp;looks&nbsp;like:&nbsp;1b&nbsp;&nbsp;.
got&nbsp;1&nbsp;bytes&nbsp;from&nbsp;modem,&nbsp;data&nbsp;looks&nbsp;like:&nbsp;f6&nbsp;&nbsp;.
got&nbsp;1&nbsp;bytes&nbsp;from&nbsp;modem,&nbsp;data&nbsp;looks&nbsp;like:&nbsp;02&nbsp;&nbsp;.
got&nbsp;1&nbsp;bytes&nbsp;from&nbsp;modem,&nbsp;data&nbsp;looks&nbsp;like:&nbsp;00&nbsp;&nbsp;.
got&nbsp;1&nbsp;bytes&nbsp;from&nbsp;modem,&nbsp;data&nbsp;looks&nbsp;like:&nbsp;41&nbsp;&nbsp;A
got&nbsp;1&nbsp;bytes&nbsp;from&nbsp;modem,&nbsp;data&nbsp;looks&nbsp;like:&nbsp;02&nbsp;&nbsp;.
got&nbsp;1&nbsp;bytes&nbsp;from&nbsp;modem,&nbsp;data&nbsp;looks&nbsp;like:&nbsp;43&nbsp;&nbsp;C
Received&nbsp;PROMPT2&nbsp;from&nbsp;phone,&nbsp;starting&nbsp;download
handle_write():&nbsp;4096&nbsp;bytes&nbsp;(4096/55947)
handle_write():&nbsp;4096&nbsp;bytes&nbsp;(8192/55947)
handle_write():&nbsp;4096&nbsp;bytes&nbsp;(12288/55947)
handle_write():&nbsp;4096&nbsp;bytes&nbsp;(16384/55947)
handle_write():&nbsp;4096&nbsp;bytes&nbsp;(20480/55947)
handle_write():&nbsp;4096&nbsp;bytes&nbsp;(24576/55947)
handle_write():&nbsp;4096&nbsp;bytes&nbsp;(28672/55947)
handle_write():&nbsp;4096&nbsp;bytes&nbsp;(32768/55947)
handle_write():&nbsp;4096&nbsp;bytes&nbsp;(36864/55947)
handle_write():&nbsp;4096&nbsp;bytes&nbsp;(40960/55947)
handle_write():&nbsp;4096&nbsp;bytes&nbsp;(45056/55947)
handle_write():&nbsp;4096&nbsp;bytes&nbsp;(49152/55947)
handle_write():&nbsp;4096&nbsp;bytes&nbsp;(53248/55947)
handle_write():&nbsp;2699&nbsp;bytes&nbsp;(55947/55947)
handle_write():&nbsp;finished
</pre>
</div>
<p><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/flash1.png" TARGET="_blank"></a></p><div><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/flash1.png" TARGET="_blank"><img src="../_resources/1de8bc4fd239a24900317e03aed35260.png"  type="image/png" hash="1de8bc4fd239a24900317e03aed35260" alt="flash1" width="576" height="352" /></en-media></a></div><p></p>
<p>上面步骤一切正常的情况下，会看到DOWNLOAD&nbsp;ACK和OSMOCOM&nbsp;Layer&nbsp;1的提示，此时C118屏幕上已经显示出layer1的界面了：</p>
<div>

<pre>got&nbsp;1&nbsp;bytes&nbsp;from&nbsp;modem,&nbsp;data&nbsp;looks&nbsp;like:&nbsp;1b&nbsp;&nbsp;.
got&nbsp;1&nbsp;bytes&nbsp;from&nbsp;modem,&nbsp;data&nbsp;looks&nbsp;like:&nbsp;f6&nbsp;&nbsp;.
got&nbsp;1&nbsp;bytes&nbsp;from&nbsp;modem,&nbsp;data&nbsp;looks&nbsp;like:&nbsp;02&nbsp;&nbsp;.
got&nbsp;1&nbsp;bytes&nbsp;from&nbsp;modem,&nbsp;data&nbsp;looks&nbsp;like:&nbsp;00&nbsp;&nbsp;.
got&nbsp;1&nbsp;bytes&nbsp;from&nbsp;modem,&nbsp;data&nbsp;looks&nbsp;like:&nbsp;41&nbsp;&nbsp;A
got&nbsp;1&nbsp;bytes&nbsp;from&nbsp;modem,&nbsp;data&nbsp;looks&nbsp;like:&nbsp;03&nbsp;&nbsp;.
got&nbsp;1&nbsp;bytes&nbsp;from&nbsp;modem,&nbsp;data&nbsp;looks&nbsp;like:&nbsp;42&nbsp;&nbsp;B
Received&nbsp;DOWNLOAD&nbsp;ACK&nbsp;from&nbsp;phone,&nbsp;your&nbsp;code&nbsp;is&nbsp;running&nbsp;now!
battery_compal_e88_init:&nbsp;starting&nbsp;up


OSMOCOM&nbsp;Layer&nbsp;1&nbsp;(revision&nbsp;osmocon_v0.0.0-1351-g074c78a-modified)
</pre>
</div>
<p><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/flash2.png" TARGET="_blank"></a></p><div><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/flash2.png" TARGET="_blank"><img src="../_resources/112f976079c016b20e6f2e8603b3f86c.png"  type="image/png" hash="112f976079c016b20e6f2e8603b3f86c" alt="flash2" width="547" height="483" /></en-media></a></div><p></p>
<p>因为是软刷，按电源键大约2秒会关机。关机后需要重新执行上面操作刷入layer1<br/>
如果想把固件烧入手机中，可以参考这里：<a HREF="http://bb.osmocom.org/trac/wiki/flashing_new" TARGET="_blank">http://bb.osmocom.org/trac/wiki/flashing_new</a><br/>
也许是版本问题，在我的机器上总是提示crc错误。想想刷完这个还不能用直充充电，还是每次用之前软刷好了。</p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>
<p>然而，不是事事都那么顺利。我有幸买到一台有问题的C118，断电后第一次刷机，总是无法收到DOWNLOAD&nbsp;ACK，直接卡死在handle_write():&nbsp;finished这里。此时屏幕不亮短按电源键也没有任何反应：</p>
<p><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/flash1.png" TARGET="_blank"></a></p><div><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/flash1.png" TARGET="_blank"><img src="../_resources/1de8bc4fd239a24900317e03aed35260.png"  type="image/png" hash="1de8bc4fd239a24900317e03aed35260" alt="flash1" width="576" height="352" /></en-media></a></div><p></p>
<p>虽然不是Android系统，一样可以祭出Android三宝绝招&mdash;&mdash;<b>拔电池</b>。重新插上电池后，短按电源重新刷入，正常看到OSMOCOM&nbsp;Layer&nbsp;1的提示（建议遇到各种非线缆相关的疑难杂症，都先尝试下拔电池重刷，这个好像是osmocom不稳定导致的）</p>
<p>另外，这里说下我之前犯的一个低级错误：模块和连接都确认没问题，但按电源键确输出一堆乱码。</p>
<p><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/error_line.jpg" TARGET="_blank"></a></p><div><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/error_line.jpg" TARGET="_blank"><img src="../_resources/8bb9c82feaa41712611b6bf0601e4c9c.jpg"  type="image/jpeg" hash="8bb9c82feaa41712611b6bf0601e4c9c" alt="error_line" width="576" height="217" /></en-media></a></div><p></p>
<p>这个网上Google了好久都没有结果，甚至mail&nbsp;list里还有哥们说是手机的接收模块烧了。结果最后卖家发来张图片：（抱歉旺信丢消息了，图片找不到了<img SRC="" TITLE="124.gif" WIDTH="69" HEIGHT="34"/>&nbsp;大致就是红圈这里，没有插到位）</p>
<p><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/czxa.jpg" TARGET="_blank"></a></p><div><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/czxa.jpg" TARGET="_blank"><img src="../_resources/3ce23a0109d17b24a966754669841ccf.jpg"  type="image/jpeg" hash="3ce23a0109d17b24a966754669841ccf" alt="czxa" width="576" height="392" /></en-media></a></div><p></p>
<p>打开电池后盖才发现，如果不用小刀狠狠削掉一圈，这个数据线根本没法插到底。（微博上也看到2个同学遇到相同的问题，看来数据线都是同一家买的-_-b）</p>
<p>另外一种情况是只收到PROMPT1后，就出现ftmtool&nbsp;error了。网上有种说法是主机的时钟频率太慢（比如在虚拟机里跑osmocon），导致没有发完就超时了。但我专门用VMWARE测试，并没有遇到这样的问题。<br/>
个人理解是osmocomBB的刷机不稳定，遇到这种情况请先检查是否用了burst_ind分支(也就是sylvain/testing)，我之前就因为用的这份老代码，导致刷一下午只有1-2次能成功。另外还可以把-m&nbsp;c123xor换成-m&nbsp;c123试试，有时候去掉xor方式后可以正常刷进去。<br/>
更新libosmocore并换成luca/gsmmap分支后，就再也没有遇到这个情况了。</p>
<p>我并非通信专业出身，GSM网络的各种概念在此之前一无所知，如果文章中有错误欢迎指正:) </p>
<p>之前介绍了OsmocomBB的硬件与刷机，这里重点介绍下其附带软件的使用。</p>
<p>参考<a HREF="http://bb.osmocom.org/trac/wiki/Applications" TARGET="_blank"><b>官方wiki</b></a>可以知道osmocomBB的代码可以分为两种：一种是在手机基带芯片上跑的layer1（物理传输层）；另一种是在PC上跑的与layer1通信，提供上层服务的程序：</p>
<div>

<pre>[root@ArchDev&nbsp;~]#&nbsp;cd&nbsp;osmocom-bb/src/
[root@ArchDev&nbsp;src]#&nbsp;ls
Makefile&nbsp;&nbsp;README.building&nbsp;&nbsp;README.development&nbsp;&nbsp;host&nbsp;&nbsp;shared&nbsp;&nbsp;target&nbsp;&nbsp;target_dsp&nbsp;&nbsp;wireshark
</pre>
</div>
<p>target下就是针对各手机的固件，bin位于target/firmware/board/compal_e88下。Baseband&nbsp;firmware一节介绍了不同固件的功能和对应程序，*.compalram是软刷用的，断电后需要重新刷机。*.e88flash/*.e88loader是配合loader使用的，刷入前需要参考&nbsp;<a HREF="http://bb.osmocom.org/trac/wiki/flashing_new" TARGET="_blank">http://bb.osmocom.org/trac/wiki/flashing_new</a>&nbsp;把loader写到手机中，然后在手机上用loader运行。</p>
<p>后面cell_log和ccch_scan都是对应layer1的，因为直接写入有一定危险性，本文只演示软刷(layer1.compalram)的使用方法。</p>
<p>回到src目录下，接着看PC侧的工具：</p>
<div>

<pre>[root@ArchDev&nbsp;~]#&nbsp;cd&nbsp;~/osmocom-bb/src/
[root@ArchDev&nbsp;host]#&nbsp;ls
calypso_pll&nbsp;&nbsp;fb_tools&nbsp;&nbsp;gsmmap&nbsp;&nbsp;layer23&nbsp;&nbsp;osmocon&nbsp;&nbsp;rita_pll
</pre>
</div>
<p>osmocon是刷入固件，并与固件通信的程序，使用方法（注意C118选<b>compal_e88/layer1.compalram.bin</b>这个固件）：</p>
<div>

<pre>$&nbsp;cd&nbsp;host/osmocon/
$&nbsp;./osmocon&nbsp;-p&nbsp;/dev/ttyUSB0&nbsp;-m&nbsp;c123xor&nbsp;../../target/firmware/board/compal_e88/layer1.compalram.bin
</pre>
</div>
<p>将C118关机后，短按电源键就开始运行了。刷机过程和常见问题硬件篇都已经提过，这里不再详述。</p>
<p><b>layer23</b>下，有实现不同功能的数据链路层/网络层程序，比如模拟手机功能的mobile（接入网络需要SIM卡），以及抓取相关信息的杂项程序。直接进入misc目录：</p>
<div>

<pre>cd&nbsp;layer23/src/misc/
</pre>
</div>
<p><b>cell_log</b>是一个扫描有效运营商频率，并收集BCCH上基本信息的工具，我们先用它来获取运营商的ARFCN、MNC和MCC等信息。这里不需要gprs数据，直接使用这个参数：</p>
<div>

<pre>-O&nbsp;--only-scan&nbsp;&nbsp;Do&nbsp;a&nbsp;scan&nbsp;and&nbsp;show&nbsp;available&nbsp;ARFCNs,&nbsp;no&nbsp;data&nbsp;logging

<b>./cell_log&nbsp;--only-scan</b>
...
&lt;000e&gt;&nbsp;cell_log.c:248&nbsp;Cell:&nbsp;ARFCN=56&nbsp;PWR=-67dB&nbsp;MCC=460&nbsp;MNC=00&nbsp;(China,&nbsp;China&nbsp;Mobile)
</pre>
</div>
<p><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/cell_log.png" TARGET="_blank"></a></p><div><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/cell_log.png" TARGET="_blank"><img src="../_resources/2c21021c632bd848e94bfe45256ebc0f.png"  type="image/png" hash="2c21021c632bd848e94bfe45256ebc0f" alt="cell_log" width="576" height="284" /></en-media></a></div><p></p>
<p>例如这里选取信号最强的<b>ARFCN=56</b>&nbsp;(China&nbsp;Mobile)，有了这个就可以开始抓取Common&nbsp;Control&nbsp;Channel&nbsp;(CCCH)了：</p>
<div>

<pre>./ccch_scan&nbsp;&nbsp;-i&nbsp;127.0.0.1
</pre>
</div>
<p>看到ccch_scan开始输出burst内容后，就可以</p>
<div>

<pre>sudo&nbsp;wireshark&nbsp;-k&nbsp;-i&nbsp;lo&nbsp;-f&nbsp;&apos;port&nbsp;4729&apos;
</pre>
</div>
<p>打开Wireshark来抓GSMTAP，设置&nbsp;gsm_sms&nbsp;过滤器即可看到SMS报文内容：</p>
<p><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/wireshark.jpg" TARGET="_blank"></a></p><div><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/wireshark.jpg" TARGET="_blank"><img src="../_resources/8adc534bcca5b9fdd39e6d2bd6f10000.jpg"  type="image/jpeg" hash="8adc534bcca5b9fdd39e6d2bd6f10000" alt="wireshark" width="576" height="360" /></en-media></a></div><p></p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>
<p>为了加深对SMS传输的理解，我写了个Python脚本来重组短信的PDU。<br/>
下面部分需要些GSM网络相关的知识，推荐&nbsp;<a HREF="http://web.it.kth.se/~johanmon/attic/2g1723/lectures.html" TARGET="_blank">GSM&nbsp;network&nbsp;and&nbsp;services&nbsp;2G1723&nbsp;2006</a></p>
<p><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/signaling_protocols.png" TARGET="_blank"></a></p><div><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/signaling_protocols.png" TARGET="_blank"><img src="../_resources/3e585937f0e31c1d09729d33e1b50e34.png"  type="image/png" hash="3e585937f0e31c1d09729d33e1b50e34" alt="signaling_protocols" width="576" height="332" /></en-media></a></div><p></p>
<p>从协议图中得知，移动设备(MS)和基站(BTS)间使用Um接口，最底层就是刷入手机的<b>layer1物理传输层</b>，之上分别是<b>layer2数据链路层</b>和<b>layer3网络层</b>。</p>
<p>位于图中layer2的<b>LAPDm</b>，是一种保证数据传输不会出错的协议。一个LAPDm帧共有23个字节（184个比特），提供分片管理控制等功能:</p>
<p><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/LAPDm.png" TARGET="_blank"></a></p><div><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/LAPDm.png" TARGET="_blank"><img src="../_resources/c027bc95654dd06d32b7544fb839cd9f.png"  type="image/png" hash="c027bc95654dd06d32b7544fb839cd9f" alt="LAPDm" width="353" height="253" /></en-media></a></div><p></p>
<p>layer3的协议则可以分为<b>RR/MM/CM</b>三种，这里只列出嗅探相关的功能：</p>
<div>

<pre><b>RR(Radio&nbsp;Resource&nbsp;Management)</b>：channel,&nbsp;cell控制等信息，可以忽略
<b>MM(Mobility&nbsp;Management)</b>：Location&nbsp;updating（如果需要接收方号码，需要关注这个动作）
<b>CM(Connection&nbsp;Management)</b>：Call&nbsp;Control（语音通话时的控制信息，可以知道何时开始捕获TCH）,&nbsp;SMS（这里的重点）
</pre>
</div>
<p>参考GSM的文档&nbsp;<a HREF="http://www.3gpp.org/DynaReport/0406.htm" TARGET="_blank">TS&nbsp;04.06</a>&nbsp;得知&nbsp;LAPDm&nbsp;的Address&nbsp;field字段中，定义了&nbsp;3.3.3&nbsp;Service&nbsp;access&nbsp;point&nbsp;identifier&nbsp;(SAPI)</p>
<div>

<pre>SAPI&nbsp;value&nbsp;&nbsp;Related&nbsp;entity&nbsp;
0&nbsp;&nbsp;Call&nbsp;control&nbsp;signalling,&nbsp;mobility&nbsp;management&nbsp;signalling&nbsp;and&nbsp;radio&nbsp;resource&nbsp;management&nbsp;signalling
3&nbsp;&nbsp;Short&nbsp;message&nbsp;service
</pre>
</div>
<p><b>SAPI=3</b>就是我们要的Short&nbsp;message&nbsp;service，如图：</p>
<p><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/CM_SMS.png" TARGET="_blank"></a></p><div><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/CM_SMS.png" TARGET="_blank"><img src="../_resources/4dfbf2cd8378e30e84eae7ac56452f1a.png"  type="image/png" hash="4dfbf2cd8378e30e84eae7ac56452f1a" alt="CM_SMS" width="507" height="306" /></en-media></a></div><p></p>
<p>3gpp的GSM文档看得比较晕，这里直接对照Wireshark里的gsm_sms报文分析，发现SMS帧实际是重组LAPDm的payload得到的。也就说如果想自己处理SMS帧，就必须也和Wireshark一样重组LAPDm的payload，并解析其中的SMS&nbsp;PDU。</p>
<p><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/GSMTAP_cap.png" TARGET="_blank"></a></p><div><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/GSMTAP_cap.png" TARGET="_blank"><img src="../_resources/6b4f256fc6c9dda0e5ad6982c22a33ca.png"  type="image/png" hash="6b4f256fc6c9dda0e5ad6982c22a33ca" alt="GSMTAP_cap" width="576" height="494" /></en-media></a></div><p></p>
<p>这是一个<b>SAPI=3</b>的LAPDm报文头部。GSMTAP是一种伪头部<a HREF="http://bb.osmocom.org/trac/wiki/GSMTAP" TARGET="_blank">http://bb.osmocom.org/trac/wiki/GSMTAP</a>，记录了burst的一些基本信息（如ChannelType，ARFCN，上行还是下行等）。因为是用ccch_scan捕获的流量，编码时只用关注&nbsp;Channel&nbsp;Type:&nbsp;SDCCH/8&nbsp;的LADPm协议。</p>
<p>为了方便访问，定义GSMTAP类如下，传入udp&nbsp;payload部分，解析GSMTAP并提供其后的数据：</p>
<div>

<pre>class&nbsp;GSMTAP:
&nbsp;&nbsp;def&nbsp;__init__(self,&nbsp;gsmtap):
&nbsp;&nbsp;&nbsp;&nbsp;self.gsmtap&nbsp;=&nbsp;gsmtap

&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;version&quot;,&nbsp;ord(gsmtap[0]))
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;hdr_len&quot;,&nbsp;ord(gsmtap[1])&nbsp;&lt;&lt;&nbsp;2)
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;payload_type&quot;,&nbsp;ord(gsmtap[2]))

&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;time_slot&quot;,&nbsp;ord(gsmtap[3]))
&nbsp;&nbsp;&nbsp;&nbsp;ARFCN&nbsp;=&nbsp;(ord(gsmtap[4])&amp;0x3F)*0x100&nbsp;+&nbsp;ord(gsmtap[5])
&nbsp;&nbsp;&nbsp;&nbsp;UPLINK&nbsp;=&nbsp;ord(gsmtap[4])&nbsp;&gt;&gt;&nbsp;6
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;arfcn&quot;,&nbsp;ARFCN)
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;link&quot;,&nbsp;UPLINK)

&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;signal_noise&quot;,&nbsp;ord(gsmtap[6]))
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;signal_level&quot;,&nbsp;ord(gsmtap[7]))
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;GSM&nbsp;Frame&nbsp;Number
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;channel_type&quot;,&nbsp;ord(gsmtap[12]))
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;antenna_number&quot;,&nbsp;ord(gsmtap[13]))
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;sub_slot&quot;,&nbsp;ord(gsmtap[14]))

&nbsp;&nbsp;def&nbsp;get_payload(self):
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;self.gsmtap[self.hdr_len:]
</pre>
</div>
<p>GSMTAP&nbsp;Header之后是&nbsp;Link&nbsp;Access&nbsp;Procedure,&nbsp;Channel&nbsp;Dm，即LAPDm。参考TS&nbsp;04.06有3个关键字段:&nbsp;<b>Address&nbsp;Field，Control&nbsp;Field，Length&nbsp;Field</b></p>
<p><b>Address&nbsp;Field</b>除了上面说的SAPI外都可以不关注。<br/>
<b>Control&nbsp;Field</b>比较关键，里面记录了该LAPDm的分片信息。Frame&nbsp;type:&nbsp;Information&nbsp;frame说明当前是I帧(I&nbsp;frame)，其余bit为N(S)和N(R)。Send&nbsp;sequence&nbsp;number&nbsp;N(S)标记该分片的顺序，从0开始递增。看Wireshark源码说实际有些N(S)可能不是从0开始的，这里组包就不判断N(S)是否为0直接按顺序附加。N(R)是Receive&nbsp;sequence&nbsp;number，看文档上I帧传输时N(R)的状态没看明白，直接默认同时间只有1个下行短信了，这样收到的N(R)基本是一样的（事实上大部分时候都是如此）<br/>
<b>Length&nbsp;Field</b>除了长度信息，还有&nbsp;More&nbsp;segments&nbsp;标记，直到这个位为0才表示接收完一个完整的SMS报文</p>
<div>

<pre>class&nbsp;LAPDm:
&nbsp;&nbsp;def&nbsp;__init__(self,&nbsp;lapdm):
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;lapdm&quot;,&nbsp;lapdm)

&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;addr_field&quot;,&nbsp;ord(lapdm[0]))
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;lpd&quot;,&nbsp;(ord(lapdm[0])&gt;&gt;5)&amp;0x3)
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;sapi&quot;,&nbsp;(ord(lapdm[0])&gt;&gt;2)&amp;0x7)

&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;ctrl_field&quot;,&nbsp;ord(lapdm[1]))
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;n_r&quot;,&nbsp;ord(lapdm[1])&gt;&gt;5)
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;n_s&quot;,&nbsp;(ord(lapdm[1])&gt;&gt;1)&amp;0x7)

&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;len_field&quot;,&nbsp;ord(lapdm[2]))
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;has_more&quot;,&nbsp;(ord(lapdm[2])&gt;&gt;1)&amp;0x1)
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;length&quot;,&nbsp;ord(lapdm[2])&gt;&gt;2)

&nbsp;&nbsp;def&nbsp;get_data(self):
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;self.lapdm[3:]
</pre>
</div>
<p>之后就可以这样，获得LAPDm的相关信息了：</p>
<div>

<pre>gsmtap&nbsp;=&nbsp;GSMTAP(gsm_payload)
lapdm&nbsp;=&nbsp;LAPDm(gsmtap.get_payload())

if&nbsp;(gsmtap.channel_type&nbsp;==&nbsp;8)&nbsp;and&nbsp;(lapdm.sapi&nbsp;==&nbsp;3):&nbsp;&nbsp;#&nbsp;TS&nbsp;04.06,&nbsp;3.3.3,&nbsp;SAPI:&nbsp;3&nbsp;-&nbsp;Short&nbsp;message&nbsp;service
&nbsp;&nbsp;debug_printf(&quot;LINK[%d]&nbsp;ARFCN=%d&nbsp;TIME_SLOT=%d&nbsp;CHANNEL=%d,&nbsp;N(R)=%d&nbsp;N(S)=%d,&nbsp;segment&nbsp;more[%d],&nbsp;payload&nbsp;len=%d\n&quot;&nbsp;%&nbsp;\
&nbsp;&nbsp;&nbsp;&nbsp;(gsmtap.link,&nbsp;gsmtap.arfcn,&nbsp;gsmtap.time_slot,&nbsp;gsmtap.channel_type,&nbsp;lapdm.n_r,&nbsp;lapdm.n_s,&nbsp;lapdm.has_more,&nbsp;lapdm.length))

&nbsp;&nbsp;last_sms_payload&nbsp;+=&nbsp;lapdm.get_data()&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;附加本次收到的数据
&nbsp;&nbsp;if&nbsp;(lapdm.has_more&nbsp;==&nbsp;0):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;最后一个分片，解析整个&nbsp;SMS&nbsp;payload
&nbsp;&nbsp;&nbsp;&nbsp;hexdump(last_sms_payload)
&nbsp;&nbsp;&nbsp;&nbsp;last_sms_payload&nbsp;=&nbsp;&quot;&quot;
</pre>
</div>
<p>接着看wireshark中重组的payload，确认得到的last_sms_payload和wireshark中解析的一致。</p>
<p>在wireshark中展开一个重组后的SMS报文</p>
<p><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/SMS.png" TARGET="_blank"></a></p><div><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/SMS.png" TARGET="_blank"><img src="../_resources/e3cab3546f2966a1e82a363514a0e091.png"  type="image/png" hash="e3cab3546f2966a1e82a363514a0e091" alt="SMS" width="576" height="334" /></en-media></a></div><p></p>
<p>可以看到，在&nbsp;GSM&nbsp;SMS&nbsp;TPDU&nbsp;(GSM&nbsp;03.40)&nbsp;SMS-DELIVER&nbsp;之前，还有CP-DATA/RP-DATA头，RP-DATA中有短信中心的信息，但没什么作用直接跳过。我们只需要知道后面SMS&nbsp;TPDU的长度即可：</p>
<div>

<pre>class&nbsp;SMS:
&nbsp;&nbsp;def&nbsp;__init__(self,&nbsp;payload):
&nbsp;&nbsp;&nbsp;&nbsp;self.payload&nbsp;=&nbsp;payload

&nbsp;&nbsp;&nbsp;&nbsp;iOff&nbsp;=&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;CP-DATA
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;protocol&quot;,&nbsp;ord(payload[iOff])&amp;0xF);&nbsp;iOff+=1
&nbsp;&nbsp;&nbsp;&nbsp;iOff&nbsp;+=&nbsp;2

&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;RP-DATA&nbsp;(Network&nbsp;to&nbsp;MS)
&nbsp;&nbsp;&nbsp;&nbsp;iOff&nbsp;+=&nbsp;2
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;RP_origin_len&quot;,&nbsp;ord(payload[iOff]));&nbsp;iOff+=1
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;RP_origin_ext&quot;,&nbsp;ord(payload[iOff]));
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;RP_origin&quot;,&nbsp;bcdDigits(payload[iOff+1:iOff+self.RP_origin_len]))
&nbsp;&nbsp;&nbsp;&nbsp;iOff&nbsp;+=&nbsp;self.RP_origin_len

&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;RP_dest_len&quot;,&nbsp;ord(payload[iOff]));&nbsp;iOff+=1
&nbsp;&nbsp;&nbsp;&nbsp;iOff&nbsp;+=&nbsp;self.RP_dest_len

&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;length&quot;,&nbsp;ord(payload[iOff]));&nbsp;iOff+=1
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;tpdu_off&quot;,&nbsp;iOff);

&nbsp;&nbsp;def&nbsp;get_tpdu(self):
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;self.payload[self.tpdu_off:self.tpdu_off+self.length]
</pre>
</div>
<p>调用&nbsp;<b>get_tpdu()</b>&nbsp;就会返回TPDU内容，里面TP-Originating-Address就是发送者的号码，TP-User-Data就是我们要的短信内容。</p>
<div>

<pre>class&nbsp;TPDU:
&nbsp;&nbsp;def&nbsp;__init__(self,&nbsp;tpdu):
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;tpdu&quot;,&nbsp;tpdu)
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;iOff&nbsp;=&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;SMS-DELIVER
&nbsp;&nbsp;&nbsp;&nbsp;iOff&nbsp;+=&nbsp;1
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;TP_origin_num&quot;,&nbsp;ord(tpdu[iOff]));&nbsp;iOff+=1
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;TP_origin_len&quot;,&nbsp;(self.TP_origin_num&gt;&gt;1)+(self.TP_origin_num%2))
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;TP_origin_ext&quot;,&nbsp;ord(tpdu[iOff]));&nbsp;iOff+=1
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;TP_origin&quot;,&nbsp;bcdDigits(tpdu[iOff:iOff+self.TP_origin_len]))
&nbsp;&nbsp;&nbsp;&nbsp;iOff&nbsp;+=&nbsp;self.TP_origin_len

&nbsp;&nbsp;&nbsp;&nbsp;iOff&nbsp;+=&nbsp;2
&nbsp;&nbsp;&nbsp;&nbsp;iOff&nbsp;+=&nbsp;7&nbsp;&nbsp;#&nbsp;TimeStamp

&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;tpu_len&quot;,&nbsp;ord(tpdu[iOff]));&nbsp;iOff+=1
&nbsp;&nbsp;&nbsp;&nbsp;setattr(self,&nbsp;&quot;data&quot;,&nbsp;tpdu[iOff:iOff+self.tpu_len])

&nbsp;&nbsp;def&nbsp;get_data(self):
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;self.data.decode(&quot;utf-16be&quot;).encode(&quot;utf-8&quot;)
</pre>
</div>
<p>中文在SMS中是UCS2编码的，<b>get_data()</b>&nbsp;是用python的utf-16be解码原始数据，并转成UTF-8输出。</p>
<p>好了，加上process_sms_tpdu()函数，最终代码就是这样：</p>
<div>

<pre>def&nbsp;process_sms_tpdu(sms_payload):
&nbsp;&nbsp;hexdump(sms_payload)

&nbsp;&nbsp;sms&nbsp;=&nbsp;SMS(sms_payload)
&nbsp;&nbsp;tpdu&nbsp;=&nbsp;TPDU(sms.get_tpdu())
&nbsp;&nbsp;debug_printf(&quot;[SMS&nbsp;from&nbsp;%s]&nbsp;%s&quot;&nbsp;%&nbsp;(tpdu.TP_origin,&nbsp;tpdu.get_data()))

def&nbsp;handle_tcpdump_buffer(title,&nbsp;buffer):
&nbsp;&nbsp;raw_struct&nbsp;=&nbsp;str2rawbuf(buffer)
&nbsp;&nbsp;udp_packet&nbsp;=&nbsp;UDP(raw_struct)
&nbsp;&nbsp;gsm_payload&nbsp;=&nbsp;udp_packet.get_payload()
&nbsp;&nbsp;#hexdump(gsm_payload)

&nbsp;&nbsp;gsmtap&nbsp;=&nbsp;GSMTAP(gsm_payload)
&nbsp;&nbsp;lapdm&nbsp;=&nbsp;LAPDm(gsmtap.get_payload())

&nbsp;&nbsp;if&nbsp;(gsmtap.channel_type&nbsp;==&nbsp;8)&nbsp;and&nbsp;(lapdm.sapi&nbsp;==&nbsp;3):&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;TS&nbsp;04.06,&nbsp;3.3.3,&nbsp;SAPI:&nbsp;3&nbsp;-&nbsp;Short&nbsp;message&nbsp;service
&nbsp;&nbsp;&nbsp;&nbsp;debug_printf(&quot;LINK[%d]&nbsp;ARFCN=%d&nbsp;TIME_SLOT=%d&nbsp;CHANNEL=%d,&nbsp;N(R)=%d&nbsp;N(S)=%d,&nbsp;segment&nbsp;more[%d],&nbsp;payload&nbsp;len=%d\n&quot;&nbsp;%&nbsp;\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(gsmtap.link,&nbsp;gsmtap.arfcn,&nbsp;gsmtap.time_slot,&nbsp;gsmtap.channel_type,&nbsp;lapdm.n_r,&nbsp;lapdm.n_s,&nbsp;lapdm.has_more,&nbsp;lapdm.length))

&nbsp;&nbsp;&nbsp;&nbsp;global&nbsp;last_sms_payload
&nbsp;&nbsp;&nbsp;&nbsp;last_sms_payload&nbsp;+=&nbsp;lapdm.get_data()
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(lapdm.has_more&nbsp;==&nbsp;0):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process_sms_tpdu(last_sms_payload)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last_sms_payload&nbsp;=&nbsp;&quot;&quot;
</pre>
</div>
<p><b>注：文末的&nbsp;gsmtap_sms_decode_src.7z&nbsp;里有完整的解析脚本</b>&nbsp;使用&nbsp;./ccch_scan&nbsp;-a&nbsp;ARFCN&nbsp;-i&nbsp;127.0.0.1&nbsp;将GSMTAP转发到本机的4729端口后，可以用这个脚本来重组SMS报文：<br/>
<b>tcpdump&nbsp;-l&nbsp;-ilo&nbsp;-nXs0&nbsp;udp&nbsp;and&nbsp;port&nbsp;4729&nbsp;|&nbsp;python2&nbsp;-u&nbsp;show_gsmtap_sms.py</b></p>
<p>运行截图：</p>
<p><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/gsm_sms.jpg" TARGET="_blank"></a></p><div><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/gsm_sms.jpg" TARGET="_blank"><img src="../_resources/0537bb8172d846b706b221062d02d418.jpg"  type="image/jpeg" hash="0537bb8172d846b706b221062d02d418" alt="gsm_sms" width="576" height="432" /></en-media></a></div><p></p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>
<p>上面脚本只是为了熟悉lapdm的重组，并未处理N(S)非零，以及并发时下行短信的重组<img SRC="" TITLE="124.gif" WIDTH="69" HEIGHT="34"/>&nbsp;建议有一定编码能力的同学，可以参考<a HREF="http://anonsvn.wireshark.org/wireshark/trunk/epan/dissectors/packet-lapdm.c" TARGET="_blank">wireshark源码</a>进行数据还原：</p>
<div>

<pre>static&nbsp;void
<b>dissect_lapdm</b>(tvbuff_t&nbsp;*tvb,&nbsp;packet_info&nbsp;*pinfo,&nbsp;proto_tree&nbsp;*tree)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Rely&nbsp;on&nbsp;caller&nbsp;to&nbsp;provide&nbsp;a&nbsp;way&nbsp;to&nbsp;group&nbsp;fragments&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fragment_id&nbsp;=&nbsp;(pinfo-&gt;circuit_id&nbsp;&lt;&lt;&nbsp;4)&nbsp;|&nbsp;(sapi&nbsp;&lt;&lt;&nbsp;1)&nbsp;|&nbsp;pinfo-&gt;p2p_dir;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;This&nbsp;doesn&apos;t&nbsp;seem&nbsp;the&nbsp;best&nbsp;way&nbsp;of&nbsp;doing&nbsp;it&nbsp;as&nbsp;doesn&apos;t
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;take&nbsp;N(S)&nbsp;into&nbsp;account,&nbsp;but&nbsp;N(S)&nbsp;isn&apos;t&nbsp;always&nbsp;0&nbsp;for
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;first&nbsp;fragment!
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fd_m&nbsp;=&nbsp;<b>fragment_add_seq_next</b>&nbsp;(&amp;lapdm_reassembly_table,&nbsp;payload,&nbsp;0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pinfo,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fragment_id,&nbsp;/*&nbsp;guint32&nbsp;ID&nbsp;for&nbsp;fragments&nbsp;belonging&nbsp;together&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*n_s&nbsp;guint32&nbsp;fragment&nbsp;sequence&nbsp;number&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len,&nbsp;/*&nbsp;guint32&nbsp;fragment&nbsp;length&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m);&nbsp;/*&nbsp;More&nbsp;fragments?&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;...
}
</pre>
</div>
<p>另外细心的各位可能会奇怪，下行短信里怎么没有短信接受者的号码，这里有篇关于SMS传输的基本原理说明：<br/>
<a HREF="http://robinlea.com/pub/Amphol/Security_Research_Labs.html" TARGET="_blank">http://robinlea.com/pub/Amphol/Secur&hellip;arch_Labs.html</a></p>
<p>简单来讲，短信接受者的号码、IMEI等数据，只有在&rdquo;Location&nbsp;Update&rdquo;时才会在网络中出现，并且是以加密形式传输的。当接收短信时，基站根据之前位置更新时注册的信息，判断接收者的位置。所以，想要拿到接受者的号码，需要破解A5/1算法并还原出&rdquo;Location&nbsp;Update&rdquo;时的原文<img SRC="" TITLE="恐怖!" WIDTH="57" HEIGHT="58"/></p>
<p><b>Airprobe</b>项目里有介绍如何破解A5/1算法找到Kc：<a HREF="https://srlabs.de/airprobe-how-to/" TARGET="_blank">https://srlabs.de/airprobe-how-to/</a>&nbsp;只不过需要价格昂贵的USRP2&hellip;<br/>
另外还看到个RTL-SDR的文章（就是以前传说中可以跟踪飞机的电视棒），也支持Airprobe：<br/>
<a HREF="http://www.rtl-sdr.com/rtl-sdr-tutorial-analyzing-gsm-with-airprobe-and-wireshark/" TARGET="_blank">http://www.rtl-sdr.com/rtl-sdr-tutor&hellip;and-wireshark/</a></p>
<p>到此，GSM&nbsp;Sniffering入门算是告一段落了，感谢各位的回帖与支持，以及zmworm版主的催稿，不然软件篇估计我要拖到年后<img SRC="" TITLE="扮鬼脸" WIDTH="68" HEIGHT="34"/><br/>
最近可能没有精力继续折腾GSM网络（年底事情多完全是借口，其实主要还是因为懒&hellip;），写这篇文章权当抛砖引玉了，希望能在看雪上看到A5/1破解和语音的还原，到时再来拜读各位的大作！ </p>
<p><a HREF="https://xmsg.org/wordpress/wp-content/uploads/2015/11/gsmtap_sms_decode_src.7z" TARGET="_blank">gsmtap_sms_decode_src</a></p>

&Tab;&Tab;&Tab;&Tab;&Tab;&Tab;&Tab;&Tab;&Tab;&Tab;&Tab;</div></div></div><br/></en-note>      
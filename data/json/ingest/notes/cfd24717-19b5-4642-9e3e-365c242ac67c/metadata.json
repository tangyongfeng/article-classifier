{
  "ingest_source": {
    "id": "4fa3e73a-ae37-4b3c-900f-e8e6bd0ee190",
    "source_type": "evernote_html",
    "source_path": "backups/2023年6月/IT技术/PostgreSQL操作JSON数据.html",
    "collected_at": "2025-11-10T15:43:31.155115Z",
    "external_id": null,
    "title_hint": null,
    "language_hint": "en",
    "captured_at": null,
    "checksum": "453e67095b024c6de2d0b8229f757809ea475ba577785251b259f3a9a6439f0b",
    "status": "pending",
    "notes": {
      "batch_id": "phase2-backfill-202306"
    }
  },
  "note": {
    "id": "cfd24717-19b5-4642-9e3e-365c242ac67c",
    "ingest_source_id": "4fa3e73a-ae37-4b3c-900f-e8e6bd0ee190",
    "canonical_title": "PostgreSQL操作JSON数据",
    "language": "en",
    "ingested_at": "2025-11-10T15:43:31.155120Z",
    "created_at": null,
    "status": "active",
    "importance": 0,
    "attributes": {
      "source_filename": "PostgreSQL操作JSON数据.html"
    }
  },
  "variants": [
    {
      "id": "2120f150-b6a7-489c-9e52-db4af9630db7",
      "note_id": "cfd24717-19b5-4642-9e3e-365c242ac67c",
      "variant_type": "raw_html",
      "version": 1,
      "created_by": "evernote_ingest:v0",
      "created_at": "2025-11-10T15:43:31.155123Z",
      "content": "---\ntitle: PostgreSQL操作JSON数据\nupdated: 2019-02-16 10:02:32Z\ncreated: 2019-02-16 10:02:32Z\nsource: https://my.oschina.net/swingcoder/blog/489769\n---\n\n\n<en-note>\n  <div>\n<div><br/></div><div STYLE=\"font-size: 16px; display:block; min-width: 100%; \"> <div STYLE=\"background-color:transparent;font:inherit;vertical-align:baseline;\"><div STYLE=\"background-color:transparent;font:inherit;vertical-align:baseline;font-family:&quot;PT Serif&quot;;font-size:16px;line-height:1.5em;color:rgb(31, 9, 9);text-align:left;\"><div STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;\"><div STYLE=\"z-index:200;padding-left:2em;padding-right:2em;margin-left:auto;margin-right:auto;position:relative;margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;width:36em;\"><div STYLE=\"position:relative;margin-left:-25px;margin-right:25px;margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;\"><div STYLE=\"position:relative;margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;padding-top:4.5em;padding-bottom:9em;\"><div STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\"><div STYLE=\"margin-bottom:0px;position:relative;margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;\"><div STYLE=\"margin-bottom:0px;margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;\"><div STYLE=\"margin-bottom:0px;margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;\"><h1 STYLE=\"padding:0px;margin:0px;border:0px;font:inherit;vertical-align:baseline;font-weight:normal;font-size:35px;line-height:35px;margin-bottom:20px;font-family:&quot;PT Serif&quot;;text-align:left;\"> PostgreSQL是不是你的下一个JSON数据库？ 转 </h1><div STYLE=\"margin-bottom:0px;position:relative;margin:0px;height:1em;line-height:1;text-align:center;padding:0px;border:0px;font:inherit;vertical-align:baseline;padding-top:1.5em;padding-bottom:1.5em;\"><div STYLE=\"margin-bottom:0px;position:absolute;left:-4em;top:50%;z-index:10;width:100%;padding-left:4em;padding-right:4em;height:0.1em;margin:0px;opacity:0.5;padding:0px;border:0px;font:inherit;vertical-align:baseline;background:-webkit-linear-gradient(0deg, rgb(243, 242, 238) 1%, rgb(31, 9, 9) 50%, rgb(243, 242, 238) 99%);\"><span STYLE=\"font:inherit;position:absolute;left:-4em;top:50%;z-index:10;width:100%;padding-left:4em;padding-right:4em;height:0.1em;margin:0px;opacity:0.5;background:-webkit-linear-gradient(0deg, rgb(243, 242, 238) 1%, rgb(31, 9, 9) 50%, rgb(243, 242, 238) 99%);\"></span></div></div></div>\n                    <div STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">\n                        <div STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">\n                            \n                            发布于 2015/08/09 15:48</div>\n                        <div STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">字数 1647</div>\n                        <div STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">阅读 464</div>\n                        <div STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">收藏 11</div>\n                        <div STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\"><a TARGET=\"_blank\" STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;text-decoration:none;color:rgb(6, 85, 136);\">点赞 0</a></div>\n                        <div STYLE=\"margin-bottom:0px;margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;\"><a HREF=\"https://my.oschina.net/swingcoder/blog/489769#comments\" TARGET=\"_blank\" STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;text-decoration:none;color:rgb(6, 85, 136);\"> 评论 0</a></div>\n                                            </div>\n                                                                        \n                                                                <div STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">\n                                                    \n                                                <p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">根据<a HREF=\"http://en.wikipedia.org/wiki/Betteridge%27s_law_of_headlines\" TARGET=\"_blank\" STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;text-decoration:none;color:rgb(6, 85, 136);\">Betteridge</a>定律（任何头条的设问句可以用一个词来回答：不是），除非你的JSON数据很少修改，并且查询很多。</p> \n<p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">最新版的PostgreSQL添加更多对JSON的支持，我们曾经问过PostgreSQL是否可以替换MongoDB作为JSON数据库，答案显而易见，但我们更希望的是，啊哈，这个问题由读者来问了。</p> \n\n<h4 STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-weight:bold;font-size:20px;margin-top:30px;margin-bottom:1.5em;font-family:&quot;PT Serif&quot;;text-align:left;\">&ldquo;PostgreSQL不是已经有一些json的支持了吗？&rdquo;</h4> \n<p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">是的，在PostgreSQL 9.4之前的版本也有JSON 数据类型了，你可以这样：</p> \n<pre STYLE=\"width:auto;margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-size:0.875em;line-height:1.71429em;background-color:rgb(243, 242, 238);font-family:Inconsolata;\"><code STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-size:1.15em;line-height:1.71429em;font-family:Inconsolata;\">CREATE&nbsp;TABLE&nbsp;justjson&nbsp;(&nbsp;id&nbsp;INTEGER,&nbsp;doc&nbsp;JSON)\n&gt;INSERT&nbsp;INTO&nbsp;justjson&nbsp;VALUES&nbsp;(&nbsp;1,&nbsp;&apos;{\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;name&quot;:&quot;fred&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;address&quot;:{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;line1&quot;:&quot;52&nbsp;The&nbsp;Elms&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;line2&quot;:&quot;Elmstreet&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;postcode&quot;:&quot;ES1&nbsp;1ES&quot;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}&apos;);</code></pre> \n<p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">保存了JSON的原始文本到数据库，包括空白行和键顺序及重新的键，我们来查看下保存的数据：</p> \n<pre STYLE=\"width:auto;margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-size:0.875em;line-height:1.71429em;background-color:rgb(243, 242, 238);font-family:Inconsolata;\"><code STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-size:1.15em;line-height:1.71429em;font-family:Inconsolata;\">&gt;SELECT&nbsp;*&nbsp;FROM&nbsp;justjson;\n&nbsp;id&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doc\n----+---------------------------------\n&nbsp;&nbsp;1&nbsp;|&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+\n&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;name&quot;:&quot;fred&quot;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+\n&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;address&quot;:{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+\n&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;line1&quot;:&quot;52&nbsp;The&nbsp;Elms&quot;,&nbsp;+\n&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;line2&quot;:&quot;Elmstreet&quot;,&nbsp;&nbsp;&nbsp;+\n&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;postcode&quot;:&quot;ES1&nbsp;1ES&quot;&nbsp;&nbsp;&nbsp;+\n&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+\n&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n(1&nbsp;row)</code></pre> \n<p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">跟保存之前的文本一模一样，但我们仍可以解析出具体的数据出来，PostgreSQL提供了一套JSON的操作方法进行查找，例如，我们只要查出address信息，如果做？</p> \n<pre STYLE=\"width:auto;margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-size:0.875em;line-height:1.71429em;background-color:rgb(243, 242, 238);font-family:Inconsolata;\"><code STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-size:1.15em;line-height:1.71429em;font-family:Inconsolata;\">select&nbsp;doc-&gt;&gt;&apos;address&apos;&nbsp;FROM&nbsp;justjson;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?column?\n---------------------------------\n&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;line1&quot;:&quot;52&nbsp;The&nbsp;Elms&quot;,&nbsp;+\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;line2&quot;:&quot;Elmstreet&quot;,&nbsp;&nbsp;&nbsp;+\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;postcode&quot;:&quot;ES1&nbsp;1ES&quot;&nbsp;&nbsp;&nbsp;+\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n(1&nbsp;row)</code></pre> \n<p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">doc字段的 -&gt;&gt; 操作符是查询JSON对象的某个字段并返回文本，用数字也可以当作数组的索引，但仍返回文本。跟 -&gt;&gt; 类似的还有 -&gt; 操作符，返回不转文本的内容，可以用它来导航搜索JSON对象，如：</p> \n<pre STYLE=\"width:auto;margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-size:0.875em;line-height:1.71429em;background-color:rgb(243, 242, 238);font-family:Inconsolata;\"><code STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-size:1.15em;line-height:1.71429em;font-family:Inconsolata;\">select&nbsp;doc-&gt;&apos;address&apos;-&gt;&gt;&apos;postcode&apos;&nbsp;FROM&nbsp;justjson;&nbsp;&nbsp;\n&nbsp;?column?\n----------\n&nbsp;ES1&nbsp;1ES\n(1&nbsp;row)</code></pre> \n<p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">还有个更简短的写法来指定搜索路径，用 #&gt;&gt; 操作符，如梦：</p> \n<pre STYLE=\"width:auto;margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-size:0.875em;line-height:1.71429em;background-color:rgb(243, 242, 238);font-family:Inconsolata;\"><code STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-size:1.15em;line-height:1.71429em;font-family:Inconsolata;\">select&nbsp;doc#&gt;&gt;&apos;{address,postcode}&apos;&nbsp;FROM&nbsp;justjson;&nbsp;&nbsp;\n&nbsp;?column?\n----------\n&nbsp;ES1&nbsp;1ES\n(1&nbsp;row)</code></pre> \n<p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">通过保存完整的JSON数据类型可使其跟源数据完全一样并且不会丢失内容，但为保持完全一致也带来了成本，性能的缺失，而且不能索引...所有，尽管可以很方便的维持一致性和保持JSON文档，但仍有很大的提升空间，所以引入了JSONB。</p> \n\n<h4 STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-weight:bold;font-size:20px;margin-top:30px;margin-bottom:1.5em;font-family:&quot;PT Serif&quot;;text-align:left;\">&quot;JSONB有什么不同？&quot;</h4> \n<p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">JSONB可以将整个JSON文档转有层级的KEY/VALUE数据对，所有的空白字符删除了，重复键只保留最后一次，键也没有排序，而是用HASH来保存了，上面的例子中用JSONB的版本的话，看来起类似这样：</p> \n<pre STYLE=\"width:auto;margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-size:0.875em;line-height:1.71429em;background-color:rgb(243, 242, 238);font-family:Inconsolata;\"><code STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-size:1.15em;line-height:1.71429em;font-family:Inconsolata;\">&gt;CREATE&nbsp;TABLE&nbsp;justjsonb&nbsp;(&nbsp;id&nbsp;INTEGER,&nbsp;doc&nbsp;JSONB)\n&gt;INSERT&nbsp;INTO&nbsp;justjsonb&nbsp;VALUES&nbsp;(&nbsp;1,&nbsp;&apos;{\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;name&quot;:&quot;fred&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;address&quot;:{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;line1&quot;:&quot;52&nbsp;The&nbsp;Elms&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;line2&quot;:&quot;Elmstreet&quot;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;postcode&quot;:&quot;ES1&nbsp;1ES&quot;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}&apos;);\n&gt;SELECT&nbsp;*&nbsp;FROM&nbsp;justjsonb;\n&nbsp;id&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doc\n----+----------------------------------------------------------------------------------------------------\n&nbsp;&nbsp;1&nbsp;|&nbsp;{&quot;name&quot;:&nbsp;&quot;fred&quot;,&nbsp;&quot;address&quot;:&nbsp;{&quot;line1&quot;:&nbsp;&quot;52&nbsp;The&nbsp;Elms&quot;,&nbsp;&quot;line2&quot;:&nbsp;&quot;Elmstreet&quot;,&nbsp;&quot;postcode&quot;:&nbsp;&quot;ES1&nbsp;1ES&quot;}}\n(1&nbsp;row)</code></pre> \n<p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">可以看到，所有非文本内容都消失了，替换成JSON文档需要的最少格式，这种压缩方式表示当数据插入时会自动格式化，这样可以减少之后访问数据分析处理的工作量。</p> \n\n<h4 STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-weight:bold;font-size:20px;margin-top:30px;margin-bottom:1.5em;font-family:&quot;PT Serif&quot;;text-align:left;\">&quot;PostgreSQL的这种数据有点像HSTORE&quot;</h4> \n<p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">看到键值对，JSONB还真有点像PostgreSQL的HSTORE扩展，它也可以保存键值对，但它是一个扩展，而，JSONB（以及JSON）是在PostgreSQL内核的，HSTORE只有一级层级，但PostgreSQL可以有嵌套的元素，并且，HSTORE只能存字符串，而JSONB还可以存JSON的所数字类型。</p> \n\n<h4 STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-weight:bold;font-size:20px;margin-top:30px;margin-bottom:1.5em;font-family:&quot;PT Serif&quot;;text-align:left;\">&ldquo;那JSONB到底带给我啥好处呢？&rdquo;</h4> \n<p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">索引，到处用上索引，你不能在PostgreSQL对JSON类型创建真正的索引，你可以创建表达式索引（expression indexes），但只限于你想索引的内容，例如：</p> \n<pre STYLE=\"width:auto;margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-size:0.875em;line-height:1.71429em;background-color:rgb(243, 242, 238);font-family:Inconsolata;\"><code STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-size:1.15em;line-height:1.71429em;font-family:Inconsolata;\">create&nbsp;index&nbsp;justjson_postcode&nbsp;on&nbsp;justjson&nbsp;((doc-&gt;&apos;address&apos;-&gt;&gt;&apos;postcode&apos;));</code></pre> \n<p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">只有邮编（postcode）索引了，其它都没有索引。</p> \n<p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">而JSONB，支持GIN索引，一种通用返转索引（<a HREF=\"http://www.postgresql.org/docs/9.4/static/gin-intro.html\" TARGET=\"_blank\" STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;text-decoration:none;color:rgb(6, 85, 136);\">Generalized Inverted Index</a>），PostgreSQL提供了<a HREF=\"http://www.postgresql.org/docs/9.4/static%20/functions-json.html#FUNCTIONS-JSONB-OP-TABLE\" TARGET=\"_blank\" STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;text-decoration:none;color:rgb(6, 85, 136);\">另外一套</a>索引操作符来支持，包括 @&gt; 包括JSON，&lt;@ 最包含，? 测试字符串是否存在，?| 任意字符串是否存在，?&amp; 所有存大的字符串。</p> \n<p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">有两类索引可用，默认叫 json_ops，它支持所有操作符（译者：指普通json操作符）和一个只支持&amp;&gt;操作符的jsonb_path_ops索引（译者：指索引操作符），默认索引给JSON中的每个键值都创建了索引，其实 jsonb_path_ops只创建了一个比默认复杂的更高压缩的hash表索引，但默认索引担任更多操作能力同时增加了空间成本。给表添加一些数据，我们再来看看某个邮编，如果我们创建了一个默认的GIN JSON索引然后查询：</p> \n<pre STYLE=\"width:auto;margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-size:0.875em;line-height:1.71429em;background-color:rgb(243, 242, 238);font-family:Inconsolata;\"><code STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-size:1.15em;line-height:1.71429em;font-family:Inconsolata;\">explain&nbsp;select&nbsp;*&nbsp;from&nbsp;justjsonb&nbsp;where&nbsp;doc&nbsp;@&gt;&nbsp;&apos;{&nbsp;&quot;address&quot;:&nbsp;{&nbsp;&quot;postcode&quot;:&quot;HA36CC&quot;&nbsp;}&nbsp;}&apos;;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QUERY&nbsp;PLAN\n-----------------------------------------------------------------\n&nbsp;Seq&nbsp;Scan&nbsp;on&nbsp;justjsonb&nbsp;&nbsp;(cost=0.00..3171.14&nbsp;rows=100&nbsp;{&quot;address&quot;:&nbsp;{&quot;postcode&quot;:&nbsp;&quot;HA36CC&quot;}}&apos;::jsonb)\n(2&nbsp;rows)</code></pre> \n<p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">可以看出来是顺序扫瞄表，如果我们加个默认的JSON GIN索引后再看看有什么不同？</p> \n<pre STYLE=\"width:auto;margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-size:0.875em;line-height:1.71429em;background-color:rgb(243, 242, 238);font-family:Inconsolata;\"><code STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-size:1.15em;line-height:1.71429em;font-family:Inconsolata;\">&gt;&nbsp;create&nbsp;index&nbsp;justjsonb_gin&nbsp;on&nbsp;justjsonb&nbsp;using&nbsp;gin&nbsp;(doc);\n&gt;&nbsp;explain&nbsp;select&nbsp;*&nbsp;from&nbsp;justjsonb&nbsp;where&nbsp;doc&nbsp;@&gt;&nbsp;&apos;{&nbsp;&quot;address&quot;:&nbsp;{&nbsp;&quot;postcode&quot;:&quot;HA36CC&quot;&nbsp;}&nbsp;}&apos;;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QUERY&nbsp;PLAN\n-------------------------------------------------------------------------------\n&nbsp;Bitmap&nbsp;Heap&nbsp;Scan&nbsp;on&nbsp;justjsonb&nbsp;&nbsp;(cost=40.78..367.62&nbsp;rows=100&nbsp;{&quot;address&quot;:&nbsp;{&quot;postcode&quot;:&nbsp;&quot;HA36CC&quot;}}&apos;::jsonb)\n&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;Bitmap&nbsp;Index&nbsp;Scan&nbsp;on&nbsp;justjsonb_gin&nbsp;&nbsp;(cost=0.00..40.75&nbsp;rows=100&nbsp;{&quot;address&quot;:&nbsp;{&quot;postcode&quot;:&nbsp;&quot;HA36CC&quot;}}&apos;::jsonb)\n(4&nbsp;rows)</code></pre> \n<p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">搜索性能提升很大，但隐藏了空间的耗费，例中是41%的数据大小，让我们删除索引重复执行jsonb_path_ops GIN索引。</p> \n<pre STYLE=\"width:auto;margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-size:0.875em;line-height:1.71429em;background-color:rgb(243, 242, 238);font-family:Inconsolata;\"><code STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-size:1.15em;line-height:1.71429em;font-family:Inconsolata;\">&gt;&nbsp;create&nbsp;index&nbsp;justjsonb_gin&nbsp;on&nbsp;justjsonb&nbsp;using&nbsp;gin&nbsp;(doc&nbsp;jsonb_path_ops);\n&gt;&nbsp;explain&nbsp;select&nbsp;*&nbsp;from&nbsp;justjsonb&nbsp;where&nbsp;doc&nbsp;@&gt;&nbsp;&apos;{&nbsp;&quot;address&quot;:&nbsp;{&nbsp;&quot;postcode&quot;:&quot;HA36CC&quot;&nbsp;}&nbsp;}&apos;;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QUERY&nbsp;PLAN\n-------------------------------------------------------------------------------\n&nbsp;Bitmap&nbsp;Heap&nbsp;Scan&nbsp;on&nbsp;justjsonb&nbsp;&nbsp;(cost=16.78..343.62&nbsp;rows=100&nbsp;{&quot;address&quot;:&nbsp;{&quot;postcode&quot;:&nbsp;&quot;HA36CC&quot;}}&apos;::jsonb)\n&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;Bitmap&nbsp;Index&nbsp;Scan&nbsp;on&nbsp;justjsonb_gin&nbsp;&nbsp;(cost=0.00..16.75&nbsp;rows=100&nbsp;{&quot;address&quot;:&nbsp;{&quot;postcode&quot;:&nbsp;&quot;HA36CC&quot;}}&apos;::jsonb)\n(4&nbsp;rows)</code></pre> \n<p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">总成本低了点，索引体积小了很多，这是典型的创建索引速度和空间平衡的方法，但比顺序扫瞄性能高很多。</p> \n<h4 STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;font-weight:bold;font-size:20px;margin-top:30px;margin-bottom:1.5em;font-family:&quot;PT Serif&quot;;text-align:left;\">&ldquo;我应该用它作为我的JSON数据库吗？&rdquo;</h4> \n<p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">如果你经常更新你的JSON文档，回答是否定的，PostgreSQL最擅长的是存储和攻取JSON文档及他们的字段，但尽管如此你可以取出单个字段，你也不能更新单个字段；实际上你可以，将整个JSON解析出来，添加新的字段再写回，让JSON分析器处理重复，但你很明显不想依赖这个。</p> \n<p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">如果你的主要数据用关系数据库用得很好，JSON数据只是一群补充（静态数据），那么用PostgreSQL就可以了，而且用JSONB表示和索引能力将更高效。另外，如果你的数据模型是可变内容的集合，那么你可能会寻找一样主流工业级的json文档数据库如<a HREF=\"https://www.mongodb.org/\" TARGET=\"_blank\" STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;text-decoration:none;color:rgb(6, 85, 136);\">MongoDB</a>或<a HREF=\"http://rethinkdb.com/\" TARGET=\"_blank\" STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;text-decoration:none;color:rgb(6, 85, 136);\">RethinkDB</a>。</p> \n<p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">参考</p> \n<p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">PostgreSQL vs MongoDB&nbsp;<a HREF=\"http://my.oschina.net/Suregogo/blog/358277\" TARGET=\"_blank\" STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;text-decoration:none;color:rgb(6, 85, 136);\">http://my.oschina.net/Suregogo/blog/358277</a> </p> \n<p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">Query JSON in PostgreSQL <a HREF=\"http://schinckel.net/2014/05/25/querying-json-in-postgres/\" TARGET=\"_blank\" STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;text-decoration:none;color:rgb(6, 85, 136);\">http://schinckel.net/2014/05/25/querying-json-in-postgres/</a></p> \n<p STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">原文：&nbsp;<a HREF=\"https://www.compose.io/articles/is-postgresql-your-next-json-database/\" TARGET=\"_blank\" STYLE=\"margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;text-decoration:none;color:rgb(6, 85, 136);\">https://www.compose.io/articles/is-postgresql-your-next-json-database/</a></p> \n<p STYLE=\"margin-bottom:0px;margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;\">&lt;译：朱淦 350050183@qq.com 2015.8.9&gt;</p>\n                                                    \n                                            </div>\n                    \n                    <p STYLE=\"margin-bottom:0px;margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;\">\n                                                    本文转载自：https://www.compose.io/articles/is-postgresql-your-next-json-database/\n                                            </p>\n                </div></div></div><div STYLE=\"position:absolute;top:-1000px;left:-1000px;margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;margin-bottom:1.5em;\">Measure</div><div STYLE=\"margin-bottom:0px;position:absolute;top:-1000px;left:-1000px;line-height:1;margin:0px;padding:0px;border:0px;font:inherit;vertical-align:baseline;\">Measure</div></div></div></div></div></div></div></div>\n</div>\n</en-note>      ",
      "content_path": null,
      "diff_base_variant_id": null,
      "metadata": {
        "checksum": "453e67095b024c6de2d0b8229f757809ea475ba577785251b259f3a9a6439f0b",
        "path": "backups/2023年6月/IT技术/PostgreSQL操作JSON数据.html"
      }
    },
    {
      "id": "a3b07afb-c790-4946-9515-171d82e44cf0",
      "note_id": "cfd24717-19b5-4642-9e3e-365c242ac67c",
      "variant_type": "clean_text",
      "version": 1,
      "created_by": "evernote_ingest:v0",
      "created_at": "2025-11-10T15:43:31.155126Z",
      "content": "---\ntitle: PostgreSQL操作JSON数据\nupdated: 2019-02-16 10:02:32Z\ncreated: 2019-02-16 10:02:32Z\nsource: https://my.oschina.net/swingcoder/blog/489769\n---\n\n PostgreSQL是不是你的下一个JSON数据库？ 转\n\n                            发布于 2015/08/09 15:48\n\n字数 1647\n\n阅读 464\n\n收藏 11\n\n点赞 0\n\n 评论 0\n\n根据\nBetteridge\n定律（任何头条的设问句可以用一个词来回答：不是），除非你的JSON数据很少修改，并且查询很多。\n\n最新版的PostgreSQL添加更多对JSON的支持，我们曾经问过PostgreSQL是否可以替换MongoDB作为JSON数据库，答案显而易见，但我们更希望的是，啊哈，这个问题由读者来问了。\n\n“PostgreSQL不是已经有一些json的支持了吗？”\n\n是的，在PostgreSQL 9.4之前的版本也有JSON 数据类型了，你可以这样：\n\nCREATE TABLE justjson ( id INTEGER, doc JSON)\n>INSERT INTO justjson VALUES ( 1, '{\n    \"name\":\"fred\",\n    \"address\":{\n        \"line1\":\"52 The Elms\",\n        \"line2\":\"Elmstreet\",\n        \"postcode\":\"ES1 1ES\"\n        }\n    }');\n\n保存了JSON的原始文本到数据库，包括空白行和键顺序及重新的键，我们来查看下保存的数据：\n\n>SELECT * FROM justjson;\n id |               doc\n----+---------------------------------\n  1 | {                              +\n    |     \"name\":\"fred\",             +\n    |     \"address\":{                +\n    |         \"line1\":\"52 The Elms\", +\n    |         \"line2\":\"Elmstreet\",   +\n    |         \"postcode\":\"ES1 1ES\"   +\n    |         }                      +\n    |     }\n(1 row)\n\n跟保存之前的文本一模一样，但我们仍可以解析出具体的数据出来，PostgreSQL提供了一套JSON的操作方法进行查找，例如，我们只要查出address信息，如果做？\n\nselect doc->>'address' FROM justjson;  \n            ?column?\n---------------------------------\n {                              +\n         \"line1\":\"52 The Elms\", +\n         \"line2\":\"Elmstreet\",   +\n         \"postcode\":\"ES1 1ES\"   +\n         }\n(1 row)\n\ndoc字段的 ->> 操作符是查询JSON对象的某个字段并返回文本，用数字也可以当作数组的索引，但仍返回文本。跟 ->> 类似的还有 -> 操作符，返回不转文本的内容，可以用它来导航搜索JSON对象，如：\n\nselect doc->'address'->>'postcode' FROM justjson;  \n ?column?\n----------\n ES1 1ES\n(1 row)\n\n还有个更简短的写法来指定搜索路径，用 #>> 操作符，如梦：\n\nselect doc#>>'{address,postcode}' FROM justjson;  \n ?column?\n----------\n ES1 1ES\n(1 row)\n\n通过保存完整的JSON数据类型可使其跟源数据完全一样并且不会丢失内容，但为保持完全一致也带来了成本，性能的缺失，而且不能索引...所有，尽管可以很方便的维持一致性和保持JSON文档，但仍有很大的提升空间，所以引入了JSONB。\n\n\"JSONB有什么不同？\"\n\nJSONB可以将整个JSON文档转有层级的KEY/VALUE数据对，所有的空白字符删除了，重复键只保留最后一次，键也没有排序，而是用HASH来保存了，上面的例子中用JSONB的版本的话，看来起类似这样：\n\n>CREATE TABLE justjsonb ( id INTEGER, doc JSONB)\n>INSERT INTO justjsonb VALUES ( 1, '{\n    \"name\":\"fred\",\n    \"address\":{\n        \"line1\":\"52 The Elms\",\n        \"line2\":\"Elmstreet\",\n        \"postcode\":\"ES1 1ES\"\n        }\n    }');\n>SELECT * FROM justjsonb;\n id |                                                doc\n----+----------------------------------------------------------------------------------------------------\n  1 | {\"name\": \"fred\", \"address\": {\"line1\": \"52 The Elms\", \"line2\": \"Elmstreet\", \"postcode\": \"ES1 1ES\"}}\n(1 row)\n\n可以看到，所有非文本内容都消失了，替换成JSON文档需要的最少格式，这种压缩方式表示当数据插入时会自动格式化，这样可以减少之后访问数据分析处理的工作量。\n\n\"PostgreSQL的这种数据有点像HSTORE\"\n\n看到键值对，JSONB还真有点像PostgreSQL的HSTORE扩展，它也可以保存键值对，但它是一个扩展，而，JSONB（以及JSON）是在PostgreSQL内核的，HSTORE只有一级层级，但PostgreSQL可以有嵌套的元素，并且，HSTORE只能存字符串，而JSONB还可以存JSON的所数字类型。\n\n“那JSONB到底带给我啥好处呢？”\n\n索引，到处用上索引，你不能在PostgreSQL对JSON类型创建真正的索引，你可以创建表达式索引（expression indexes），但只限于你想索引的内容，例如：\n\ncreate index justjson_postcode on justjson ((doc->'address'->>'postcode'));\n\n只有邮编（postcode）索引了，其它都没有索引。\n\n而JSONB，支持GIN索引，一种通用返转索引（\nGeneralized Inverted Index\n），PostgreSQL提供了\n另外一套\n索引操作符来支持，包括 @> 包括JSON，<@ 最包含，? 测试字符串是否存在，?| 任意字符串是否存在，?& 所有存大的字符串。\n\n有两类索引可用，默认叫 json_ops，它支持所有操作符（译者：指普通json操作符）和一个只支持&>操作符的jsonb_path_ops索引（译者：指索引操作符），默认索引给JSON中的每个键值都创建了索引，其实 jsonb_path_ops只创建了一个比默认复杂的更高压缩的hash表索引，但默认索引担任更多操作能力同时增加了空间成本。给表添加一些数据，我们再来看看某个邮编，如果我们创建了一个默认的GIN JSON索引然后查询：\n\nexplain select * from justjsonb where doc @> '{ \"address\": { \"postcode\":\"HA36CC\" } }';  \n                           QUERY PLAN\n-----------------------------------------------------------------\n Seq Scan on justjsonb  (cost=0.00..3171.14 rows=100 {\"address\": {\"postcode\": \"HA36CC\"}}'::jsonb)\n(2 rows)\n\n可以看出来是顺序扫瞄表，如果我们加个默认的JSON GIN索引后再看看有什么不同？\n\n> create index justjsonb_gin on justjsonb using gin (doc);\n> explain select * from justjsonb where doc @> '{ \"address\": { \"postcode\":\"HA36CC\" } }';\n                                  QUERY PLAN\n-------------------------------------------------------------------------------\n Bitmap Heap Scan on justjsonb  (cost=40.78..367.62 rows=100 {\"address\": {\"postcode\": \"HA36CC\"}}'::jsonb)\n   ->  Bitmap Index Scan on justjsonb_gin  (cost=0.00..40.75 rows=100 {\"address\": {\"postcode\": \"HA36CC\"}}'::jsonb)\n(4 rows)\n\n搜索性能提升很大，但隐藏了空间的耗费，例中是41%的数据大小，让我们删除索引重复执行jsonb_path_ops GIN索引。\n\n> create index justjsonb_gin on justjsonb using gin (doc jsonb_path_ops);\n> explain select * from justjsonb where doc @> '{ \"address\": { \"postcode\":\"HA36CC\" } }';\n                                  QUERY PLAN\n-------------------------------------------------------------------------------\n Bitmap Heap Scan on justjsonb  (cost=16.78..343.62 rows=100 {\"address\": {\"postcode\": \"HA36CC\"}}'::jsonb)\n   ->  Bitmap Index Scan on justjsonb_gin  (cost=0.00..16.75 rows=100 {\"address\": {\"postcode\": \"HA36CC\"}}'::jsonb)\n(4 rows)\n\n总成本低了点，索引体积小了很多，这是典型的创建索引速度和空间平衡的方法，但比顺序扫瞄性能高很多。\n\n“我应该用它作为我的JSON数据库吗？”\n\n如果你经常更新你的JSON文档，回答是否定的，PostgreSQL最擅长的是存储和攻取JSON文档及他们的字段，但尽管如此你可以取出单个字段，你也不能更新单个字段；实际上你可以，将整个JSON解析出来，添加新的字段再写回，让JSON分析器处理重复，但你很明显不想依赖这个。\n\n如果你的主要数据用关系数据库用得很好，JSON数据只是一群补充（静态数据），那么用PostgreSQL就可以了，而且用JSONB表示和索引能力将更高效。另外，如果你的数据模型是可变内容的集合，那么你可能会寻找一样主流工业级的json文档数据库如\nMongoDB\n或\nRethinkDB\n。\n\n参考\n\nPostgreSQL vs MongoDB \nhttp://my.oschina.net/Suregogo/blog/358277\n\nQuery JSON in PostgreSQL\nhttp://schinckel.net/2014/05/25/querying-json-in-postgres/\n\n原文： \nhttps://www.compose.io/articles/is-postgresql-your-next-json-database/\n\n<译：朱淦 350050183@qq.com 2015.8.9>\n\n                                                    本文转载自：https://www.compose.io/articles/is-postgresql-your-next-json-database/\n                                           \nMeasure",
      "content_path": null,
      "diff_base_variant_id": null,
      "metadata": {
        "language": "en",
        "length": 5647,
        "rule_count": 2,
        "applied_rules": [
          {
            "rule_id": "dedupe_lines",
            "description": "Collapse adjacent duplicate lines",
            "note": "collapsed duplicate adjacent lines"
          },
          {
            "rule_id": "whitespace",
            "description": "Normalize whitespace",
            "note": "collapsed whitespace"
          }
        ]
      }
    }
  ],
  "extractions": [
    {
      "id": "37d0da6e-77e4-49aa-b5a5-e0139e19790d",
      "note_id": "cfd24717-19b5-4642-9e3e-365c242ac67c",
      "extractor": "llm_enhance:v0#qwen3:30b",
      "payload": {
        "summary": "（空摘要）",
        "keywords": [
          "待补充",
          "待补充",
          "待补充",
          "待补充",
          "待补充"
        ],
        "action_items": [
          "无"
        ],
        "source": "qwen3:30b",
        "category_path": [
          "商务"
        ],
        "new_category_suggestion": null
      },
      "version": 1,
      "created_at": "2025-11-12T07:25:29.258759Z",
      "created_by": "llm_enhance:v0",
      "quality_score": 0.067
    }
  ],
  "journal": {
    "id": "aaf6f986-545e-44d5-b778-79cb3848ffc3",
    "note_id": "cfd24717-19b5-4642-9e3e-365c242ac67c",
    "stage": "ingest",
    "agent_id": "evernote_ingest:v0",
    "started_at": "2025-11-10T15:43:31.155131Z",
    "finished_at": "2025-11-10T15:43:31.155132Z",
    "status": "success",
    "input_ref": {
      "task_id": "e2a68019-5f8f-4551-9ea7-9841c4585b97",
      "source_path": "backups/2023年6月/IT技术/PostgreSQL操作JSON数据.html",
      "checksum": "453e67095b024c6de2d0b8229f757809ea475ba577785251b259f3a9a6439f0b"
    },
    "output_ref": {
      "ingest_source": "4fa3e73a-ae37-4b3c-900f-e8e6bd0ee190",
      "note": "cfd24717-19b5-4642-9e3e-365c242ac67c",
      "variants": [
        "2120f150-b6a7-489c-9e52-db4af9630db7",
        "a3b07afb-c790-4946-9515-171d82e44cf0"
      ]
    },
    "error_detail": null
  },
  "llm": {
    "status": "success",
    "model": "qwen3:30b",
    "updated_at": "2025-11-12T07:25:29.258500Z",
    "latency_seconds": 52.99087633402087,
    "attempts": 2,
    "summary": {
      "summary": "（空摘要）",
      "keywords": [
        "待补充",
        "待补充",
        "待补充",
        "待补充",
        "待补充"
      ],
      "action_items": [
        "无"
      ],
      "source": "qwen3:30b",
      "category_path": [
        "商务"
      ],
      "new_category_suggestion": null
    },
    "quality": {
      "score": 0.067,
      "metrics": {
        "input_chars": 5647.0,
        "input_lines": 132.0,
        "summary_chars": 5.0,
        "summary_coverage_ratio": 0.001,
        "keyword_hit_rate": 0.0,
        "action_item_count": 1.0,
        "unique_summary_sentences": 1.0,
        "estimated_read_seconds": 338.8
      }
    }
  }
}
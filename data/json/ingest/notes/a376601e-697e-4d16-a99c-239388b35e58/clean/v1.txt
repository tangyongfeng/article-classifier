---
title: Delphi实现电脑端微信图片文件解密 - C++/Delphi - 吾八哥博客
updated: 2019-02-18 08:38:40Z
created: 2019-02-18 08:38:40Z
source: http://www.5bug.wang/post/43.html
---

Delphi实现电脑端微信图片文件解密

电脑端微信收到图片后是存在了“C:\Users\www.5bug.wang\Documents\WeChat Files\微信帐号\Data”目录下的，但文件不能直接使用图片浏览器打开的，因为做了一些加密，之前有个朋友问我这些文件怎么解密，就抽空研究了下。参考了一篇文章：http://share.iclient.ifeng.com/news/shareNews?forward=1&aid=117431304&from=timeline&isappinstalled=1&forward=1#backhead，文章里提到的是加密值：ox5，其实现在改了，是根据不同的图片格式采用不同的加密值了，今天这里使用Delphi来实现这个图片文件的解密，教你找到被撤回的微信图片或者存储被撤回的图片，哈哈。直接上代码吧！
Pascal
uses
  System.SysUtils, System.Classes, Winapi.Windows, System.Math, System.StrUtils;
// 计算MagicCode以及图片类型
function CalcMagicCode(const AHeadCode: Word; var AMagicCode: Word; var AFileExt: string): Boolean;
const
  C_TypeCodeArr: array of Word = [$4D42, $D8FF, $4947, $5089];
  C_TypeExtArr: array of string = ['.bmp', '.jpeg', '.gif', '.png'];
var
  I: Integer;
  LByte1, LByte2: Byte;
  LMagicCode: Word;
begin
  Result := False;
  LByte1 := Byte(AHeadCode);
  LByte2 := HiByte(AHeadCode);
  for I := Low(C_TypeCodeArr) to High(C_TypeCodeArr) do
  begin
    LMagicCode := Byte(C_TypeCodeArr[I]) xor LByte1;
    if LMagicCode = (HiByte(C_TypeCodeArr[I]) xor LByte2) then
    begin
      AMagicCode := LMagicCode;
      AFileExt := C_TypeExtArr[I];
      Result := True;
    end;
procedure MakeFileList(const Path, FileExt: string; AFileList: TStrings);
var
  sch: TSearchRec;
  tmpPath: string;
begin
  if RightStr(Trim(Path), 1) <> '\' then
    tmpPath := Trim(Path) + '\'
  else
    tmpPath := Trim(Path);
  if not DirectoryExists(tmpPath) then
    Exit;
  if FindFirst(tmpPath + '*', faAnyFile, sch) = 0 then
  begin
    repeat
      if ((sch.Name = '.') or (sch.Name = '..')) then
        Continue;
      if (UpperCase(ExtractFileExt(tmpPath + sch.Name)) = UpperCase(FileExt)) or (FileExt = '.*') then
        AFileList.Add(tmpPath + sch.Name);
    until FindNext(sch) <> 0;
    System.SysUtils.FindClose(sch);
  end;
procedure DecryptWXImgFile(const ASrcFile, ASavePath: string);
var
  LSrcStream: TMemoryStream;
  LDesStream: TFileStream;
  LFilesize, LPos: Integer;
  LBuffer: Word;
  LSrcByte, LDesByte: Byte;
  LMagicCode: Word;
  LFileExt, LFileName: string;
begin
  LSrcStream := TMemoryStream.Create;
  try
    LSrcStream.LoadFromFile(ASrcFile);
    LSrcStream.Position := 0;
    LSrcStream.ReadBuffer(LBuffer, 2);
    if CalcMagicCode(LBuffer, LMagicCode, LFileExt) then
    begin
      LFileName := ASavePath + ChangeFileExt(ExtractFileName(ASrcFile), LFileExt);
      LDesStream := TFileStream.Create(LFileName, fmCreate);
      try
        LPos := 0;
        LFilesize := LSrcStream.Size;
        // 此处效率低，需要优化
        while LPos < LFilesize do
        begin
          LSrcStream.Position := LPos;
          LSrcStream.ReadBuffer(LSrcByte, 1);
          LDesByte := LSrcByte xor LMagicCode;
          LDesStream.WriteBuffer(LDesByte, 1);
          Inc(LPos);
        end;
      finally
        LDesStream.Free;
      end;
  finally
    LSrcStream.Free;
  end;
调用方法：
Pascal
DecryptWXImgFile(‘C:\Users\5bug.wang\Documents\WeChat Files\Wubug5\Data\1383774871197177544.dat’, ‘C:\Users\5bug.wang\Desktop\test\’);
以上代码里有一处自行优化吧，否则效率非常低下！只要监控这个存储目录，就可以实现找到被撤回的微信图片或者存储被撤回的图片了，还可以实现一些小工具了，比如微信防撤回图片存储器，微信图片整理工具等了。

Measure
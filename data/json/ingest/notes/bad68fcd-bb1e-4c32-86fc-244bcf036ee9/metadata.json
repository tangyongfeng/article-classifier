{
  "ingest_source": {
    "id": "e714f17d-5568-44c9-babd-a4d433b38dce",
    "source_type": "evernote_html",
    "source_path": "backups/2023年6月/IT技术/另类挂钩-RING3数据包监视（Delphi版）.html",
    "collected_at": "2025-11-10T15:43:32.277140Z",
    "external_id": null,
    "title_hint": null,
    "language_hint": "en",
    "captured_at": null,
    "checksum": "7c0fe846b53eda257052da58dcfae783cdc61b0cb076da2991a286aa60d82957",
    "status": "pending",
    "notes": {
      "batch_id": "phase2-backfill-202306"
    }
  },
  "note": {
    "id": "bad68fcd-bb1e-4c32-86fc-244bcf036ee9",
    "ingest_source_id": "e714f17d-5568-44c9-babd-a4d433b38dce",
    "canonical_title": "另类挂钩-RING3数据包监视（Delphi版）",
    "language": "en",
    "ingested_at": "2025-11-10T15:43:32.277147Z",
    "created_at": null,
    "status": "active",
    "importance": 0,
    "attributes": {
      "source_filename": "另类挂钩-RING3数据包监视（Delphi版）.html"
    }
  },
  "variants": [
    {
      "id": "9c6cbf55-4ba7-4843-8110-15963f6c21c1",
      "note_id": "bad68fcd-bb1e-4c32-86fc-244bcf036ee9",
      "variant_type": "raw_html",
      "version": 1,
      "created_by": "evernote_ingest:v0",
      "created_at": "2025-11-10T15:43:32.277150Z",
      "content": "---\ntitle: 另类挂钩-RING3数据包监视（Delphi版）\nupdated: 2021-02-09 22:22:47Z\ncreated: 2021-02-09 22:22:32Z\nauthor: tangyongfeng@gmail.com\n---\n\n\n<en-note><div>unit&nbsp;uNtDeviceIoControl;</div><div>{</div><div>&nbsp;&nbsp;原理：Hook&nbsp;ntdll!NtDeviceIoControlFile</div><div>&nbsp;&nbsp;&nbsp;&nbsp;拦截&nbsp;AFD_RECV&nbsp;和&nbsp;AFD_SEND&nbsp;对TCP包进行监视，</div><div>&nbsp;&nbsp;&nbsp;&nbsp;通过比较&nbsp;send&nbsp;函数的&nbsp;Buffer&nbsp;是否为&nbsp;GET/POST</div><div>&nbsp;&nbsp;&nbsp;&nbsp;recv&nbsp;函数的&nbsp;Buffer&nbsp;是否为&nbsp;HTTP，来判断HTTP包</div><div><br/></div><div>&nbsp;&nbsp;&nbsp;&nbsp;代码思路相当清晰，又有注释（原来就有），我就不多说了。</div><div>}</div><div>interface</div><div><br/></div><div>uses</div><div>&nbsp;&nbsp;SysUtils,&nbsp;Windows;</div><div><br/></div><div>const</div><div>&nbsp;&nbsp;AFD_RECV&nbsp;=&nbsp;$12017;</div><div>&nbsp;&nbsp;AFD_SEND&nbsp;=&nbsp;$1201f;</div><div><br/></div><div>&nbsp;&nbsp;HTTP_GET:&nbsp;AnsiString&nbsp;=&nbsp;&apos;GET&nbsp;&apos;;</div><div>&nbsp;&nbsp;HTTP_POST:&nbsp;AnsiString&nbsp;=&nbsp;&apos;POST&nbsp;&apos;;</div><div>&nbsp;&nbsp;HTTP_RESPONSE:&nbsp;AnsiString&nbsp;=&nbsp;&apos;HTTP&apos;;</div><div><br/></div><div>type</div><div>&nbsp;&nbsp;NTSTATUS&nbsp;=&nbsp;DWORD;</div><div>&nbsp;&nbsp;PVOID&nbsp;=&nbsp;Pointer;</div><div><br/></div><div>&nbsp;&nbsp;_AFD_WSABUF&nbsp;=&nbsp;record</div><div>&nbsp;&nbsp;&nbsp;&nbsp;len:&nbsp;DWORD;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;buf:&nbsp;PAnsiChar;</div><div>&nbsp;&nbsp;end;</div><div>&nbsp;&nbsp;TAFD_WSABUF&nbsp;=&nbsp;_AFD_WSABUF;</div><div>&nbsp;&nbsp;PAFD_WSABUF&nbsp;=&nbsp;^TAFD_WSABUF;</div><div><br/></div><div>&nbsp;&nbsp;_AFD_INFO&nbsp;=&nbsp;record</div><div>&nbsp;&nbsp;&nbsp;&nbsp;BufferArray:&nbsp;PAFD_WSABUF;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;BufferCount:&nbsp;DWORD;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;AfdFlags:&nbsp;DWORD;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;TdiFlags:&nbsp;DWORD;</div><div>&nbsp;&nbsp;end;</div><div>&nbsp;&nbsp;TAFD_INFO&nbsp;=&nbsp;_AFD_INFO;</div><div>&nbsp;&nbsp;PAFD_INFO&nbsp;=&nbsp;^TAFD_INFO;</div><div><br/></div><div>&nbsp;&nbsp;_IO_STATUS_BLOCK&nbsp;=&nbsp;record</div><div>&nbsp;&nbsp;&nbsp;&nbsp;//union&nbsp;{</div><div>&nbsp;&nbsp;&nbsp;&nbsp;Status:&nbsp;NTSTATUS;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;PVOID&nbsp;Pointer;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;//}</div><div>&nbsp;&nbsp;&nbsp;&nbsp;Information:&nbsp;ULONG_PTR;</div><div>&nbsp;&nbsp;end;</div><div>&nbsp;&nbsp;IO_STATUS_BLOCK&nbsp;=&nbsp;_IO_STATUS_BLOCK;</div><div>&nbsp;&nbsp;PIO_STATUS_BLOCK&nbsp;=&nbsp;^IO_STATUS_BLOCK;</div><div>&nbsp;&nbsp;TIoStatusBlock&nbsp;=&nbsp;IO_STATUS_BLOCK;</div><div>&nbsp;&nbsp;PIoStatusBlock&nbsp;=&nbsp;^TIoStatusBlock;</div><div><br/></div><div>&nbsp;&nbsp;PIO_APC_ROUTINE&nbsp;=&nbsp;procedure(ApcContext:&nbsp;PVOID;&nbsp;IoStatusBlock:&nbsp;PIO_STATUS_BLOCK;&nbsp;Reserved:&nbsp;ULONG);&nbsp;stdcall;</div><div><br/></div><div>&nbsp;&nbsp;PIMAGE_IMPORT_DESCRIPTOR&nbsp;=&nbsp;^_IMAGE_IMPORT_DESCRIPTOR;</div><div>&nbsp;&nbsp;PImageImportDescriptor&nbsp;=&nbsp;PIMAGE_IMPORT_DESCRIPTOR;</div><div>&nbsp;&nbsp;_IMAGE_IMPORT_DESCRIPTOR&nbsp;=&nbsp;packed&nbsp;record</div><div>&nbsp;&nbsp;&nbsp;&nbsp;CharacteristicsOrOriginalFirstThunk:&nbsp;DWord;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;TimeDateStamp:&nbsp;DWord;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;ForwarderChain:&nbsp;DWord;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;Name:&nbsp;DWord;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;FirstThunk:&nbsp;DWord;</div><div>&nbsp;&nbsp;end;</div><div><br/></div><div>&nbsp;&nbsp;PIMAGE_THUNK_DATA&nbsp;=&nbsp;^_IMAGE_THUNK_DATA;</div><div>&nbsp;&nbsp;PImageThunkData&nbsp;=&nbsp;PIMAGE_THUNK_DATA;</div><div>&nbsp;&nbsp;_IMAGE_THUNK_DATA&nbsp;=&nbsp;packed&nbsp;record</div><div>&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;Integer&nbsp;of</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;:&nbsp;(ForwarderString:&nbsp;DWord);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;:&nbsp;(Function_:&nbsp;DWord);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;:&nbsp;(Ordinal:&nbsp;DWord);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;:&nbsp;(AddressOfData:&nbsp;DWord);</div><div>&nbsp;&nbsp;end;</div><div><br/></div><div>function&nbsp;NT_SUCCESS(Status:&nbsp;NTSTATUS):&nbsp;BOOL;</div><div>{$EXTERNALSYM&nbsp;NT_SUCCESS}</div><div><br/></div><div>var</div><div>&nbsp;&nbsp;OldNtDeviceIoControl:&nbsp;DWORD;</div><div><br/></div><div>procedure&nbsp;SuperHookDeviceIoControl();</div><div><br/></div><div>implementation</div><div><br/></div><div>function&nbsp;NT_SUCCESS(Status:&nbsp;NTSTATUS):&nbsp;BOOL;</div><div>begin</div><div>&nbsp;&nbsp;//Result&nbsp;:=&nbsp;Status&nbsp;&gt;=&nbsp;0;</div><div>&nbsp;&nbsp;Result&nbsp;:=&nbsp;Status&nbsp;&lt;&nbsp;$80000000;</div><div>end;</div><div><br/></div><div>//////////////////////////////////////////////////////////////////////////</div><div>///</div><div>///&nbsp;LookupSendPacket</div><div>///&nbsp;检查Send包</div><div>///&nbsp;目前实现了过滤HTTP请求（GET&nbsp;AND&nbsp;POST）</div><div>///</div><div>//////////////////////////////////////////////////////////////////////////</div><div>function&nbsp;LookupSendPacket(Buffer:&nbsp;Pointer;&nbsp;Len:&nbsp;DWORD):&nbsp;Boolean;</div><div>begin</div><div>&nbsp;&nbsp;Result&nbsp;:=&nbsp;False;</div><div>&nbsp;&nbsp;//&nbsp;过滤长度太小的包</div><div>&nbsp;&nbsp;if&nbsp;(Len&nbsp;&lt;&nbsp;10)&nbsp;then&nbsp;Exit;</div><div>&nbsp;&nbsp;//&nbsp;检查是不是GET或POST</div><div>&nbsp;&nbsp;if&nbsp;(&nbsp;CompareMem(Buffer,&nbsp;@HTTP_GET[1],&nbsp;4)</div><div>&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;CompareMem(Buffer,&nbsp;@HTTP_POST[1],&nbsp;4)&nbsp;)&nbsp;then</div><div>&nbsp;&nbsp;begin</div><div>&nbsp;&nbsp;&nbsp;&nbsp;Result&nbsp;:=&nbsp;True;</div><div>&nbsp;&nbsp;end;</div><div>end;</div><div><br/></div><div>//////////////////////////////////////////////////////////////////////////</div><div>///</div><div>///&nbsp;LookupRecvPacket</div><div>///</div><div>///&nbsp;检查Recv包</div><div>///&nbsp;在这里可以实现Recv包查字典功能</div><div>///&nbsp;目前实现了过滤HTTP返回数据包的功能</div><div>///</div><div>///</div><div>///////////////////////////////////////////////////////////////////////////</div><div>function&nbsp;LookupRecvPacket(Buffer:&nbsp;Pointer;&nbsp;Len:&nbsp;DWORD):&nbsp;Boolean;</div><div>begin</div><div>&nbsp;&nbsp;Result&nbsp;:=&nbsp;False;</div><div>&nbsp;&nbsp;if&nbsp;(Len&nbsp;&lt;&nbsp;10)&nbsp;then&nbsp;Exit;</div><div><br/></div><div>&nbsp;&nbsp;if&nbsp;(&nbsp;CompareMem(Buffer,&nbsp;@HTTP_RESPONSE[1],&nbsp;4)&nbsp;)&nbsp;then</div><div>&nbsp;&nbsp;begin</div><div>&nbsp;&nbsp;&nbsp;&nbsp;Result&nbsp;:=&nbsp;True;</div><div>&nbsp;&nbsp;end;</div><div>end;</div><div><br/></div><div>{&nbsp;HOOK&nbsp;函数&nbsp;}</div><div><br/></div><div>//////////////////////////////////////////////////////////////////////////</div><div>///</div><div>///&nbsp;NtDeviceIoControlFile的HOOK函数</div><div>///&nbsp;ws2_32.dll的send&nbsp;,&nbsp;recv最终会调用到mswsock.dll内的数据发送函数</div><div>///&nbsp;mswsock.dll会调用NtDeviceIoControl向TDI&nbsp;Client驱动发送Send&nbsp;Recv指令</div><div>///&nbsp;我们在这里做拦截，可以过滤所有的TCP&nbsp;收发包（UDP之类亦可，不过要更改指令）</div><div>///</div><div>//////////////////////////////////////////////////////////////////////////</div><div>///&nbsp;Compatibility:&nbsp;NT3,&nbsp;NT4,&nbsp;W2K,&nbsp;WXP,&nbsp;2K3</div><div>function&nbsp;NewNtDeviceIoControlFile(</div><div>&nbsp;&nbsp;&nbsp;&nbsp;FileHandle&nbsp;:&nbsp;THANDLE;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;Event&nbsp;:&nbsp;THANDLE;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;ApcRoutine&nbsp;:&nbsp;PIO_APC_ROUTINE;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;ApcContext&nbsp;:&nbsp;PVOID;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;IoStatusBlock&nbsp;:&nbsp;PIO_STATUS_BLOCK;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;IoControlCode&nbsp;:&nbsp;ULONG;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;InputBuffer&nbsp;:&nbsp;PVOID;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;InputBufferLength&nbsp;:&nbsp;ULONG;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;OutputBuffer&nbsp;:&nbsp;PVOID;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;OutputBufferLength&nbsp;:&nbsp;ULONG</div><div>&nbsp;&nbsp;):&nbsp;NTSTATUS;&nbsp;stdcall;</div><div>var</div><div>&nbsp;&nbsp;AfdInfo:&nbsp;PAFD_INFO;</div><div>&nbsp;&nbsp;Buffer:&nbsp;PAnsiChar;</div><div>&nbsp;&nbsp;Len:&nbsp;DWORD;</div><div>begin</div><div>&nbsp;&nbsp;//&nbsp;先调用原始函数</div><div>&nbsp;&nbsp;asm</div><div>&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;OutputBufferLength</div><div>&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;OutputBuffer</div><div>&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;InputBufferLength</div><div>&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;InputBuffer</div><div>&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;IoControlCode</div><div>&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;IoStatusBlock</div><div>&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;ApcContext</div><div>&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;ApcRoutine</div><div>&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;Event</div><div>&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;FileHandle</div><div>&nbsp;&nbsp;&nbsp;&nbsp;call&nbsp;&nbsp;OldNtDeviceIoControl</div><div>&nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;Result,&nbsp;eax</div><div>&nbsp;&nbsp;end;</div><div><br/></div><div>&nbsp;&nbsp;//&nbsp;如果原始函数失败了（例如RECV无数据）</div><div>&nbsp;&nbsp;if&nbsp;(Not&nbsp;NT_SUCCESS(Result))&nbsp;then</div><div>&nbsp;&nbsp;begin</div><div>&nbsp;&nbsp;&nbsp;&nbsp;Exit;</div><div>&nbsp;&nbsp;end;</div><div><br/></div><div>&nbsp;&nbsp;//&nbsp;检查是否为TCP收发指令</div><div>&nbsp;&nbsp;if&nbsp;(IoControlCode&nbsp;&lt;&gt;&nbsp;AFD_SEND)</div><div>&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;(IoControlCode&nbsp;&lt;&gt;&nbsp;AFD_RECV)&nbsp;then</div><div>&nbsp;&nbsp;begin</div><div>&nbsp;&nbsp;&nbsp;&nbsp;Exit;</div><div>&nbsp;&nbsp;end;</div><div><br/></div><div>&nbsp;&nbsp;//&nbsp;访问AFD&nbsp;INFO结构，获得SEND或RECV的BUFFER信息</div><div>&nbsp;&nbsp;//&nbsp;这里可能是有问题的BUFFER，因此我们要加TRY&nbsp;EXCEPT</div><div>&nbsp;&nbsp;try</div><div>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;从&nbsp;InputBuffer&nbsp;得到&nbsp;Buffer&nbsp;和&nbsp;Len</div><div>&nbsp;&nbsp;&nbsp;&nbsp;AfdInfo&nbsp;:=&nbsp;PAFD_INFO(InputBuffer);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;Buffer&nbsp;:=&nbsp;AfdInfo.BufferArray.buf;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;Len&nbsp;:=&nbsp;AfdInfo.BufferArray.len;</div><div><br/></div><div>&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;IoControlCode&nbsp;of</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AFD_SEND:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;LookupSendPacket(Buffer,&nbsp;Len)&nbsp;)&nbsp;then</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;输出包内容</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutputDebugString(PChar(Format(&apos;[HTTP&nbsp;Send]&nbsp;Length&nbsp;=&nbsp;%d&apos;,&nbsp;[Len])));</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutputDebugString(PChar(Format(&apos;%s&apos;,&nbsp;[StrPas(Buffer)])));</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AFD_RECV:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;LookupRecvPacket(Buffer,&nbsp;Len)&nbsp;)&nbsp;then</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;输出包内容</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutputDebugString(PChar(Format(&apos;[HTTP&nbsp;Recv]&nbsp;Length&nbsp;=&nbsp;%d&apos;,&nbsp;[Len])));</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutputDebugString(PChar(Format(&apos;%s&apos;,&nbsp;[StrPas(Buffer)])));</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;end;</div><div>&nbsp;&nbsp;except</div><div>&nbsp;&nbsp;end;</div><div>end;</div><div><br/></div><div>//////////////////////////////////////////////////////////////////////////</div><div>///</div><div>///&nbsp;&nbsp;Hook&nbsp;mswsock.dll导出表的Ntdll!NtDeviceIoControlFile</div><div>///&nbsp;&nbsp;并过滤其对TDI&nbsp;Cilent的请求来过滤封包</div><div>///&nbsp;&nbsp;稳定，隐蔽，RING3下最底层的包过滤~</div><div>///</div><div>//////////////////////////////////////////////////////////////////////////</div><div>procedure&nbsp;SuperHookDeviceIoControl();</div><div>var</div><div>&nbsp;&nbsp;hMod:&nbsp;HMODULE;</div><div>&nbsp;&nbsp;pDosHeader:&nbsp;PImageDosHeader;</div><div>&nbsp;&nbsp;pNtHeaders:&nbsp;PImageNtHeaders;</div><div>&nbsp;&nbsp;ImportDescriptor:&nbsp;PImageImportDescriptor;</div><div>&nbsp;&nbsp;ThunkData:&nbsp;PImageThunkData;</div><div>&nbsp;&nbsp;dll_name,&nbsp;func_name:&nbsp;PAnsiChar;</div><div>&nbsp;&nbsp;iNum:&nbsp;Integer;</div><div>&nbsp;&nbsp;lpAddr:&nbsp;Pointer;</div><div>&nbsp;&nbsp;myaddr,&nbsp;btw:&nbsp;DWORD;</div><div>begin</div><div>&nbsp;&nbsp;//得到ws2_32.dll的模块基址</div><div>&nbsp;&nbsp;hMod&nbsp;:=&nbsp;LoadLibrary(&apos;mswsock.dll&apos;);</div><div>&nbsp;&nbsp;if&nbsp;(hMod&nbsp;=&nbsp;0)&nbsp;then</div><div>&nbsp;&nbsp;begin</div><div>&nbsp;&nbsp;&nbsp;&nbsp;OutputDebugString(PChar(Format(&apos;LoadLibrary(%s)失败！&apos;,&nbsp;[&apos;mswsock.dll&apos;])));</div><div>&nbsp;&nbsp;&nbsp;&nbsp;Exit;</div><div>&nbsp;&nbsp;end;</div><div><br/></div><div>&nbsp;&nbsp;//得到DOS头</div><div>&nbsp;&nbsp;pDosHeader&nbsp;:=&nbsp;PImageDosHeader(hMod);</div><div>&nbsp;&nbsp;//如果DOS头无效</div><div>&nbsp;&nbsp;if&nbsp;(&nbsp;pDosHeader^.e_magic&nbsp;&lt;&gt;&nbsp;IMAGE_DOS_SIGNATURE&nbsp;)&nbsp;then</div><div>&nbsp;&nbsp;begin</div><div>&nbsp;&nbsp;&nbsp;&nbsp;Exit;</div><div>&nbsp;&nbsp;end;</div><div><br/></div><div>&nbsp;&nbsp;//得到NT头</div><div>&nbsp;&nbsp;pNtHeaders&nbsp;:=&nbsp;PImageNtHeaders(hMod&nbsp;+&nbsp;DWORD(pDosHeader^._lfanew));</div><div>&nbsp;&nbsp;//如果NT头无效</div><div>&nbsp;&nbsp;if&nbsp;(&nbsp;pNtHeaders^.Signature&nbsp;&lt;&gt;&nbsp;IMAGE_NT_SIGNATURE&nbsp;)&nbsp;then</div><div>&nbsp;&nbsp;begin</div><div>&nbsp;&nbsp;&nbsp;&nbsp;Exit;</div><div>&nbsp;&nbsp;end;</div><div><br/></div><div>&nbsp;&nbsp;//检查输入表数据目录是否存在</div><div>&nbsp;&nbsp;if&nbsp;(pNtHeaders^.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress&nbsp;=&nbsp;0)</div><div>&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;(pNtHeaders^.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size&nbsp;=&nbsp;0)&nbsp;then</div><div>&nbsp;&nbsp;begin</div><div>&nbsp;&nbsp;&nbsp;&nbsp;Exit;</div><div>&nbsp;&nbsp;end;</div><div><br/></div><div>&nbsp;&nbsp;//OutputDebugString(PChar(Format(&apos;[HOOK]&nbsp;lock&nbsp;mswsock.dll,&nbsp;waiting&apos;,&nbsp;[])));</div><div><br/></div><div>&nbsp;&nbsp;//得到输入表描述指针</div><div>&nbsp;&nbsp;ImportDescriptor&nbsp;:=&nbsp;PImageImportDescriptor(hMod&nbsp;+&nbsp;pNtHeaders^.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</div><div><br/></div><div>&nbsp;&nbsp;//检查每个输入项</div><div>&nbsp;&nbsp;while&nbsp;(ImportDescriptor^.FirstThunk&nbsp;&lt;&gt;&nbsp;0)&nbsp;do</div><div>&nbsp;&nbsp;begin</div><div>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;检查输入表项是否为ntdll.dll</div><div>&nbsp;&nbsp;&nbsp;&nbsp;dll_name&nbsp;:=&nbsp;PAnsiChar(hMod&nbsp;+&nbsp;ImportDescriptor^.Name);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果不是，则跳到下一个处理</div><div>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(StrIComp(dll_name,&nbsp;&apos;ntdll.dll&apos;)&nbsp;&lt;&gt;&nbsp;0)&nbsp;then</div><div>&nbsp;&nbsp;&nbsp;&nbsp;begin</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImportDescriptor&nbsp;:=&nbsp;PImageImportDescriptor(DWORD(ImportDescriptor)&nbsp;+&nbsp;SizeOf(_IMAGE_IMPORT_DESCRIPTOR));</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Continue;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;end;</div><div><br/></div><div>&nbsp;&nbsp;&nbsp;&nbsp;ThunkData&nbsp;:=&nbsp;PImageThunkData(hMod&nbsp;+&nbsp;ImportDescriptor^.CharacteristicsOrOriginalFirstThunk);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;iNum&nbsp;:=&nbsp;1;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(ThunkData^.Function_&nbsp;&lt;&gt;&nbsp;0)&nbsp;do</div><div>&nbsp;&nbsp;&nbsp;&nbsp;begin</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;检查函数是否为NtDeviceIoControlFile</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func_name&nbsp;:=&nbsp;PAnsiChar(hMod&nbsp;+&nbsp;ThunkData^.AddressOfData&nbsp;+&nbsp;2);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//OutputDebugString(PChar(Format(&apos;[HOOK]&nbsp;find&nbsp;API:&nbsp;%s&apos;,&nbsp;[StrPas(func_name)])));</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(StrIComp(func_name&nbsp;,&nbsp;&apos;NtDeviceIoControlFile&apos;)&nbsp;=&nbsp;0)&nbsp;then</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutputDebugString(PChar(Format(&apos;[HOOK]&nbsp;Lock&nbsp;&quot;%s&quot;&nbsp;for&nbsp;HOOK.&apos;,&nbsp;[StrPas(func_name)])));</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果是，那么记录原始函数地址</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;HOOK我们的函数地址</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;序号&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RVA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;偏移&nbsp;&nbsp;Name</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;9A&nbsp;&nbsp;D8E3&nbsp;&nbsp;CCE3&nbsp;&nbsp;NtDeviceIoControlFile</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myaddr&nbsp;:=&nbsp;DWORD(@NewNtDeviceIoControlFile);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lpAddr&nbsp;:=&nbsp;Pointer(hMod&nbsp;+&nbsp;ImportDescriptor^.FirstThunk&nbsp;+&nbsp;DWORD(iNum-1)*4);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OldNtDeviceIoControl&nbsp;:=&nbsp;PDWORD(lpAddr)^;</div><div><br/></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutputDebugString(PChar(Format(&apos;[HOOK]&nbsp;Base=%0.8X,&nbsp;Thunk=%0.8X,&nbsp;ID=%X&apos;,&nbsp;[hMod,&nbsp;ImportDescriptor^.FirstThunk,&nbsp;iNum-1])));</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutputDebugString(PChar(Format(&apos;[HOOK]&nbsp;Orign[0x%0.8X]=0x%0.8X,&nbsp;new&nbsp;Addr=0x%0.8X&apos;,&nbsp;[DWORD(lpAddr),&nbsp;PDWORD(lpAddr)^,&nbsp;myaddr])));</div><div><br/></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WriteProcessMemory(GetCurrentProcess(),&nbsp;lpAddr,&nbsp;@myaddr,&nbsp;4,&nbsp;btw);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exit;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;</div><div><br/></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inc(iNum);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThunkData&nbsp;:=&nbsp;PImageThunkData(DWORD(ThunkData)&nbsp;+&nbsp;SizeOf(_IMAGE_THUNK_DATA));</div><div>&nbsp;&nbsp;&nbsp;&nbsp;end;</div><div><br/></div><div>&nbsp;&nbsp;&nbsp;&nbsp;Inc(ImportDescriptor);</div><div>&nbsp;&nbsp;end;</div><div>end;</div><div><br/></div><div>end.</div></en-note>      ",
      "content_path": null,
      "diff_base_variant_id": null,
      "metadata": {
        "checksum": "7c0fe846b53eda257052da58dcfae783cdc61b0cb076da2991a286aa60d82957",
        "path": "backups/2023年6月/IT技术/另类挂钩-RING3数据包监视（Delphi版）.html"
      }
    },
    {
      "id": "879678f9-057e-4a7a-8b09-95d374a63293",
      "note_id": "bad68fcd-bb1e-4c32-86fc-244bcf036ee9",
      "variant_type": "clean_text",
      "version": 1,
      "created_by": "evernote_ingest:v0",
      "created_at": "2025-11-10T15:43:32.277154Z",
      "content": "---\ntitle: 另类挂钩-RING3数据包监视（Delphi版）\nupdated: 2021-02-09 22:22:47Z\ncreated: 2021-02-09 22:22:32Z\nauthor: tangyongfeng@gmail.com\n---\n\nunit uNtDeviceIoControl;\n{\n  原理：Hook ntdll!NtDeviceIoControlFile\n    拦截 AFD_RECV 和 AFD_SEND 对TCP包进行监视，\n    通过比较 send 函数的 Buffer 是否为 GET/POST\n    recv 函数的 Buffer 是否为 HTTP，来判断HTTP包\n    代码思路相当清晰，又有注释（原来就有），我就不多说了。\n}\ninterface\nuses\n  SysUtils, Windows;\nconst\n  AFD_RECV = $12017;\n  AFD_SEND = $1201f;\n  HTTP_GET: AnsiString = 'GET ';\n  HTTP_POST: AnsiString = 'POST ';\n  HTTP_RESPONSE: AnsiString = 'HTTP';\ntype\n  NTSTATUS = DWORD;\n  PVOID = Pointer;\n  _AFD_WSABUF = record\n    len: DWORD;\n    buf: PAnsiChar;\n  end;\n  TAFD_WSABUF = _AFD_WSABUF;\n  PAFD_WSABUF = ^TAFD_WSABUF;\n  _AFD_INFO = record\n    BufferArray: PAFD_WSABUF;\n    BufferCount: DWORD;\n    AfdFlags: DWORD;\n    TdiFlags: DWORD;\n  end;\n  TAFD_INFO = _AFD_INFO;\n  PAFD_INFO = ^TAFD_INFO;\n  _IO_STATUS_BLOCK = record\n    //union {\n    Status: NTSTATUS;\n    //    PVOID Pointer;\n    //}\n    Information: ULONG_PTR;\n  end;\n  IO_STATUS_BLOCK = _IO_STATUS_BLOCK;\n  PIO_STATUS_BLOCK = ^IO_STATUS_BLOCK;\n  TIoStatusBlock = IO_STATUS_BLOCK;\n  PIoStatusBlock = ^TIoStatusBlock;\n  PIO_APC_ROUTINE = procedure(ApcContext: PVOID; IoStatusBlock: PIO_STATUS_BLOCK; Reserved: ULONG); stdcall;\n  PIMAGE_IMPORT_DESCRIPTOR = ^_IMAGE_IMPORT_DESCRIPTOR;\n  PImageImportDescriptor = PIMAGE_IMPORT_DESCRIPTOR;\n  _IMAGE_IMPORT_DESCRIPTOR = packed record\n    CharacteristicsOrOriginalFirstThunk: DWord;\n    TimeDateStamp: DWord;\n    ForwarderChain: DWord;\n    Name: DWord;\n    FirstThunk: DWord;\n  end;\n  PIMAGE_THUNK_DATA = ^_IMAGE_THUNK_DATA;\n  PImageThunkData = PIMAGE_THUNK_DATA;\n  _IMAGE_THUNK_DATA = packed record\n    case Integer of\n      0 : (ForwarderString: DWord);\n      1 : (Function_: DWord);\n      2 : (Ordinal: DWord);\n      3 : (AddressOfData: DWord);\n  end;\nfunction NT_SUCCESS(Status: NTSTATUS): BOOL;\n{$EXTERNALSYM NT_SUCCESS}\nvar\n  OldNtDeviceIoControl: DWORD;\nprocedure SuperHookDeviceIoControl();\nimplementation\nfunction NT_SUCCESS(Status: NTSTATUS): BOOL;\nbegin\n  //Result := Status >= 0;\n  Result := Status < $80000000;\nend;\n//////////////////////////////////////////////////////////////////////////\n///\n/// LookupSendPacket\n/// 检查Send包\n/// 目前实现了过滤HTTP请求（GET AND POST）\n///\n//////////////////////////////////////////////////////////////////////////\nfunction LookupSendPacket(Buffer: Pointer; Len: DWORD): Boolean;\nbegin\n  Result := False;\n  // 过滤长度太小的包\n  if (Len < 10) then Exit;\n  // 检查是不是GET或POST\n  if ( CompareMem(Buffer, @HTTP_GET[1], 4)\n    or CompareMem(Buffer, @HTTP_POST[1], 4) ) then\n  begin\n    Result := True;\n  end;\n//////////////////////////////////////////////////////////////////////////\n///\n/// LookupRecvPacket\n///\n/// 检查Recv包\n/// 在这里可以实现Recv包查字典功能\n/// 目前实现了过滤HTTP返回数据包的功能\n///\n///////////////////////////////////////////////////////////////////////////\nfunction LookupRecvPacket(Buffer: Pointer; Len: DWORD): Boolean;\nbegin\n  Result := False;\n  if (Len < 10) then Exit;\n  if ( CompareMem(Buffer, @HTTP_RESPONSE[1], 4) ) then\n  begin\n    Result := True;\n  end;\n{ HOOK 函数 }\n//////////////////////////////////////////////////////////////////////////\n///\n/// NtDeviceIoControlFile的HOOK函数\n/// ws2_32.dll的send , recv最终会调用到mswsock.dll内的数据发送函数\n/// mswsock.dll会调用NtDeviceIoControl向TDI Client驱动发送Send Recv指令\n/// 我们在这里做拦截，可以过滤所有的TCP 收发包（UDP之类亦可，不过要更改指令）\n///\n//////////////////////////////////////////////////////////////////////////\n/// Compatibility: NT3, NT4, W2K, WXP, 2K3\nfunction NewNtDeviceIoControlFile(\n    FileHandle : THANDLE;\n    Event : THANDLE;\n    ApcRoutine : PIO_APC_ROUTINE;\n    ApcContext : PVOID;\n    IoStatusBlock : PIO_STATUS_BLOCK;\n    IoControlCode : ULONG;\n    InputBuffer : PVOID;\n    InputBufferLength : ULONG;\n    OutputBuffer : PVOID;\n    OutputBufferLength : ULONG\n  ): NTSTATUS; stdcall;\nvar\n  AfdInfo: PAFD_INFO;\n  Buffer: PAnsiChar;\n  Len: DWORD;\nbegin\n  // 先调用原始函数\n  asm\n    push  OutputBufferLength\n    push  OutputBuffer\n    push  InputBufferLength\n    push  InputBuffer\n    push  IoControlCode\n    push  IoStatusBlock\n    push  ApcContext\n    push  ApcRoutine\n    push  Event\n    push  FileHandle\n    call  OldNtDeviceIoControl\n    mov   Result, eax\n  end;\n  // 如果原始函数失败了（例如RECV无数据）\n  if (Not NT_SUCCESS(Result)) then\n  begin\n    Exit;\n  end;\n  // 检查是否为TCP收发指令\n  if (IoControlCode <> AFD_SEND)\n    and (IoControlCode <> AFD_RECV) then\n  begin\n    Exit;\n  end;\n  // 访问AFD INFO结构，获得SEND或RECV的BUFFER信息\n  // 这里可能是有问题的BUFFER，因此我们要加TRY EXCEPT\n  try\n    // 从 InputBuffer 得到 Buffer 和 Len\n    AfdInfo := PAFD_INFO(InputBuffer);\n    Buffer := AfdInfo.BufferArray.buf;\n    Len := AfdInfo.BufferArray.len;\n    case IoControlCode of\n      AFD_SEND:\n        if ( LookupSendPacket(Buffer, Len) ) then\n        begin\n          // 输出包内容\n          OutputDebugString(PChar(Format('[HTTP Send] Length = %d', [Len])));\n          OutputDebugString(PChar(Format('%s', [StrPas(Buffer)])));\n        end;\n      AFD_RECV:\n        if ( LookupRecvPacket(Buffer, Len) ) then\n        begin\n          // 输出包内容\n          OutputDebugString(PChar(Format('[HTTP Recv] Length = %d', [Len])));\n          OutputDebugString(PChar(Format('%s', [StrPas(Buffer)])));\n        end;\n  except\n  end;\n//////////////////////////////////////////////////////////////////////////\n///\n///  Hook mswsock.dll导出表的Ntdll!NtDeviceIoControlFile\n///  并过滤其对TDI Cilent的请求来过滤封包\n///  稳定，隐蔽，RING3下最底层的包过滤~\n///\n//////////////////////////////////////////////////////////////////////////\nprocedure SuperHookDeviceIoControl();\nvar\n  hMod: HMODULE;\n  pDosHeader: PImageDosHeader;\n  pNtHeaders: PImageNtHeaders;\n  ImportDescriptor: PImageImportDescriptor;\n  ThunkData: PImageThunkData;\n  dll_name, func_name: PAnsiChar;\n  iNum: Integer;\n  lpAddr: Pointer;\n  myaddr, btw: DWORD;\nbegin\n  //得到ws2_32.dll的模块基址\n  hMod := LoadLibrary('mswsock.dll');\n  if (hMod = 0) then\n  begin\n    OutputDebugString(PChar(Format('LoadLibrary(%s)失败！', ['mswsock.dll'])));\n    Exit;\n  end;\n  //得到DOS头\n  pDosHeader := PImageDosHeader(hMod);\n  //如果DOS头无效\n  if ( pDosHeader^.e_magic <> IMAGE_DOS_SIGNATURE ) then\n  begin\n    Exit;\n  end;\n  //得到NT头\n  pNtHeaders := PImageNtHeaders(hMod + DWORD(pDosHeader^._lfanew));\n  //如果NT头无效\n  if ( pNtHeaders^.Signature <> IMAGE_NT_SIGNATURE ) then\n  begin\n    Exit;\n  end;\n  //检查输入表数据目录是否存在\n  if (pNtHeaders^.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = 0)\n    or (pNtHeaders^.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size = 0) then\n  begin\n    Exit;\n  end;\n  //OutputDebugString(PChar(Format('[HOOK] lock mswsock.dll, waiting', [])));\n  //得到输入表描述指针\n  ImportDescriptor := PImageImportDescriptor(hMod + pNtHeaders^.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);\n  //检查每个输入项\n  while (ImportDescriptor^.FirstThunk <> 0) do\n  begin\n    // 检查输入表项是否为ntdll.dll\n    dll_name := PAnsiChar(hMod + ImportDescriptor^.Name);\n    // 如果不是，则跳到下一个处理\n    if (StrIComp(dll_name, 'ntdll.dll') <> 0) then\n    begin\n      ImportDescriptor := PImageImportDescriptor(DWORD(ImportDescriptor) + SizeOf(_IMAGE_IMPORT_DESCRIPTOR));\n      Continue;\n    end;\n    ThunkData := PImageThunkData(hMod + ImportDescriptor^.CharacteristicsOrOriginalFirstThunk);\n    iNum := 1;\n    while (ThunkData^.Function_ <> 0) do\n    begin\n      // 检查函数是否为NtDeviceIoControlFile\n      func_name := PAnsiChar(hMod + ThunkData^.AddressOfData + 2);\n      //OutputDebugString(PChar(Format('[HOOK] find API: %s', [StrPas(func_name)])));\n      if (StrIComp(func_name , 'NtDeviceIoControlFile') = 0) then\n      begin\n        OutputDebugString(PChar(Format('[HOOK] Lock \"%s\" for HOOK.', [StrPas(func_name)])));\n        //\n        // 如果是，那么记录原始函数地址\n        // HOOK我们的函数地址\n        //\n        // 序号     RVA     偏移  Name\n        //   9A  D8E3  CCE3  NtDeviceIoControlFile\n        myaddr := DWORD(@NewNtDeviceIoControlFile);\n        lpAddr := Pointer(hMod + ImportDescriptor^.FirstThunk + DWORD(iNum-1)*4);\n        OldNtDeviceIoControl := PDWORD(lpAddr)^;\n        OutputDebugString(PChar(Format('[HOOK] Base=%0.8X, Thunk=%0.8X, ID=%X', [hMod, ImportDescriptor^.FirstThunk, iNum-1])));\n        OutputDebugString(PChar(Format('[HOOK] Orign[0x%0.8X]=0x%0.8X, new Addr=0x%0.8X', [DWORD(lpAddr), PDWORD(lpAddr)^, myaddr])));\n        WriteProcessMemory(GetCurrentProcess(), lpAddr, @myaddr, 4, btw);\n        Exit;\n      end;\n      Inc(iNum);\n      ThunkData := PImageThunkData(DWORD(ThunkData) + SizeOf(_IMAGE_THUNK_DATA));\n    end;\n    Inc(ImportDescriptor);\n  end;\nend.",
      "content_path": null,
      "diff_base_variant_id": null,
      "metadata": {
        "language": "en",
        "length": 8450,
        "rule_count": 1,
        "applied_rules": [
          {
            "rule_id": "dedupe_lines",
            "description": "Collapse adjacent duplicate lines",
            "note": "collapsed duplicate adjacent lines"
          }
        ]
      }
    }
  ],
  "extractions": [],
  "journal": {
    "id": "a79434e0-78d7-4777-9a44-c957713cfa10",
    "note_id": "bad68fcd-bb1e-4c32-86fc-244bcf036ee9",
    "stage": "ingest",
    "agent_id": "evernote_ingest:v0",
    "started_at": "2025-11-10T15:43:32.277160Z",
    "finished_at": "2025-11-10T15:43:32.277160Z",
    "status": "success",
    "input_ref": {
      "task_id": "f6646c94-b054-4457-840f-c4445cc67391",
      "source_path": "backups/2023年6月/IT技术/另类挂钩-RING3数据包监视（Delphi版）.html",
      "checksum": "7c0fe846b53eda257052da58dcfae783cdc61b0cb076da2991a286aa60d82957"
    },
    "output_ref": {
      "ingest_source": "e714f17d-5568-44c9-babd-a4d433b38dce",
      "note": "bad68fcd-bb1e-4c32-86fc-244bcf036ee9",
      "variants": [
        "9c6cbf55-4ba7-4843-8110-15963f6c21c1",
        "879678f9-057e-4a7a-8b09-95d374a63293"
      ]
    },
    "error_detail": null
  }
}
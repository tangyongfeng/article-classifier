{
  "ingest_source": {
    "id": "fc279a8d-3d91-4aad-8610-de6166a026dc",
    "source_type": "evernote_html",
    "source_path": "backups/2023年6月/IT技术/Java 6 JVM参数选项大全（中文版）.html",
    "collected_at": "2025-11-10T15:43:30.849967Z",
    "external_id": null,
    "title_hint": null,
    "language_hint": "no",
    "captured_at": null,
    "checksum": "6238b66aa3832a2170124e218b64b13f810292a6d46b76842d71f68cd9c2d3f3",
    "status": "pending",
    "notes": {
      "batch_id": "phase2-backfill-202306"
    }
  },
  "note": {
    "id": "7d8781d1-b666-45f8-8d40-d0c3244733e9",
    "ingest_source_id": "fc279a8d-3d91-4aad-8610-de6166a026dc",
    "canonical_title": "Java 6 JVM参数选项大全（中文版）",
    "language": "no",
    "ingested_at": "2025-11-10T15:43:30.849971Z",
    "created_at": null,
    "status": "active",
    "importance": 0,
    "attributes": {
      "source_filename": "Java 6 JVM参数选项大全（中文版）.html"
    }
  },
  "variants": [
    {
      "id": "f4e89cc6-107a-4f89-8bb3-58ec1b02ad2b",
      "note_id": "7d8781d1-b666-45f8-8d40-d0c3244733e9",
      "variant_type": "raw_html",
      "version": 1,
      "created_by": "evernote_ingest:v0",
      "created_at": "2025-11-10T15:43:30.849974Z",
      "content": "---\ntitle: Java 6 JVM参数选项大全（中文版）\nupdated: 2012-06-25 00:46:56Z\ncreated: 2012-06-25 00:46:45Z\nsource: http://www.sunwei.org/archives/189\ntags:\n  - java\n  - jvm\n---\n\n\n\n\n<en-note STYLE=\"word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;\"><div><p>本文是基于最新的SUN官方文档<a HREF=\"http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp\" TARGET=\"_blank\" TITLE=\"Java SE 6 Hotspot VM Options\">Java SE 6 Hotspot VM Options</a> 编写的译文。主要介绍JVM中的非稳态选项及其使用说明。</p><p>为了让读者明白每个选项的含义，作者在原文基础上<strong>补充了大量的资料</strong>。希望这份文档，对正在研究JVM参数的朋友有帮助！</p><p>另外，考虑到本文档是初稿，如有描述错误，敬请指正。</p><p><strong>非稳态</strong><strong>选项使用说明</strong></p><p>-XX:+&lt;option&gt; 启用选项</p><p>-XX:-&lt;option&gt; 不启用选项</p><p>-XX:&lt;option&gt;=&lt;number&gt; 给选项设置一个数字类型值，可跟单位，例如 32k, 1024m, 2g<br/>\n-XX:&lt;option&gt;=&lt;string&gt; 给选项设置一个字符串值，例如-XX:HeapDumpPath=./dump.core</p><p><strong>行为</strong><strong>选项</strong></p><table BORDER=\"1\" CELLPADDING=\"0\" CELLSPACING=\"0\" WIDTH=\"100%\"><tbody><tr><td VALIGN=\"top\"><strong>选项</strong></td><td VALIGN=\"top\" WIDTH=\"10%\"><strong>默认值与限制</strong></td><td VALIGN=\"top\" WIDTH=\"74%\"><strong>描述</strong></td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:-AllowUserSignalHandlers</td><td VALIGN=\"top\" WIDTH=\"10%\">限于Linux和Solaris，默认不启用</td><td VALIGN=\"top\" WIDTH=\"74%\">允许为java进程安装信号处理器。<br/>\nJava信号处理相关知识，详见<a HREF=\"http://kenwublog.com/java-asynchronous-notify-based-on-signal\">http://kenwublog.com/java-asynchronous-notify-based-on-signal</a></td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:-DisableExplicitGC</td><td VALIGN=\"top\" WIDTH=\"10%\">默认不启用</td><td VALIGN=\"top\" WIDTH=\"74%\">禁止在运行期显式地调用 System.gc()。开启该选项后，GC的触发时机将由Garbage Collector全权掌控。<br/>\n注意：你熟悉的代码里没调用System.gc()，不代表你依赖的框架工具没在使用。例如RMI就在多数用户毫不知情的情况下，显示地调用GC来防止自身OOM。\n<p>请仔细权衡禁用带来的影响。</p></td></tr><tr><td WIDTH=\"15%\">-XX:-RelaxAccessControlCheck</td><td VALIGN=\"top\" WIDTH=\"10%\">默认不启用</td><td WIDTH=\"74%\">在Class校验器中，放松对访问控制的检查。作用与reflection里的setAccessible类似。</td></tr><tr><td WIDTH=\"15%\">-XX:-UseConcMarkSweepGC</td><td VALIGN=\"top\" WIDTH=\"10%\">默认不启用</td><td WIDTH=\"74%\">启用CMS低停顿垃圾收集器。资料详见：<a HREF=\"http://kenwublog.com/docs/CMS_GC.pdf\">http://kenwublog.com/docs/CMS_GC.pdf</a></td></tr><tr><td WIDTH=\"15%\">-XX:-UseParallelGC</td><td VALIGN=\"top\" WIDTH=\"10%\">-server时启用其他情况下，默认不启用</td><td WIDTH=\"74%\">策略为新生代使用并行清除，年老代使用单线程Mark-Sweep-Compact的垃圾收集器。</td></tr><tr><td WIDTH=\"15%\">-XX:-UseParallelOldGC</td><td VALIGN=\"top\" WIDTH=\"10%\">默认不启用</td><td WIDTH=\"74%\">策略为老年代和新生代都使用并行清除的垃圾收集器。</td></tr><tr><td WIDTH=\"15%\">-XX:-UseSerialGC</td><td VALIGN=\"top\" WIDTH=\"10%\">-client时启用其他情况下，默认不启用</td><td WIDTH=\"74%\">使用串行垃圾收集器。</td></tr><tr><td WIDTH=\"15%\">-XX:+UseSplitVerifier</td><td VALIGN=\"top\" WIDTH=\"10%\">java5默认不启用java6默认启用</td><td WIDTH=\"74%\">使用新的Class类型校验器 。<br/><strong>新Class类型校验器有什么特点？</strong><br/>\n新Class类型校验器，将老的校验步骤拆分成了两步：<br/>\n1，类型推断。<br/>\n2，类型校验。新类型校验器通过在javac编译时嵌入类型信息到bytecode中，省略了类型推断这一步，从而提升了classloader的性能。Classload顺序（供参考）<br/>\nload -&gt; <strong>verify</strong> -&gt; prepare -&gt; resove -&gt; init<br/><strong>关联选项：</strong><br/>\n-XX:+FailOverToOldVerifier</td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:+FailOverToOldVerifier</td><td VALIGN=\"top\" WIDTH=\"10%\">Java6新引入选项，默认启用</td><td VALIGN=\"top\" WIDTH=\"74%\">如果新的Class校验器检查失败，则使用老的校验器。\n<p><strong>为什么会失败？</strong></p><p>因为JDK6最高向下兼容到JDK1.2，而JDK1.2的class info 与JDK6的info存在较大的差异，所以新校验器可能会出现校验失败的情况。</p><p><strong><br/>\n关联选项：<br/></strong>-XX:+UseSplitVerifier</p></td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:+HandlePromotionFailure</td><td VALIGN=\"top\" WIDTH=\"10%\">java5以前是默认不启用，java6默认启用</td><td VALIGN=\"top\" WIDTH=\"74%\">关闭新生代收集担保。<br/><strong>什么是新生代收集</strong><strong>担保？</strong><br/>\n在一次理想化的minor gc中，Eden和First Survivor中的活跃对象会被复制到Second Survivor。<br/>\n然而，Second Survivor不一定能容纳下所有从E和F区copy过来的活跃对象。为了确保minor gc能够顺利完成，GC需要在年老代中额外保留一块足以容纳所有活跃对象的内存空间。<br/>\n这个预留操作，就被称之为新生代收集担保（New Generation Guarantee）。如果预留操作无法完成时，仍会触发major gc(full gc)。<strong>为什么要关闭新生代收集</strong><strong>担保？</strong><br/>\n因为在年老代中预留的空间大小，是无法精确计算的。 为了确保极端情况的发生，GC参考了最坏情况下的新生代内存占用，即Eden+First Survivor。\n<p>这种策略无疑是在浪费年老代内存，从时序角度看，还会提前触发Full GC。</p><p>为了避免如上情况的发生，JVM允许开发者手动关闭新生代收集担保。</p><p>在开启本选项后，minor gc将不再提供新生代收集担保，而是在出现survior或年老代不够用时，抛出promotion failed异常。</p></td></tr><tr><td WIDTH=\"15%\">-XX:+UseSpinning</td><td VALIGN=\"top\" WIDTH=\"10%\">java1.4.2和1.5需要手动启用, java6默认已启用</td><td WIDTH=\"74%\">启用多线程自旋锁优化。<br/><strong>自旋锁优化原理</strong>大家知道，Java的多线程安全是基于Lock机制实现的，而Lock的性能往往不如人意。<br/>\n原因是，monitorenter与monitorexit这两个控制多线程同步的bytecode原语，是JVM依赖操作系统互斥(mutex)来实现的。<br/>\n互斥是一种会导致线程挂起，并在较短的时间内又必须重新调度回原线程的，较为消耗资源的操作。为了避免进入OS互斥，Java6的开发者们提出了自旋锁优化。自旋锁优化的原理是在线程进入OS互斥前，通过CAS自旋一定的次数来检测锁的释放。\n<p>如果在自旋次数未达到预设值前锁已被释放，则当前线程会立即持有该锁。</p><p>CAS检测锁的原理详见:<a HREF=\"http://kenwublog.com/theory-of-lightweight-locking-upon-cas\">http://kenwublog.com/theory-of-lightweight-locking-upon-cas</a><br/><strong>关联选项：</strong><br/>\n-XX:PreBlockSpin=10</p></td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:PreBlockSpin=10</td><td VALIGN=\"top\" WIDTH=\"10%\">-XX:+UseSpinning 必须先启用，对于java6来说已经默认启用了，这里默认自旋10次</td><td VALIGN=\"top\" WIDTH=\"74%\">控制多线程自旋锁优化的自旋次数。(什么是自旋锁优化？见 -XX:+UseSpinning 处的描述)<br/><strong>关联选项：</strong><br/>\n-XX:+UseSpinning</td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:+ScavengeBeforeFullGC</td><td VALIGN=\"top\" WIDTH=\"10%\">默认启用</td><td VALIGN=\"top\" WIDTH=\"74%\">在Full GC前触发一次Minor GC。</td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:+UseGCOverheadLimit</td><td VALIGN=\"top\" WIDTH=\"10%\">默认启用</td><td VALIGN=\"top\" WIDTH=\"74%\">限制GC的运行时间。如果GC耗时过长，就抛OOM。</td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:+UseTLAB</td><td VALIGN=\"top\" WIDTH=\"10%\">1.4.2以前和使用-client选项时，默认不启用，其余版本默认启用</td><td VALIGN=\"top\" WIDTH=\"74%\">启用线程本地缓存区（Thread Local）。</td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:+UseThreadPriorities</td><td VALIGN=\"top\" WIDTH=\"10%\">默认启用</td><td VALIGN=\"top\" WIDTH=\"74%\">使用本地线程的优先级。</td></tr><tr><td WIDTH=\"15%\">-XX:+UseAltSigs</td><td VALIGN=\"top\" WIDTH=\"10%\">限于Solaris，默认启用</td><td WIDTH=\"74%\">为了防止与其他发送信号的应用程序冲突，允许使用候补信号替代 SIGUSR1和SIGUSR2。</td></tr><tr><td WIDTH=\"15%\">-XX:+UseBoundThreads</td><td VALIGN=\"top\" WIDTH=\"10%\">限于Solaris, 默认启用</td><td WIDTH=\"74%\">绑定所有的用户线程到内核线程。<br/>\n减少线程进入饥饿状态（得不到任何cpu time）的次数。</td></tr><tr><td WIDTH=\"15%\">-XX:+UseLWPSynchronization</td><td VALIGN=\"top\" WIDTH=\"10%\">限于solaris，默认启用</td><td WIDTH=\"74%\">使用轻量级进程（内核线程）替换线程同步。</td></tr><tr><td WIDTH=\"15%\">-XX:+MaxFDLimit</td><td VALIGN=\"top\" WIDTH=\"10%\">限于Solaris，默认启用</td><td WIDTH=\"74%\">设置java进程可用文件描述符为操作系统允许的最大值。</td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:+UseVMInterruptibleIO</td><td VALIGN=\"top\" WIDTH=\"10%\">限于solaris，默认启用</td><td VALIGN=\"top\" WIDTH=\"74%\">在solaris中，允许运行时中断线程 。</td></tr></tbody></table><hr SIZE=\"2\"/><p><strong>性能选项</strong></p><table BORDER=\"1\" CELLPADDING=\"0\" CELLSPACING=\"0\" WIDTH=\"100%\"><tbody><tr><td VALIGN=\"top\" WIDTH=\"16%\"><strong>选项与默认值</strong></td><td VALIGN=\"top\" WIDTH=\"10%\"><strong>默认值与限制</strong></td><td VALIGN=\"top\" WIDTH=\"72%\"><strong>描述</strong></td></tr><tr><td VALIGN=\"top\" WIDTH=\"16%\">-XX:+AggressiveOpts</td><td VALIGN=\"top\" WIDTH=\"10%\">JDK 5 update 6后引入，但需要手动启用。JDK6默认启用。</td><td VALIGN=\"top\" WIDTH=\"72%\">启用JVM开发团队最新的调优成果。例如编译优化，偏向锁，并行年老代收集等。</td></tr><tr><td VALIGN=\"top\" WIDTH=\"16%\">-XX:CompileThreshold=10000</td><td VALIGN=\"top\" WIDTH=\"10%\">1000</td><td VALIGN=\"top\" WIDTH=\"72%\">通过JIT编译器，将方法编译成机器码的触发阀值，可以理解为调用方法的次数，例如调1000次，将方法编译为机器码。</td></tr><tr><td VALIGN=\"top\" WIDTH=\"16%\">-XX:LargePageSizeInBytes=4m</td><td VALIGN=\"top\" WIDTH=\"10%\">默认4mamd64位：2m</td><td VALIGN=\"top\" WIDTH=\"72%\">设置堆内存的内存页大小。调整内存页的方法和性能提升原理，详见 <a HREF=\"http://kenwublog.com/tune-large-page-for-jvm-optimization\">http://kenwublog.com/tune-large-page-for-jvm-optimization</a></td></tr><tr><td VALIGN=\"top\" WIDTH=\"16%\">-XX:MaxHeapFreeRatio=70</td><td VALIGN=\"top\" WIDTH=\"10%\">70</td><td VALIGN=\"top\" WIDTH=\"72%\">GC后，如果发现空闲堆内存占到整个预估上限值的70%，则收缩预估上限值。<strong>什么是预估上限值？</strong><p>JVM在启动时，会申请最大值（-Xmx指定的数值）的地址空间，但其中绝大部分空间不会被立即分配(virtual)。</p><p>它们会一直保留着，直到运行过程中，JVM发现实际占用接近已分配上限值时，才从virtual里再分配掉一部分内存。</p><p>这里提到的已分配上限值，也可以叫做预估上限值。<br/>\n引入预估上限值的好处是，可以有效地控制堆的大小。堆越小，GC效率越高嘛。</p><p>注意：预估上限值的大小一定小于或等于最大值。</p></td></tr><tr><td VALIGN=\"top\" WIDTH=\"16%\">-XX:MaxNewSize=size</td><td VALIGN=\"top\" WIDTH=\"10%\">1.3.1 Sparc: 32m1.3.1 x86: 2.5m</td><td VALIGN=\"top\" WIDTH=\"72%\">新生代占整个堆内存的最大值。</td></tr><tr><td VALIGN=\"top\" WIDTH=\"16%\">-XX:MaxPermSize=64m</td><td VALIGN=\"top\" WIDTH=\"10%\">5.0以后: 64 bit VMs会增大预设值的30%1.4 amd64: 96m\n<p>1.3.1 -client: 32m</p><p>其他默认 64m</p></td><td VALIGN=\"top\" WIDTH=\"72%\">Perm（俗称方法区）占整个堆内存的最大值。</td></tr><tr><td VALIGN=\"top\" WIDTH=\"16%\">-XX:MinHeapFreeRatio=40</td><td VALIGN=\"top\" WIDTH=\"10%\">40</td><td VALIGN=\"top\" WIDTH=\"72%\">GC后，如果发现空闲堆内存占到整个预估上限值的40%，则增大上限值。(什么是预估上限值？见 -XX:MaxHeapFreeRatio 处的描述)\n<p><strong>关联选项：</strong></p><p>-XX:MaxHeapFreeRatio=70</p></td></tr><tr><td VALIGN=\"top\" WIDTH=\"16%\">-XX:NewRatio=2</td><td VALIGN=\"top\" WIDTH=\"10%\">Sparc -client: 8&times;86 -server: 8\n<p>x86 -client: 12</p><p>-client: 4 (1.3)</p><p>8 (1.3.1+)</p><p>x86: 12</p><p>其他默认 2</p></td><td VALIGN=\"top\" WIDTH=\"72%\">新生代和年老代的堆内存占用比例。例如2例如2表示新生代占年老代的1/2，占整个堆内存的1/3。</td></tr><tr><td VALIGN=\"top\" WIDTH=\"16%\">-XX:NewSize=2.125m</td><td VALIGN=\"top\" WIDTH=\"10%\">5.0以后: 64 bit Vms会增大预设值的30%x86: 1m\n<p>x86, 5.0以后: 640k</p><p>其他默认 2.125m</p></td><td VALIGN=\"top\" WIDTH=\"72%\">新生代预估上限的默认值。(什么是预估上限值？见 -XX:MaxHeapFreeRatio 处的描述)</td></tr><tr><td VALIGN=\"top\" WIDTH=\"16%\">-XX:ReservedCodeCacheSize=32m</td><td VALIGN=\"top\" WIDTH=\"10%\">Solaris 64-bit, amd64, -server x86: 48m1.5.0_06之前, Solaris 64-bit amd64: 1024m\n<p>其他默认 32m</p></td><td VALIGN=\"top\" WIDTH=\"72%\">设置代码缓存的最大值，编译时用。</td></tr><tr><td VALIGN=\"top\" WIDTH=\"16%\">-XX:SurvivorRatio=8</td><td VALIGN=\"top\" WIDTH=\"10%\">Solaris amd64: 6Sparc in 1.3.1: 25\n<p>Solaris platforms5.0以前: 32</p><p>其他默认 8</p></td><td VALIGN=\"top\" WIDTH=\"72%\">Eden与Survivor的占用比例。例如8表示，一个survivor区占用 1/8 的Eden内存，即1/10的新生代内存，为什么不是1/9？因为我们的新生代有2个survivor，即S1和S22。所以survivor总共是占用新生代内存的 2/10，Eden与新生代的占比则为 8/10。</td></tr><tr><td VALIGN=\"top\" WIDTH=\"16%\">-XX:TargetSurvivorRatio=50</td><td VALIGN=\"top\" WIDTH=\"10%\">50</td><td VALIGN=\"top\" WIDTH=\"72%\">实际使用的survivor空间大小占比。默认是50%，最高90%。</td></tr><tr><td VALIGN=\"top\" WIDTH=\"16%\">-XX:ThreadStackSize=512</td><td VALIGN=\"top\" WIDTH=\"10%\">Sparc: 512Solaris x86: 320(5.0以前 256)\n<p>Sparc 64 bit: 1024</p><p>Linux amd64: 1024 (5.0 以前 0)</p><p>其他默认 512.</p></td><td VALIGN=\"top\" WIDTH=\"72%\">线程堆栈大小</td></tr><tr><td VALIGN=\"top\" WIDTH=\"16%\">-XX:+UseBiasedLocking</td><td VALIGN=\"top\" WIDTH=\"10%\">JDK 5 update 6后引入，但需要手动启用。JDK6默认启用。</td><td VALIGN=\"top\" WIDTH=\"72%\">启用4。偏向锁原理详见<a HREF=\"http://kenwublog.com/theory-of-java-biased-locking\">http://kenwublog.com/theory-of-java-biased-locking</a></td></tr><tr><td VALIGN=\"top\" WIDTH=\"16%\">-XX:+UseFastAccessorMethods</td><td VALIGN=\"top\" WIDTH=\"10%\">默认启用</td><td VALIGN=\"top\" WIDTH=\"72%\">优化原始类型的getter方法性能。</td></tr><tr><td VALIGN=\"top\" WIDTH=\"16%\">-XX:-UseISM</td><td VALIGN=\"top\" WIDTH=\"10%\">默认启用</td><td VALIGN=\"top\" WIDTH=\"72%\">启用solaris的ISM。详见<a HREF=\"http://java.sun.com/docs/hotspot/ism.html\">Intimate Shared Memory</a>.</td></tr><tr><td VALIGN=\"top\" WIDTH=\"16%\">-XX:+UseLargePages</td><td VALIGN=\"top\" WIDTH=\"10%\">JDK 5 update 5后引入，但需要手动启用。JDK6默认启用。</td><td VALIGN=\"top\" WIDTH=\"72%\">启用大内存分页。调整内存页的方法和性能提升原理，详见<a HREF=\"http://kenwublog.com/tune-large-page-for-jvm-optimization\">http://kenwublog.com/tune-large-page-for-jvm-optimization</a><p><strong>关联选项</strong></p><p>-XX:LargePageSizeInBytes=4m</p></td></tr><tr><td VALIGN=\"top\" WIDTH=\"16%\">-XX:+UseMPSS</td><td VALIGN=\"top\" WIDTH=\"10%\">1.4.1 之前: 不启用其余版本默认启用</td><td VALIGN=\"top\" WIDTH=\"72%\">启用solaris的MPSS，不能与ISM同时使用。</td></tr><tr><td VALIGN=\"top\" WIDTH=\"16%\">-XX:+StringCache</td><td VALIGN=\"top\" WIDTH=\"10%\">默认启用</td><td VALIGN=\"top\" WIDTH=\"72%\">启用字符串缓存。</td></tr><tr><td VALIGN=\"top\" WIDTH=\"16%\">-XX:AllocatePrefetchLines=1</td><td VALIGN=\"top\" WIDTH=\"10%\">1</td><td VALIGN=\"top\" WIDTH=\"72%\">与机器码指令预读相关的一个选项，资料比较少，本文档不做解释。有兴趣的朋友请自行阅读官方doc。</td></tr><tr><td VALIGN=\"top\" WIDTH=\"16%\">-XX:AllocatePrefetchStyle=1</td><td VALIGN=\"top\" WIDTH=\"10%\">1</td><td VALIGN=\"top\" WIDTH=\"72%\">与机器码指令预读相关的一个选项，资料比较少，本文档不做解释。有兴趣的朋友请自行阅读官方doc。</td></tr></tbody></table><hr SIZE=\"2\"/><p><strong>调试选项</strong></p><table BORDER=\"1\" CELLPADDING=\"0\" CELLSPACING=\"0\" WIDTH=\"100%\"><tbody><tr><td VALIGN=\"15\"><strong>选项与默认值</strong></td><td VALIGN=\"top\" WIDTH=\"11%\"><strong>默认值与限制</strong></td><td VALIGN=\"top\" WIDTH=\"72%\"><strong>描述</strong></td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:-CITime</td><td VALIGN=\"top\" WIDTH=\"11%\">1.4引入。默认启用</td><td VALIGN=\"top\" WIDTH=\"72%\">打印JIT编译器编译耗时。</td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:ErrorFile=<br/>\n./hs_err_pid&lt;pid&gt;.log</td><td VALIGN=\"top\" WIDTH=\"11%\">Java 6引入。</td><td VALIGN=\"top\" WIDTH=\"72%\">如果JVM crashed，将错误日志输出到指定文件路径。</td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:-ExtendedDTraceProbes</td><td VALIGN=\"top\" WIDTH=\"11%\">Java6引入，限于solaris默认不启用</td><td VALIGN=\"top\" WIDTH=\"72%\">启用<a HREF=\"http://java.sun.com/javase/6/docs/technotes/guides/vm/dtrace.html\">dtrace</a>诊断。</td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:HeapDumpPath=<br/>\n./java_pid&lt;pid&gt;.hprof</td><td VALIGN=\"top\" WIDTH=\"11%\">默认是java进程启动位置，即user.dir</td><td VALIGN=\"top\" WIDTH=\"72%\">堆内存快照的存储文件路径。<br/><strong>什么是堆内存快照？</strong><p>当java进程因OOM或crash被OS强制终止后，</p><p>会生成一个hprof（Heap PROFling）格式的堆内存快照文件。</p><p>该文件用于线下调试，诊断，查找问题。</p><p>文件名一般为</p><p>java_&lt;pid&gt;_&lt;date&gt;_&lt;time&gt;_heapDump.hprof</p><p>解析快照文件，可以使用 jhat, eclipse MAT，gdb等工具。</p></td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:-HeapDump<br/>\nOnOutOfMemoryError</td><td VALIGN=\"top\" WIDTH=\"11%\">1.4.2 update12 和 5.0 update 7 引入。默认不启用</td><td VALIGN=\"top\" WIDTH=\"72%\">在OOM时，输出一个dump.core文件，<br/>\n记录当时的堆内存快照<br/>\n（什么是堆内存快照? 见 -XX:HeapDumpPath 处的描述）。</td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:OnError=<br/>\n&ldquo;&lt;cmd args&gt;;&lt;cmd args&gt;&rdquo;</td><td VALIGN=\"top\" WIDTH=\"11%\">1.4.2 update 9引入</td><td VALIGN=\"top\" WIDTH=\"72%\">当java每抛出一个ERROR时，运行指定命令行指令集。\n<p>指令集是与OS环境相关的，</p><p>在linux下多数是bash脚本，windows下是dos批处理。</p></td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:OnOutOfMemoryError=<br/>\n&ldquo;&lt;cmd args&gt;;&lt;cmd args&gt;&rdquo;</td><td VALIGN=\"top\" WIDTH=\"11%\">1.4.2 update 12和java6时引入</td><td VALIGN=\"top\" WIDTH=\"72%\">当第一次发生OOM时，运行指定命令行指令集。<br/>\n指令集是与OS环境相关的，在linux下多数是bash脚本，<br/>\nwindows下是dos批处理。</td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:-PrintClassHistogram</td><td VALIGN=\"top\" WIDTH=\"11%\">默认不启用</td><td VALIGN=\"top\" WIDTH=\"72%\">在Windows下, 按ctrl-break或Linux下是<br/>\n执行kill -3（发送SIGQUIT信号）时，<br/>\n打印class柱状图。Jmap &ndash;histo pid也实现了相同的功能。\n<p>详见 <a HREF=\"http://java.sun.com/javase/6/docs/technotes/tools/share/jmap.html\">http://java.sun.com/javase/6/docs/<br/>\ntechnotes/tools/share/jmap.html</a></p></td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:-PrintConcurrentLocks</td><td VALIGN=\"top\" WIDTH=\"11%\">默认不启用</td><td VALIGN=\"top\" WIDTH=\"72%\">在thread dump的同时，打印java.util.concurrent的锁状态。<br/>\nJstack &ndash;l pid 也同样实现了同样的功能。\n<p>详见 <a HREF=\"http://java.sun.com/javase/6/docs/technotes/tools/share/jstack.html\">http://java.sun.com/javase/6/docs/<br/>\ntechnotes/tools/share/jstack.html</a></p></td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:-PrintCommandLineFlags</td><td VALIGN=\"top\" WIDTH=\"11%\">5.0 引入，默认不启用</td><td VALIGN=\"top\" WIDTH=\"72%\">Java启动时，往stdout打印当前启用的非稳态jvm options。<br/>\n例如：\n<p>-XX:+UseConcMarkSweepGC<br/>\n-XX:+HeapDumpOnOutOfMemoryError<br/>\n-XX:+DoEscapeAnalysis</p></td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:-PrintCompilation</td><td VALIGN=\"top\" WIDTH=\"11%\">默认不启用</td><td VALIGN=\"top\" WIDTH=\"72%\">往stdout打印方法被JIT编译时的信息。例如：\n<p>1 java.lang.String::charAt (33 bytes)</p></td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:-PrintGC</td><td VALIGN=\"top\" WIDTH=\"11%\">默认不启用</td><td VALIGN=\"top\" WIDTH=\"72%\">开启GC日志打印。打印格式例如：\n<p>[Full GC 131115K-&gt;7482K(1015808K), 0.1633180 secs]</p><p>该选项可通过<br/>\ncom.sun.management.HotSpotDiagnosticMXBean API<br/>\n和 Jconsole 动态启用。</p><p>详见 <a HREF=\"http://java.sun.com/developer/technicalArticles/J2SE/monitoring/%23Heap_Dump\">http://java.sun.com/developer/<br/>\ntechnicalArticles/J2SE/monitoring/#Heap_Dump</a></p></td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:-PrintGCDetails</td><td VALIGN=\"top\" WIDTH=\"11%\">1.4.0引入，默认不启用</td><td VALIGN=\"top\" WIDTH=\"72%\">打印GC回收的细节。打印格式例如：\n<p>[Full GC (System) [Tenured: 0K-&gt;2394K(466048K),<br/>\n0.0624140 secs] 30822K-&gt;2394K(518464K),</p><p>[Perm : 10443K-&gt;10443K(16384K)], 0.0625410 secs]<br/>\n[Times: user=0.05 sys=0.01, real=0.06 secs]</p><p>该选项可通过<br/>\ncom.sun.management.HotSpotDiagnosticMXBean API<br/>\n和 Jconsole 动态启用。</p><p>详见 <a HREF=\"http://java.sun.com/developer/technicalArticles/J2SE/monitoring/%23Heap_Dump\">http://java.sun.com/developer/<br/>\ntechnicalArticles/J2SE/monitoring/#Heap_Dump</a></p></td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:-PrintGCTimeStamps</td><td VALIGN=\"top\" WIDTH=\"11%\">默认不启用</td><td VALIGN=\"top\" WIDTH=\"72%\">打印GC停顿耗时。打印格式例如：\n<p><strong>2.744</strong>: [Full GC (System) 2.744:<br/>\n[Tenured: 0K-&gt;2441K(466048K), 0.0598400 secs]<br/>\n31754K-&gt;2441K(518464K),</p><p>[Perm : 10717K-&gt;10717K(16384K)], 0.0599570 secs]<br/>\n[Times: user=0.06 sys=0.00, real=0.06secs]</p><p>该选项可通过<br/>\ncom.sun.management.HotSpotDiagnosticMXBean API<br/>\n和 Jconsole 动态启用。</p><p>详见 <a HREF=\"http://java.sun.com/developer/technicalArticles/J2SE/monitoring/%23Heap_Dump\">http://java.sun.com/developer/<br/>\ntechnicalArticles/J2SE/monitoring/#Heap_Dump</a></p></td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:<br/>\n-PrintTenuringDistribution</td><td VALIGN=\"top\" WIDTH=\"11%\">默认不启用</td><td VALIGN=\"top\" WIDTH=\"72%\">打印对象的存活期限信息。打印格式例如：\n<p>[GC<br/>\nDesired survivor size 4653056 bytes, new threshold 32 (max 32)<br/>\n- age 1: 2330640 bytes, 2330640 total<br/>\n- age 2: 9520 bytes, 2340160 total</p><p>204009K-&gt;21850K(515200K), 0.1563482 secs]</p><p>Age1 2表示在第1和2次GC后存活的对象大小。</p></td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:-TraceClassLoading</td><td VALIGN=\"top\" WIDTH=\"11%\">默认不启用</td><td VALIGN=\"top\" WIDTH=\"72%\">打印class装载信息到stdout。记Loaded状态。例如：\n<p>[Loaded java.lang.Object from /opt/taobao/install/jdk1.6.0_07/jre/lib/rt.jar]</p></td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:<br/>\n-TraceClassLoadingPreorder</td><td VALIGN=\"top\" WIDTH=\"11%\">1.4.2引入，默认不启用</td><td VALIGN=\"top\" WIDTH=\"72%\">按class的引用/依赖顺序打印类装载信息到stdout。不同于 TraceClassLoading，本选项只记 Loading状态。\n<p>例如：</p><p>[Loading java.lang.Object from /home/confsrv/jdk1.6.0_14/jre/lib/rt.jar]</p></td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:-TraceClassResolution</td><td VALIGN=\"top\" WIDTH=\"11%\">1.4.2引入，默认不启用</td><td VALIGN=\"top\" WIDTH=\"72%\">打印所有静态类，常量的代码引用位置。用于debug。例如：\n<p>RESOLVE java.util.HashMap java.util.HashMap$Entry HashMap.java:209</p><p>说明HashMap类的209行引用了静态类 java.util.HashMap$Entry</p></td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:-TraceClassUnloading</td><td VALIGN=\"top\" WIDTH=\"11%\">默认不启用</td><td VALIGN=\"top\" WIDTH=\"72%\">打印class的卸载信息到stdout。记Unloaded状态。</td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:-TraceLoaderConstraints</td><td VALIGN=\"top\" WIDTH=\"11%\">Java6 引入，默认不启用</td><td VALIGN=\"top\" WIDTH=\"72%\">打印class的装载策略变化信息到stdout。例如：\n<p>[Adding new constraint for name: java/lang/String,<br/>\nloader[0]: sun/misc/Launcher$ExtClassLoader,<br/>\nloader[1]: &lt;bootloader&gt; ]</p><p>[Setting class object in existing constraint for name:<br/>\n[Ljava/lang/Object;<br/>\nand loader sun/misc/Launcher$ExtClassLoader ]</p><p>[Updating constraint for name org/xml/sax/InputSource,<br/>\nloader &lt;bootloader&gt;, by setting class object ]</p><p>[Extending constraint for name java/lang/Object<br/>\nby adding loader[15]:<br/>\nsun/reflect/DelegatingClassLoader ]</p><p>装载策略变化是实现classloader<br/>\n隔离/名称空间一致性的关键技术。</p><p>对此感兴趣的朋友，详见<br/><a HREF=\"http://kenwublog.com/docs/Dynamic+Class+Loading+in+the+Java+Virtual+Machine.pdf\">http://kenwublog.com/docs/<br/>\nDynamic+Class+Loading+in+the+<br/>\nJava+Virtual+Machine.pdf</a><br/>\n中的 contraint rules一章。</p></td></tr><tr><td VALIGN=\"top\" WIDTH=\"15%\">-XX:+PerfSaveDataToFile</td><td VALIGN=\"top\" WIDTH=\"11%\">默认启用</td><td VALIGN=\"top\" WIDTH=\"72%\">当java进程因OOM或crashed被强制终止后，生成一个堆快照文件（什么是堆内存快照? 见 -XX:HeapDumpPath 处的描述）。</td></tr></tbody></table><p><strong>作者敬告</strong></p><p>完善的单元测试，功能回归测试，和性能基准测试可以减少因调整非稳态JVM选项带来的风险。</p><p>参考资料</p><p>Java6性能调优白皮书</p><p><a HREF=\"http://java.sun.com/performance/reference/whitepapers/6_performance.html\">http://java.sun.com/performance/reference/whitepapers/6_performance.html</a></p><p>Java6 GC调优指南</p><p><a HREF=\"http://java.sun.com/javase/technologies/hotspot/gc/gc_tuning_6.html\">http://java.sun.com/javase/technologies/hotspot/gc/gc_tuning_6.html</a></p><p>更为全面的options列表</p><p><a HREF=\"http://blogs.sun.com/watt/resource/jvm-options-list.html\">http://blogs.sun.com/watt/resource/jvm-options-list.html</a></p><div STYLE=\"font-style: italic; margin-top: 10px;\"><p><strong>原创文章，转载请注明：</strong> <a HREF=\"http://www.sunwei.org/\">转载自：孙伟博客-sunwei.org</a></p><p><strong>本文链接地址:</strong> <a HREF=\"http://www.sunwei.org/archives/189\" TITLE=\"Java 6 JVM参数选项大全（中文版）\">http://www.sunwei.org/archives/189 | Java 6 JVM参数选项大全（中文版）</a></p></div></div></en-note>      ",
      "content_path": null,
      "diff_base_variant_id": null,
      "metadata": {
        "checksum": "6238b66aa3832a2170124e218b64b13f810292a6d46b76842d71f68cd9c2d3f3",
        "path": "backups/2023年6月/IT技术/Java 6 JVM参数选项大全（中文版）.html"
      }
    },
    {
      "id": "12498a90-0fac-433a-8af0-e98cee015be0",
      "note_id": "7d8781d1-b666-45f8-8d40-d0c3244733e9",
      "variant_type": "clean_text",
      "version": 1,
      "created_by": "evernote_ingest:v0",
      "created_at": "2025-11-10T15:43:30.849976Z",
      "content": "---\ntitle: Java 6 JVM参数选项大全（中文版）\nupdated: 2012-06-25 00:46:56Z\ncreated: 2012-06-25 00:46:45Z\nsource: http://www.sunwei.org/archives/189\ntags:\n  - java\n  - jvm\n---\n\n本文是基于最新的SUN官方文档\nJava SE 6 Hotspot VM Options\n 编写的译文。主要介绍JVM中的非稳态选项及其使用说明。\n为了让读者明白每个选项的含义，作者在原文基础上\n补充了大量的资料\n。希望这份文档，对正在研究JVM参数的朋友有帮助！\n另外，考虑到本文档是初稿，如有描述错误，敬请指正。\n非稳态\n选项使用说明\n-XX:+<option> 启用选项\n-XX:-<option> 不启用选项\n-XX:<option>=<number> 给选项设置一个数字类型值，可跟单位，例如 32k, 1024m, 2g\n\n-XX:<option>=<string> 给选项设置一个字符串值，例如-XX:HeapDumpPath=./dump.core\n行为\n选项\n默认值与限制\n描述\n-XX:-AllowUserSignalHandlers\n限于Linux和Solaris，默认不启用\n允许为java进程安装信号处理器。\n\nJava信号处理相关知识，详见\nhttp://kenwublog.com/java-asynchronous-notify-based-on-signal\n-XX:-DisableExplicitGC\n默认不启用\n禁止在运行期显式地调用 System.gc()。开启该选项后，GC的触发时机将由Garbage Collector全权掌控。\n\n注意：你熟悉的代码里没调用System.gc()，不代表你依赖的框架工具没在使用。例如RMI就在多数用户毫不知情的情况下，显示地调用GC来防止自身OOM。\n\n请仔细权衡禁用带来的影响。\n-XX:-RelaxAccessControlCheck\n默认不启用\n在Class校验器中，放松对访问控制的检查。作用与reflection里的setAccessible类似。\n-XX:-UseConcMarkSweepGC\n默认不启用\n启用CMS低停顿垃圾收集器。资料详见：\nhttp://kenwublog.com/docs/CMS_GC.pdf\n-XX:-UseParallelGC\n-server时启用其他情况下，默认不启用\n策略为新生代使用并行清除，年老代使用单线程Mark-Sweep-Compact的垃圾收集器。\n-XX:-UseParallelOldGC\n默认不启用\n策略为老年代和新生代都使用并行清除的垃圾收集器。\n-XX:-UseSerialGC\n-client时启用其他情况下，默认不启用\n使用串行垃圾收集器。\n-XX:+UseSplitVerifier\njava5默认不启用java6默认启用\n使用新的Class类型校验器 。\n新Class类型校验器有什么特点？\n\n新Class类型校验器，将老的校验步骤拆分成了两步：\n\n1，类型推断。\n\n2，类型校验。新类型校验器通过在javac编译时嵌入类型信息到bytecode中，省略了类型推断这一步，从而提升了classloader的性能。Classload顺序（供参考）\n\nload ->\nverify\n -> prepare -> resove -> init\n关联选项：\n\n-XX:+FailOverToOldVerifier\nJava6新引入选项，默认启用\n如果新的Class校验器检查失败，则使用老的校验器。\n\n为什么会失败？\n因为JDK6最高向下兼容到JDK1.2，而JDK1.2的class info 与JDK6的info存在较大的差异，所以新校验器可能会出现校验失败的情况。\n\n关联选项：\n-XX:+UseSplitVerifier\n-XX:+HandlePromotionFailure\njava5以前是默认不启用，java6默认启用\n关闭新生代收集担保。\n什么是新生代收集\n担保？\n\n在一次理想化的minor gc中，Eden和First Survivor中的活跃对象会被复制到Second Survivor。\n\n然而，Second Survivor不一定能容纳下所有从E和F区copy过来的活跃对象。为了确保minor gc能够顺利完成，GC需要在年老代中额外保留一块足以容纳所有活跃对象的内存空间。\n\n这个预留操作，就被称之为新生代收集担保（New Generation Guarantee）。如果预留操作无法完成时，仍会触发major gc(full gc)。\n为什么要关闭新生代收集\n担保？\n\n因为在年老代中预留的空间大小，是无法精确计算的。 为了确保极端情况的发生，GC参考了最坏情况下的新生代内存占用，即Eden+First Survivor。\n\n这种策略无疑是在浪费年老代内存，从时序角度看，还会提前触发Full GC。\n为了避免如上情况的发生，JVM允许开发者手动关闭新生代收集担保。\n在开启本选项后，minor gc将不再提供新生代收集担保，而是在出现survior或年老代不够用时，抛出promotion failed异常。\n-XX:+UseSpinning\njava1.4.2和1.5需要手动启用, java6默认已启用\n启用多线程自旋锁优化。\n自旋锁优化原理\n大家知道，Java的多线程安全是基于Lock机制实现的，而Lock的性能往往不如人意。\n\n原因是，monitorenter与monitorexit这两个控制多线程同步的bytecode原语，是JVM依赖操作系统互斥(mutex)来实现的。\n\n互斥是一种会导致线程挂起，并在较短的时间内又必须重新调度回原线程的，较为消耗资源的操作。为了避免进入OS互斥，Java6的开发者们提出了自旋锁优化。自旋锁优化的原理是在线程进入OS互斥前，通过CAS自旋一定的次数来检测锁的释放。\n\n如果在自旋次数未达到预设值前锁已被释放，则当前线程会立即持有该锁。\nCAS检测锁的原理详见:\nhttp://kenwublog.com/theory-of-lightweight-locking-upon-cas\n关联选项：\n\n-XX:PreBlockSpin=10\n-XX:+UseSpinning 必须先启用，对于java6来说已经默认启用了，这里默认自旋10次\n控制多线程自旋锁优化的自旋次数。(什么是自旋锁优化？见 -XX:+UseSpinning 处的描述)\n关联选项：\n\n-XX:+UseSpinning\n-XX:+ScavengeBeforeFullGC\n默认启用\n在Full GC前触发一次Minor GC。\n-XX:+UseGCOverheadLimit\n默认启用\n限制GC的运行时间。如果GC耗时过长，就抛OOM。\n-XX:+UseTLAB\n1.4.2以前和使用-client选项时，默认不启用，其余版本默认启用\n启用线程本地缓存区（Thread Local）。\n-XX:+UseThreadPriorities\n默认启用\n使用本地线程的优先级。\n-XX:+UseAltSigs\n限于Solaris，默认启用\n为了防止与其他发送信号的应用程序冲突，允许使用候补信号替代 SIGUSR1和SIGUSR2。\n-XX:+UseBoundThreads\n限于Solaris, 默认启用\n绑定所有的用户线程到内核线程。\n\n减少线程进入饥饿状态（得不到任何cpu time）的次数。\n-XX:+UseLWPSynchronization\n限于solaris，默认启用\n使用轻量级进程（内核线程）替换线程同步。\n-XX:+MaxFDLimit\n限于Solaris，默认启用\n设置java进程可用文件描述符为操作系统允许的最大值。\n-XX:+UseVMInterruptibleIO\n限于solaris，默认启用\n在solaris中，允许运行时中断线程 。\n性能选项\n选项与默认值\n默认值与限制\n描述\n-XX:+AggressiveOpts\nJDK 5 update 6后引入，但需要手动启用。JDK6默认启用。\n启用JVM开发团队最新的调优成果。例如编译优化，偏向锁，并行年老代收集等。\n-XX:CompileThreshold=10000\n1000\n通过JIT编译器，将方法编译成机器码的触发阀值，可以理解为调用方法的次数，例如调1000次，将方法编译为机器码。\n-XX:LargePageSizeInBytes=4m\n默认4mamd64位：2m\n设置堆内存的内存页大小。调整内存页的方法和性能提升原理，详见\nhttp://kenwublog.com/tune-large-page-for-jvm-optimization\n-XX:MaxHeapFreeRatio=70\n70\nGC后，如果发现空闲堆内存占到整个预估上限值的70%，则收缩预估上限值。\n什么是预估上限值？\nJVM在启动时，会申请最大值（-Xmx指定的数值）的地址空间，但其中绝大部分空间不会被立即分配(virtual)。\n它们会一直保留着，直到运行过程中，JVM发现实际占用接近已分配上限值时，才从virtual里再分配掉一部分内存。\n这里提到的已分配上限值，也可以叫做预估上限值。\n\n引入预估上限值的好处是，可以有效地控制堆的大小。堆越小，GC效率越高嘛。\n注意：预估上限值的大小一定小于或等于最大值。\n-XX:MaxNewSize=size\n1.3.1 Sparc: 32m1.3.1 x86: 2.5m\n新生代占整个堆内存的最大值。\n-XX:MaxPermSize=64m\n5.0以后: 64 bit VMs会增大预设值的30%1.4 amd64: 96m\n\n1.3.1 -client: 32m\n其他默认 64m\nPerm（俗称方法区）占整个堆内存的最大值。\n-XX:MinHeapFreeRatio=40\n40\nGC后，如果发现空闲堆内存占到整个预估上限值的40%，则增大上限值。(什么是预估上限值？见 -XX:MaxHeapFreeRatio 处的描述)\n\n关联选项：\n-XX:MaxHeapFreeRatio=70\n-XX:NewRatio=2\nSparc -client: 8×86 -server: 8\n\nx86 -client: 12\n-client: 4 (1.3)\n8 (1.3.1+)\nx86: 12\n其他默认 2\n新生代和年老代的堆内存占用比例。例如2例如2表示新生代占年老代的1/2，占整个堆内存的1/3。\n-XX:NewSize=2.125m\n5.0以后: 64 bit Vms会增大预设值的30%x86: 1m\n\nx86, 5.0以后: 640k\n其他默认 2.125m\n新生代预估上限的默认值。(什么是预估上限值？见 -XX:MaxHeapFreeRatio 处的描述)\n-XX:ReservedCodeCacheSize=32m\nSolaris 64-bit, amd64, -server x86: 48m1.5.0_06之前, Solaris 64-bit amd64: 1024m\n\n其他默认 32m\n设置代码缓存的最大值，编译时用。\n-XX:SurvivorRatio=8\nSolaris amd64: 6Sparc in 1.3.1: 25\n\nSolaris platforms5.0以前: 32\n其他默认 8\nEden与Survivor的占用比例。例如8表示，一个survivor区占用 1/8 的Eden内存，即1/10的新生代内存，为什么不是1/9？因为我们的新生代有2个survivor，即S1和S22。所以survivor总共是占用新生代内存的 2/10，Eden与新生代的占比则为 8/10。\n-XX:TargetSurvivorRatio=50\n50\n实际使用的survivor空间大小占比。默认是50%，最高90%。\n-XX:ThreadStackSize=512\nSparc: 512Solaris x86: 320(5.0以前 256)\n\nSparc 64 bit: 1024\nLinux amd64: 1024 (5.0 以前 0)\n其他默认 512.\n线程堆栈大小\n-XX:+UseBiasedLocking\nJDK 5 update 6后引入，但需要手动启用。JDK6默认启用。\n启用4。偏向锁原理详见\nhttp://kenwublog.com/theory-of-java-biased-locking\n-XX:+UseFastAccessorMethods\n默认启用\n优化原始类型的getter方法性能。\n-XX:-UseISM\n默认启用\n启用solaris的ISM。详见\nIntimate Shared Memory\n.\n-XX:+UseLargePages\nJDK 5 update 5后引入，但需要手动启用。JDK6默认启用。\n启用大内存分页。调整内存页的方法和性能提升原理，详见\nhttp://kenwublog.com/tune-large-page-for-jvm-optimization\n关联选项\n-XX:LargePageSizeInBytes=4m\n-XX:+UseMPSS\n1.4.1 之前: 不启用其余版本默认启用\n启用solaris的MPSS，不能与ISM同时使用。\n-XX:+StringCache\n默认启用\n启用字符串缓存。\n-XX:AllocatePrefetchLines=1\n1\n与机器码指令预读相关的一个选项，资料比较少，本文档不做解释。有兴趣的朋友请自行阅读官方doc。\n-XX:AllocatePrefetchStyle=1\n1\n与机器码指令预读相关的一个选项，资料比较少，本文档不做解释。有兴趣的朋友请自行阅读官方doc。\n调试选项\n选项与默认值\n默认值与限制\n描述\n-XX:-CITime\n1.4引入。默认启用\n打印JIT编译器编译耗时。\n-XX:ErrorFile=\n\n./hs_err_pid<pid>.log\nJava 6引入。\n如果JVM crashed，将错误日志输出到指定文件路径。\n-XX:-ExtendedDTraceProbes\nJava6引入，限于solaris默认不启用\n启用\ndtrace\n诊断。\n-XX:HeapDumpPath=\n\n./java_pid<pid>.hprof\n默认是java进程启动位置，即user.dir\n堆内存快照的存储文件路径。\n什么是堆内存快照？\n当java进程因OOM或crash被OS强制终止后，\n会生成一个hprof（Heap PROFling）格式的堆内存快照文件。\n该文件用于线下调试，诊断，查找问题。\n文件名一般为\njava_<pid>_<date>_<time>_heapDump.hprof\n解析快照文件，可以使用 jhat, eclipse MAT，gdb等工具。\n-XX:-HeapDump\n\nOnOutOfMemoryError\n1.4.2 update12 和 5.0 update 7 引入。默认不启用\n在OOM时，输出一个dump.core文件，\n\n记录当时的堆内存快照\n\n（什么是堆内存快照? 见 -XX:HeapDumpPath 处的描述）。\n-XX:OnError=\n\n“<cmd args>;<cmd args>”\n1.4.2 update 9引入\n当java每抛出一个ERROR时，运行指定命令行指令集。\n\n指令集是与OS环境相关的，\n在linux下多数是bash脚本，windows下是dos批处理。\n-XX:OnOutOfMemoryError=\n\n“<cmd args>;<cmd args>”\n1.4.2 update 12和java6时引入\n当第一次发生OOM时，运行指定命令行指令集。\n\n指令集是与OS环境相关的，在linux下多数是bash脚本，\n\nwindows下是dos批处理。\n-XX:-PrintClassHistogram\n默认不启用\n在Windows下, 按ctrl-break或Linux下是\n\n执行kill -3（发送SIGQUIT信号）时，\n\n打印class柱状图。Jmap –histo pid也实现了相同的功能。\n\n详见\nhttp://java.sun.com/javase/6/docs/\n\ntechnotes/tools/share/jmap.html\n-XX:-PrintConcurrentLocks\n默认不启用\n在thread dump的同时，打印java.util.concurrent的锁状态。\n\nJstack –l pid 也同样实现了同样的功能。\n\n详见\nhttp://java.sun.com/javase/6/docs/\n\ntechnotes/tools/share/jstack.html\n-XX:-PrintCommandLineFlags\n5.0 引入，默认不启用\nJava启动时，往stdout打印当前启用的非稳态jvm options。\n\n例如：\n\n-XX:+UseConcMarkSweepGC\n\n-XX:+HeapDumpOnOutOfMemoryError\n\n-XX:+DoEscapeAnalysis\n-XX:-PrintCompilation\n默认不启用\n往stdout打印方法被JIT编译时的信息。例如：\n\n1 java.lang.String::charAt (33 bytes)\n-XX:-PrintGC\n默认不启用\n开启GC日志打印。打印格式例如：\n\n[Full GC 131115K->7482K(1015808K), 0.1633180 secs]\n该选项可通过\n\ncom.sun.management.HotSpotDiagnosticMXBean API\n\n和 Jconsole 动态启用。\n详见\nhttp://java.sun.com/developer/\n\ntechnicalArticles/J2SE/monitoring/#Heap_Dump\n-XX:-PrintGCDetails\n1.4.0引入，默认不启用\n打印GC回收的细节。打印格式例如：\n\n[Full GC (System) [Tenured: 0K->2394K(466048K),\n\n0.0624140 secs] 30822K->2394K(518464K),\n[Perm : 10443K->10443K(16384K)], 0.0625410 secs]\n\n[Times: user=0.05 sys=0.01, real=0.06 secs]\n该选项可通过\n\ncom.sun.management.HotSpotDiagnosticMXBean API\n\n和 Jconsole 动态启用。\n详见\nhttp://java.sun.com/developer/\n\ntechnicalArticles/J2SE/monitoring/#Heap_Dump\n-XX:-PrintGCTimeStamps\n默认不启用\n打印GC停顿耗时。打印格式例如：\n\n2.744\n: [Full GC (System) 2.744:\n\n[Tenured: 0K->2441K(466048K), 0.0598400 secs]\n\n31754K->2441K(518464K),\n[Perm : 10717K->10717K(16384K)], 0.0599570 secs]\n\n[Times: user=0.06 sys=0.00, real=0.06secs]\n该选项可通过\n\ncom.sun.management.HotSpotDiagnosticMXBean API\n\n和 Jconsole 动态启用。\n详见\nhttp://java.sun.com/developer/\n\ntechnicalArticles/J2SE/monitoring/#Heap_Dump\n-XX:\n\n-PrintTenuringDistribution\n默认不启用\n打印对象的存活期限信息。打印格式例如：\n\n[GC\n\nDesired survivor size 4653056 bytes, new threshold 32 (max 32)\n\n- age 1: 2330640 bytes, 2330640 total\n\n- age 2: 9520 bytes, 2340160 total\n204009K->21850K(515200K), 0.1563482 secs]\nAge1 2表示在第1和2次GC后存活的对象大小。\n-XX:-TraceClassLoading\n默认不启用\n打印class装载信息到stdout。记Loaded状态。例如：\n\n[Loaded java.lang.Object from /opt/taobao/install/jdk1.6.0_07/jre/lib/rt.jar]\n-XX:\n\n-TraceClassLoadingPreorder\n1.4.2引入，默认不启用\n按class的引用/依赖顺序打印类装载信息到stdout。不同于 TraceClassLoading，本选项只记 Loading状态。\n\n例如：\n[Loading java.lang.Object from /home/confsrv/jdk1.6.0_14/jre/lib/rt.jar]\n-XX:-TraceClassResolution\n1.4.2引入，默认不启用\n打印所有静态类，常量的代码引用位置。用于debug。例如：\n\nRESOLVE java.util.HashMap java.util.HashMap$Entry HashMap.java:209\n说明HashMap类的209行引用了静态类 java.util.HashMap$Entry\n-XX:-TraceClassUnloading\n默认不启用\n打印class的卸载信息到stdout。记Unloaded状态。\n-XX:-TraceLoaderConstraints\nJava6 引入，默认不启用\n打印class的装载策略变化信息到stdout。例如：\n\n[Adding new constraint for name: java/lang/String,\n\nloader[0]: sun/misc/Launcher$ExtClassLoader,\n\nloader[1]: <bootloader> ]\n[Setting class object in existing constraint for name:\n\n[Ljava/lang/Object;\n\nand loader sun/misc/Launcher$ExtClassLoader ]\n[Updating constraint for name org/xml/sax/InputSource,\n\nloader <bootloader>, by setting class object ]\n[Extending constraint for name java/lang/Object\n\nby adding loader[15]:\n\nsun/reflect/DelegatingClassLoader ]\n装载策略变化是实现classloader\n\n隔离/名称空间一致性的关键技术。\n对此感兴趣的朋友，详见\nhttp://kenwublog.com/docs/\n\nDynamic+Class+Loading+in+the+\n\nJava+Virtual+Machine.pdf\n\n中的 contraint rules一章。\n-XX:+PerfSaveDataToFile\n默认启用\n当java进程因OOM或crashed被强制终止后，生成一个堆快照文件（什么是堆内存快照? 见 -XX:HeapDumpPath 处的描述）。\n作者敬告\n完善的单元测试，功能回归测试，和性能基准测试可以减少因调整非稳态JVM选项带来的风险。\n参考资料\nJava6性能调优白皮书\nhttp://java.sun.com/performance/reference/whitepapers/6_performance.html\nJava6 GC调优指南\nhttp://java.sun.com/javase/technologies/hotspot/gc/gc_tuning_6.html\n更为全面的options列表\nhttp://blogs.sun.com/watt/resource/jvm-options-list.html\n原创文章，转载请注明：\n\n转载自：孙伟博客-sunwei.org\n本文链接地址:\n\nhttp://www.sunwei.org/archives/189 | Java 6 JVM参数选项大全（中文版）",
      "content_path": null,
      "diff_base_variant_id": null,
      "metadata": {
        "language": "no",
        "length": 10360,
        "rule_count": 2,
        "applied_rules": [
          {
            "rule_id": "dedupe_lines",
            "description": "Collapse adjacent duplicate lines",
            "note": "collapsed duplicate adjacent lines"
          },
          {
            "rule_id": "whitespace",
            "description": "Normalize whitespace",
            "note": "collapsed whitespace"
          }
        ]
      }
    }
  ],
  "extractions": [
    {
      "id": "0283525f-79fa-46e6-9942-d1efc131842a",
      "note_id": "7d8781d1-b666-45f8-8d40-d0c3244733e9",
      "extractor": "llm_enhance:v0#fallback",
      "payload": {
        "summary": "--- title: Java 6 JVM参数选项大全（中文版） updated: 2012-06-25 00:46:56Z created: 2012-06-",
        "keywords": [
          "---",
          "title: Java 6 JVM参数选项大全（中文版）",
          "updated: 2012-06-25 00:46:56Z",
          "created: 2012-06-25 00:46:45Z",
          "source: http://www.sunwei.org/archives/189"
        ],
        "action_items": [
          "无"
        ],
        "source": "fallback",
        "category_path": [
          "Education"
        ],
        "new_category_suggestion": null
      },
      "version": 1,
      "created_at": "2025-11-12T00:20:32.256638Z",
      "created_by": "llm_enhance:v0",
      "quality_score": 0.148
    }
  ],
  "journal": {
    "id": "d2f1c435-e0ee-4bf9-b543-71b555348cf2",
    "note_id": "7d8781d1-b666-45f8-8d40-d0c3244733e9",
    "stage": "ingest",
    "agent_id": "evernote_ingest:v0",
    "started_at": "2025-11-10T15:43:30.849981Z",
    "finished_at": "2025-11-10T15:43:30.849981Z",
    "status": "success",
    "input_ref": {
      "task_id": "ff523602-c26c-461c-840b-a44c5da2e150",
      "source_path": "backups/2023年6月/IT技术/Java 6 JVM参数选项大全（中文版）.html",
      "checksum": "6238b66aa3832a2170124e218b64b13f810292a6d46b76842d71f68cd9c2d3f3"
    },
    "output_ref": {
      "ingest_source": "fc279a8d-3d91-4aad-8610-de6166a026dc",
      "note": "7d8781d1-b666-45f8-8d40-d0c3244733e9",
      "variants": [
        "f4e89cc6-107a-4f89-8bb3-58ec1b02ad2b",
        "12498a90-0fac-433a-8af0-e98cee015be0"
      ]
    },
    "error_detail": null
  },
  "llm": {
    "status": "fallback",
    "model": "fallback",
    "updated_at": "2025-11-12T00:20:32.256086Z",
    "latency_seconds": null,
    "attempts": 3,
    "summary": {
      "summary": "--- title: Java 6 JVM参数选项大全（中文版） updated: 2012-06-25 00:46:56Z created: 2012-06-",
      "keywords": [
        "---",
        "title: Java 6 JVM参数选项大全（中文版）",
        "updated: 2012-06-25 00:46:56Z",
        "created: 2012-06-25 00:46:45Z",
        "source: http://www.sunwei.org/archives/189"
      ],
      "action_items": [
        "无"
      ],
      "source": "fallback",
      "category_path": [
        "Education"
      ],
      "new_category_suggestion": null
    },
    "quality": {
      "score": 0.148,
      "metrics": {
        "input_chars": 10360.0,
        "input_lines": 399.0,
        "summary_chars": 80.0,
        "summary_coverage_ratio": 0.008,
        "keyword_hit_rate": 1.0,
        "action_item_count": 1.0,
        "unique_summary_sentences": 1.0,
        "estimated_read_seconds": 621.6
      }
    }
  }
}
{
  "ingest_source": {
    "id": "c4fae54c-9aad-43f4-9a1a-8a7a3d2cb1db",
    "source_type": "evernote_html",
    "source_path": "/Users/tang/workbench/article-classifier/backups/2023年6月/IT技术/ieee802.11数据radiotap介绍.html",
    "collected_at": "2025-11-09T20:05:14.016472Z",
    "external_id": null,
    "title_hint": null,
    "language_hint": "en",
    "captured_at": null,
    "checksum": "14ef73f03f489e11a47f5d9ad8b76c999ce3cb399daca348473b7a5fc6dac20c",
    "status": "pending",
    "notes": {
      "batch_id": null
    }
  },
  "note": {
    "id": "ce305e53-b563-4c09-8398-ab4969ca62f8",
    "ingest_source_id": "c4fae54c-9aad-43f4-9a1a-8a7a3d2cb1db",
    "canonical_title": "ieee802.11数据radiotap介绍",
    "language": "en",
    "ingested_at": "2025-11-09T20:05:14.016480Z",
    "created_at": null,
    "status": "active",
    "importance": 0,
    "attributes": {
      "source_filename": "ieee802.11数据radiotap介绍.html"
    }
  },
  "variants": [
    {
      "id": "9013e45d-c13a-4fb9-8d73-4e2ac3a8438a",
      "note_id": "ce305e53-b563-4c09-8398-ab4969ca62f8",
      "variant_type": "raw_html",
      "version": 1,
      "created_by": "evernote_ingest:v0",
      "created_at": "2025-11-09T20:05:14.016484Z",
      "content": "---\ntitle: ieee802.11数据radiotap介绍\nupdated: 2018-10-30 08:52:25Z\ncreated: 2018-10-30 08:52:07Z\n---\n\n\n<en-note><div>版权声明：本文为迟思堂主人李迟原创文章，版权所有。可随便任意使用（包括学习研究商用），但由此带来的成果或后果，概与作者无关。胡乱修改的，不注明出处的，概不负责。 <a HREF=\"https://blog.csdn.net/subfate/article/details/53170546\">https://blog.csdn.net/subfate/article/details/53170546</a></div><div><br/></div><div>之前写有文章介绍了在Linux系统用wireshark或tcpdump抓无线网卡数据包。分析包时发现每一数据帧前面都有一个叫radiotap的东西。它包含了如信号强度、频率等信息。当时没有研究，直接跳过。本文就对此介绍补充。首先介绍radiotap，然后利用radiotap解析库对一段radiotap数据进行解析，获取其中的信息。</div><div>介绍</div><div><br/></div><div>radiotap比传统的Prism或AVS头部更有灵活性，成为是ieee802.11事实上的标准。支持radiotap的系统较多，如Linux、FreeBSD、NetBSD、OpenBSD，还有Windows(需使用AirPcap)。它的头部定义如下：</div><div><br/></div><div>&nbsp;&nbsp;&nbsp;&nbsp;struct ieee80211_radiotap_header {</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u_int8_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it_version;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* set to 0 */</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u_int8_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it_pad;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u_int16_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it_len;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* entire length */</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u_int32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it_present;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* fields present */</div><div>&nbsp;&nbsp;&nbsp;&nbsp;} __attribute__((__packed__));</div><div><br/></div><div>其中第一个字段it_version表示版本号，当前为0。</div><div><br/></div><div>第二个字段it_pad没有使用，仅仅是为了结构体对齐。</div><div><br/></div><div>第三个字段it_present表示长度，包括了radiotap头部和数据两部分。此设计的好处在于，如果不需要了解radiotap，则可以跳过直接到ieee802.11头部。&mdash;&mdash;半个月前写抓包程序时，还不了解radio，就是直接跳过的。</div><div><br/></div><div>第四个字段it_present表示radiotap数据的位掩码。radiotap的数据紧跟其头部。当其中的位掩码为true时，表示有对应的数据，可以认为每一比特表示一种类型。比如bit5为1表示有通道数据，则可以获取到信号强度。反之就是没有对应的数据。因此radiotap的长度其实是不固定的。bit31为1表示还有多个it_present。不过目前笔者还没有碰到此情况，没有深入了解。</div><div><br/></div><div>radiotap的每个类型都是有严格的顺序的。另外，radiotap数据的字序是小端格式(little endian byte-order)&mdash;&mdash;包括头部的it_len和it_present。</div><div><br/></div><div>目前应用比较广的解析库是radiotap-library&mdash;&mdash;在horst软件和Linux内核中都使用到。关于每个类型的解释，可以参考radiotap.h文件的ieee80211_radiotap_type注释。</div><div><br/></div><div>下面看一下wireshark抓到的包的radiotap头部数据：</div><div><br/></div><div><br/></div><div>由图可见，radiotap包括的东西挺多的。</div><div>解析</div><div><br/></div><div>radiotap解析库使用十分简单，先对此有个基本面的认知概念：</div><div><br/></div><div>1、首先</div><div><br/></div><div>完整代码如下：</div><div><br/></div><div>&nbsp;&nbsp;&nbsp;&nbsp;/**</div><div>&nbsp;&nbsp;&nbsp;&nbsp;radiotap头部解析</div><div>&nbsp;&nbsp;&nbsp;&nbsp;使用radiotap库，源码地址：</div><div>&nbsp;&nbsp;&nbsp;&nbsp;<a HREF=\"https://github.com/radiotap/radiotap-library\">https://github.com/radiotap/radiotap-library</a></div><div>&nbsp;&nbsp;&nbsp;&nbsp;*/</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;#include &lt;unistd.h&gt;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;#include &lt;stdio.h&gt;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;#include &lt;stdint.h&gt;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;#include &lt;endian.h&gt;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;#include &lt;errno.h&gt;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;#include &lt;string.h&gt;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;#include &quot;radiotap_iter.h&quot;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;// 根据wireshark抓包抽取的radiotap头部数据</div><div>&nbsp;&nbsp;&nbsp;&nbsp;char radiotap_buf[][18] = {</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0x00, 0x00, 0x12, 0x00, 0x2e, 0x48,</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00, 0x00, 0x00, 0x02, 0x85, 0x09,</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xc0, 0x00, 0xc9, 0x00, 0x00, 0x00},</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0x00, 0x00, 0x12, 0x00, 0x2e, 0x48,</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00, 0x00, 0x00, 0x02, 0x85, 0x09,</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xa0, 0x00, 0xa8, 0x00, 0x00, 0x00},</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;static void print_radiotap_namespace(struct ieee80211_radiotap_iterator *iter)</div><div>&nbsp;&nbsp;&nbsp;&nbsp;{</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char signal = 0;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32_t phy_freq = 0;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch (iter-&gt;this_arg_index)</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case IEEE80211_RADIOTAP_TSFT:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\tTSFT: %llu\\n&quot;, le64toh(*(unsigned long long *)iter-&gt;this_arg));</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case IEEE80211_RADIOTAP_FLAGS:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\tflags: %02x\\n&quot;, *iter-&gt;this_arg);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 速率？</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case IEEE80211_RADIOTAP_RATE:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\trate: %.2f Mbit/s\\n&quot;, (double)*iter-&gt;this_arg/2);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;#define IEEE80211_CHAN_A \\</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_OFDM)</div><div>&nbsp;&nbsp;&nbsp;&nbsp;#define IEEE80211_CHAN_G \\</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_OFDM)</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 通信信息</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case IEEE80211_RADIOTAP_CHANNEL:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phy_freq = le16toh(*(uint16_t*)iter-&gt;this_arg); // 信道</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iter-&gt;this_arg = iter-&gt;this_arg + 2; // 通道信息如2G、5G，等</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int x = le16toh(*(uint16_t*)iter-&gt;this_arg);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\tfreq: %d type: &quot;, phy_freq);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((x &amp; IEEE80211_CHAN_A) == IEEE80211_CHAN_A)</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;A\\n&quot;);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if ((x &amp; IEEE80211_CHAN_G) == IEEE80211_CHAN_G)</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;G\\n&quot;);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if ((x &amp; IEEE80211_CHAN_2GHZ) == IEEE80211_CHAN_2GHZ)</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;B\\n&quot;);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 信号强度</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case IEEE80211_RADIOTAP_DBM_ANTSIGNAL:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal = *(signed char*)iter-&gt;this_arg;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\tsignal: %d dBm\\n&quot;, signal);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 接收标志</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case IEEE80211_RADIOTAP_RX_FLAGS:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\tRX flags: %#.4x\\n&quot;, le16toh(*(uint16_t *)iter-&gt;this_arg));</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case IEEE80211_RADIOTAP_ANTENNA:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\tantenna: %x\\n&quot;, *iter-&gt;this_arg);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 忽略下面的</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case IEEE80211_RADIOTAP_RTS_RETRIES:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case IEEE80211_RADIOTAP_DATA_RETRIES:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case IEEE80211_RADIOTAP_FHSS:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case IEEE80211_RADIOTAP_DBM_ANTNOISE:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case IEEE80211_RADIOTAP_LOCK_QUALITY:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case IEEE80211_RADIOTAP_TX_ATTENUATION:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case IEEE80211_RADIOTAP_DB_TX_ATTENUATION:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case IEEE80211_RADIOTAP_DBM_TX_POWER:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case IEEE80211_RADIOTAP_DB_ANTSIGNAL:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case IEEE80211_RADIOTAP_DB_ANTNOISE:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case IEEE80211_RADIOTAP_TX_FLAGS:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\\tBOGUS DATA\\n&quot;);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div>&nbsp;&nbsp;&nbsp;&nbsp;}</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;int main(void)</div><div>&nbsp;&nbsp;&nbsp;&nbsp;{</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct ieee80211_radiotap_iterator iter;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int err;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i, j;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (i = 0; i &lt; sizeof(radiotap_buf)/sizeof(radiotap_buf[0]); i++)</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;parsing [%d]\\n&quot;, i);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 初始化</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = ieee80211_radiotap_iterator_init(&amp;iter, </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(struct ieee80211_radiotap_header *)radiotap_buf[i], sizeof(radiotap_buf[i]), NULL);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (err)</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;not valid radiotap...\\n&quot;);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j = 0;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/**</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;遍历时，this_arg_index表示当前索引(如IEEE80211_RADIOTAP_TSFT等)，</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this_arg表示当前索引的值，this_arg_size表示值的大小。</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有flag为true时才会进一步解析。</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (!(err = ieee80211_radiotap_iterator_next(&amp;iter)))</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;next[%d]: index: %d size: %d\\n&quot;,</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j, iter.this_arg_index, iter.this_arg_size);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (iter.is_radiotap_ns) // 表示是radiotap的命名空间</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print_radiotap_namespace(&amp;iter);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j++;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;==================================\\n&quot;);</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;}</div><div><br/></div><div><br/></div><div>执行结果：</div><div><br/></div><div>&nbsp;&nbsp;&nbsp;&nbsp;parsing [0]</div><div>&nbsp;&nbsp;&nbsp;&nbsp;next[0]: index: 1 size: 1</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flags: 00</div><div>&nbsp;&nbsp;&nbsp;&nbsp;next[1]: index: 2 size: 1</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rate: 1.00 Mbit/s</div><div>&nbsp;&nbsp;&nbsp;&nbsp;next[2]: index: 3 size: 4</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freq: 2437 type: G</div><div>&nbsp;&nbsp;&nbsp;&nbsp;next[3]: index: 5 size: 1</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: -55 dBm</div><div>&nbsp;&nbsp;&nbsp;&nbsp;next[4]: index: 11 size: 1</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;antenna: 0</div><div>&nbsp;&nbsp;&nbsp;&nbsp;next[5]: index: 14 size: 2</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX flags: 0000</div><div>&nbsp;&nbsp;&nbsp;&nbsp;==================================</div><div>&nbsp;&nbsp;&nbsp;&nbsp;parsing [1]</div><div>&nbsp;&nbsp;&nbsp;&nbsp;next[0]: index: 1 size: 1</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flags: 00</div><div>&nbsp;&nbsp;&nbsp;&nbsp;next[1]: index: 2 size: 1</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rate: 1.00 Mbit/s</div><div>&nbsp;&nbsp;&nbsp;&nbsp;next[2]: index: 3 size: 4</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freq: 2437 type: B</div><div>&nbsp;&nbsp;&nbsp;&nbsp;next[3]: index: 5 size: 1</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal: -88 dBm</div><div>&nbsp;&nbsp;&nbsp;&nbsp;next[4]: index: 11 size: 1</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;antenna: 0</div><div>&nbsp;&nbsp;&nbsp;&nbsp;next[5]: index: 14 size: 2</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX flags: 0000</div><div>&nbsp;&nbsp;&nbsp;&nbsp;==================================</div><div>--------------------- </div><div>作者：李迟 </div><div>来源：CSDN </div><div>原文：<a HREF=\"https://blog.csdn.net/subfate/article/details/53170546\">https://blog.csdn.net/subfate/article/details/53170546</a> </div><div>版权声明：本文为博主原创文章，转载请附上博文链接！</div></en-note>      ",
      "content_path": null,
      "diff_base_variant_id": null,
      "metadata": {
        "checksum": "14ef73f03f489e11a47f5d9ad8b76c999ce3cb399daca348473b7a5fc6dac20c",
        "path": "/Users/tang/workbench/article-classifier/backups/2023年6月/IT技术/ieee802.11数据radiotap介绍.html"
      }
    },
    {
      "id": "d63c6c7f-f729-439c-a711-4c2373e95c11",
      "note_id": "ce305e53-b563-4c09-8398-ab4969ca62f8",
      "variant_type": "clean_text",
      "version": 1,
      "created_by": "evernote_ingest:v0",
      "created_at": "2025-11-09T20:05:14.016487Z",
      "content": "---\ntitle: ieee802.11数据radiotap介绍\nupdated: 2018-10-30 08:52:25Z\ncreated: 2018-10-30 08:52:07Z\n---\n\n版权声明：本文为迟思堂主人李迟原创文章，版权所有。可随便任意使用（包括学习研究商用），但由此带来的成果或后果，概与作者无关。胡乱修改的，不注明出处的，概不负责。\nhttps://blog.csdn.net/subfate/article/details/53170546\n之前写有文章介绍了在Linux系统用wireshark或tcpdump抓无线网卡数据包。分析包时发现每一数据帧前面都有一个叫radiotap的东西。它包含了如信号强度、频率等信息。当时没有研究，直接跳过。本文就对此介绍补充。首先介绍radiotap，然后利用radiotap解析库对一段radiotap数据进行解析，获取其中的信息。\n介绍\nradiotap比传统的Prism或AVS头部更有灵活性，成为是ieee802.11事实上的标准。支持radiotap的系统较多，如Linux、FreeBSD、NetBSD、OpenBSD，还有Windows(需使用AirPcap)。它的头部定义如下：\n    struct ieee80211_radiotap_header {\n            u_int8_t        it_version;     /* set to 0 */\n            u_int8_t        it_pad;\n            u_int16_t       it_len;         /* entire length */\n            u_int32_t       it_present;     /* fields present */\n    } __attribute__((__packed__));\n其中第一个字段it_version表示版本号，当前为0。\n第二个字段it_pad没有使用，仅仅是为了结构体对齐。\n第三个字段it_present表示长度，包括了radiotap头部和数据两部分。此设计的好处在于，如果不需要了解radiotap，则可以跳过直接到ieee802.11头部。——半个月前写抓包程序时，还不了解radio，就是直接跳过的。\n第四个字段it_present表示radiotap数据的位掩码。radiotap的数据紧跟其头部。当其中的位掩码为true时，表示有对应的数据，可以认为每一比特表示一种类型。比如bit5为1表示有通道数据，则可以获取到信号强度。反之就是没有对应的数据。因此radiotap的长度其实是不固定的。bit31为1表示还有多个it_present。不过目前笔者还没有碰到此情况，没有深入了解。\nradiotap的每个类型都是有严格的顺序的。另外，radiotap数据的字序是小端格式(little endian byte-order)——包括头部的it_len和it_present。\n目前应用比较广的解析库是radiotap-library——在horst软件和Linux内核中都使用到。关于每个类型的解释，可以参考radiotap.h文件的ieee80211_radiotap_type注释。\n下面看一下wireshark抓到的包的radiotap头部数据：\n由图可见，radiotap包括的东西挺多的。\n解析\nradiotap解析库使用十分简单，先对此有个基本面的认知概念：\n1、首先\n完整代码如下：\n    /**\n    radiotap头部解析\n    使用radiotap库，源码地址：\n    \nhttps://github.com/radiotap/radiotap-library\n    */\n     \n    #include <unistd.h>\n    #include <stdio.h>\n    #include <stdint.h>\n    #include <endian.h>\n    #include <errno.h>\n    #include <string.h>\n     \n    #include \"radiotap_iter.h\"\n     \n    // 根据wireshark抓包抽取的radiotap头部数据\n    char radiotap_buf[][18] = {\n                    {0x00, 0x00, 0x12, 0x00, 0x2e, 0x48,\n                     0x00, 0x00, 0x00, 0x02, 0x85, 0x09,\n                     0xc0, 0x00, 0xc9, 0x00, 0x00, 0x00},\n                    {0x00, 0x00, 0x12, 0x00, 0x2e, 0x48,\n                     0x00, 0x00, 0x00, 0x02, 0x85, 0x09,\n                     0xa0, 0x00, 0xa8, 0x00, 0x00, 0x00},\n                    };\n     \n    static void print_radiotap_namespace(struct ieee80211_radiotap_iterator *iter)\n    {\n        char signal = 0;\n        uint32_t phy_freq = 0;\n     \n        switch (iter->this_arg_index)\n        {\n        case IEEE80211_RADIOTAP_TSFT:\n            printf(\"\\tTSFT: %llu\\n\", le64toh(*(unsigned long long *)iter->this_arg));\n            break;\n        case IEEE80211_RADIOTAP_FLAGS:\n            printf(\"\\tflags: %02x\\n\", *iter->this_arg);\n            break;\n        // 速率？\n        case IEEE80211_RADIOTAP_RATE:\n            printf(\"\\trate: %.2f Mbit/s\\n\", (double)*iter->this_arg/2);\n            break;\n     \n    #define IEEE80211_CHAN_A \\\n        (IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_OFDM)\n    #define IEEE80211_CHAN_G \\\n        (IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_OFDM)\n        // 通信信息\n        case IEEE80211_RADIOTAP_CHANNEL:\n            phy_freq = le16toh(*(uint16_t*)iter->this_arg); // 信道\n            iter->this_arg = iter->this_arg + 2; // 通道信息如2G、5G，等\n            int x = le16toh(*(uint16_t*)iter->this_arg);\n            printf(\"\\tfreq: %d type: \", phy_freq);\n            if ((x & IEEE80211_CHAN_A) == IEEE80211_CHAN_A)\n            {\n                printf(\"A\\n\");\n            }\n            else if ((x & IEEE80211_CHAN_G) == IEEE80211_CHAN_G)\n            {\n                printf(\"G\\n\");\n            }\n            else if ((x & IEEE80211_CHAN_2GHZ) == IEEE80211_CHAN_2GHZ)\n            {\n                printf(\"B\\n\");\n            }\n            break;\n        // 信号强度\n        case IEEE80211_RADIOTAP_DBM_ANTSIGNAL:\n            signal = *(signed char*)iter->this_arg;\n            printf(\"\\tsignal: %d dBm\\n\", signal);\n            break;\n        // 接收标志\n        case IEEE80211_RADIOTAP_RX_FLAGS:\n            printf(\"\\tRX flags: %#.4x\\n\", le16toh(*(uint16_t *)iter->this_arg));\n            break;\n        case IEEE80211_RADIOTAP_ANTENNA:\n            printf(\"\\tantenna: %x\\n\", *iter->this_arg);\n            break;\n        // 忽略下面的\n        case IEEE80211_RADIOTAP_RTS_RETRIES:\n        case IEEE80211_RADIOTAP_DATA_RETRIES:\n        case IEEE80211_RADIOTAP_FHSS:\n        case IEEE80211_RADIOTAP_DBM_ANTNOISE:\n        case IEEE80211_RADIOTAP_LOCK_QUALITY:\n        case IEEE80211_RADIOTAP_TX_ATTENUATION:\n        case IEEE80211_RADIOTAP_DB_TX_ATTENUATION:\n        case IEEE80211_RADIOTAP_DBM_TX_POWER:\n        case IEEE80211_RADIOTAP_DB_ANTSIGNAL:\n        case IEEE80211_RADIOTAP_DB_ANTNOISE:\n        case IEEE80211_RADIOTAP_TX_FLAGS:\n            break;\n        default:\n            printf(\"\\tBOGUS DATA\\n\");\n            break;\n        }\n     \n    int main(void)\n    {\n        struct ieee80211_radiotap_iterator iter;\n        int err;\n        int i, j;\n     \n        for (i = 0; i < sizeof(radiotap_buf)/sizeof(radiotap_buf[0]); i++)\n        {\n            printf(\"parsing [%d]\\n\", i);\n            // 初始化\n            err = ieee80211_radiotap_iterator_init(&iter,\n            (struct ieee80211_radiotap_header *)radiotap_buf[i], sizeof(radiotap_buf[i]), NULL);\n            if (err)\n            {\n                printf(\"not valid radiotap...\\n\");\n                return -1;\n            }\n            j = 0;\n            /**\n            遍历时，this_arg_index表示当前索引(如IEEE80211_RADIOTAP_TSFT等)，\n            this_arg表示当前索引的值，this_arg_size表示值的大小。\n            只有flag为true时才会进一步解析。\n            */\n            while (!(err = ieee80211_radiotap_iterator_next(&iter)))\n            {\n                printf(\"next[%d]: index: %d size: %d\\n\",\n                        j, iter.this_arg_index, iter.this_arg_size);\n                if (iter.is_radiotap_ns) // 表示是radiotap的命名空间\n                {\n                    print_radiotap_namespace(&iter);\n                }\n                j++;\n            }\n            printf(\"==================================\\n\");\n        }\n     \n        return 0;\n    }\n执行结果：\n    parsing [0]\n    next[0]: index: 1 size: 1\n            flags: 00\n    next[1]: index: 2 size: 1\n            rate: 1.00 Mbit/s\n    next[2]: index: 3 size: 4\n            freq: 2437 type: G\n    next[3]: index: 5 size: 1\n            signal: -55 dBm\n    next[4]: index: 11 size: 1\n            antenna: 0\n    next[5]: index: 14 size: 2\n            RX flags: 0000\n    ==================================\n    parsing [1]\n    next[0]: index: 1 size: 1\n            flags: 00\n    next[1]: index: 2 size: 1\n            rate: 1.00 Mbit/s\n    next[2]: index: 3 size: 4\n            freq: 2437 type: B\n    next[3]: index: 5 size: 1\n            signal: -88 dBm\n    next[4]: index: 11 size: 1\n            antenna: 0\n    next[5]: index: 14 size: 2\n            RX flags: 0000\n    ==================================\n---------------------\n作者：李迟\n来源：CSDN\n原文：\nhttps://blog.csdn.net/subfate/article/details/53170546\n\n版权声明：本文为博主原创文章，转载请附上博文链接！",
      "content_path": null,
      "diff_base_variant_id": null,
      "metadata": {
        "language": "en",
        "length": 6942,
        "rule_count": 2,
        "applied_rules": [
          {
            "rule_id": "dedupe_lines",
            "description": "Collapse adjacent duplicate lines",
            "note": "collapsed duplicate adjacent lines"
          },
          {
            "rule_id": "whitespace",
            "description": "Normalize whitespace",
            "note": "collapsed whitespace"
          }
        ]
      }
    }
  ],
  "extractions": [],
  "journal": {
    "id": "b70fb259-e23c-45f8-b5ad-b46dd7dca393",
    "note_id": "ce305e53-b563-4c09-8398-ab4969ca62f8",
    "stage": "ingest",
    "agent_id": "evernote_ingest:v0",
    "started_at": "2025-11-09T20:05:14.016494Z",
    "finished_at": "2025-11-09T20:05:14.016494Z",
    "status": "success",
    "input_ref": {
      "task_id": "0c0a773b-e62a-4387-8704-7d9959b6be93",
      "source_path": "/Users/tang/workbench/article-classifier/backups/2023年6月/IT技术/ieee802.11数据radiotap介绍.html",
      "checksum": "14ef73f03f489e11a47f5d9ad8b76c999ce3cb399daca348473b7a5fc6dac20c"
    },
    "output_ref": {
      "ingest_source": "c4fae54c-9aad-43f4-9a1a-8a7a3d2cb1db",
      "note": "ce305e53-b563-4c09-8398-ab4969ca62f8",
      "variants": [
        "9013e45d-c13a-4fb9-8d73-4e2ac3a8438a",
        "d63c6c7f-f729-439c-a711-4c2373e95c11"
      ]
    },
    "error_detail": null
  }
}
{
  "ingest_source": {
    "id": "617087e5-9ba6-4e74-8953-1fe451769757",
    "source_type": "evernote_html",
    "source_path": "backups/2023年6月/IT技术/Tornado：一个简单例.html",
    "collected_at": "2025-11-10T15:43:31.336136Z",
    "external_id": null,
    "title_hint": null,
    "language_hint": "en",
    "captured_at": null,
    "checksum": "58364d0fc47d1f23ba7ec4845ae5c815ef02ae483e150c886a0c27f307c4b383",
    "status": "pending",
    "notes": {
      "batch_id": "phase2-backfill-202306"
    }
  },
  "note": {
    "id": "c414476c-7f9c-4048-9937-908bfdb2126b",
    "ingest_source_id": "617087e5-9ba6-4e74-8953-1fe451769757",
    "canonical_title": "Tornado：一个简单例",
    "language": "en",
    "ingested_at": "2025-11-10T15:43:31.336140Z",
    "created_at": null,
    "status": "active",
    "importance": 0,
    "attributes": {
      "source_filename": "Tornado：一个简单例.html"
    }
  },
  "variants": [
    {
      "id": "2dc817e7-1bb9-47b4-83bc-c350a024c754",
      "note_id": "c414476c-7f9c-4048-9937-908bfdb2126b",
      "variant_type": "raw_html",
      "version": 1,
      "created_by": "evernote_ingest:v0",
      "created_at": "2025-11-10T15:43:31.336143Z",
      "content": "---\ntitle: Tornado：一个简单例\nupdated: 2019-09-27 08:47:55Z\ncreated: 2019-09-27 08:47:25Z\nauthor: tangyongfeng@gmail.com\n---\n\n\n<en-note><h1><span STYLE=\"font-size: 28px;\"><b><br/></b></span></h1><div><span STYLE=\"-en-paragraph:true;\">简单的web services：\n</span></div><div><span STYLE=\"-en-paragraph:true;\">现在我们将开始了解什么是tornado，tornado可以做什么。我们来通过分析tornado实现的一个简单web service 例子开始吧。\n</span></div><div><span STYLE=\"-en-paragraph:true;\">安装\n</span></div><div>sudo pip install tornado</div><h2><span STYLE=\"font-weight: bold;\">Hello Tornado\n</span></h2><div><span STYLE=\"-en-paragraph:true;\">tornado 是一个可以处理http请求的框架，你的工作是作为一个程序员，编写一个handlers来响应一个标准的http请求。，下面是这个例子的所有代码：\n</span></div><div><span STYLE=\"-en-paragraph:true;\">范例1:</span><a HREF=\"http://hello.py/\" STYLE=\"-en-paragraph:true;\">hello.py</a><span STYLE=\"-en-paragraph:true;\">\n</span></div><div>import tornado.httpserver &nbsp; </div><div>import tornado.ioloop &nbsp; </div><div>import tornado.options &nbsp; </div><div>import tornado.web &nbsp; </div><div>from tornado.options import define, options &nbsp; </div><div>define(&ldquo;port&rdquo;, default=8000, help=&rdquo;run on the given port&rdquo;, type=int)</div><div><br/></div><div>class IndexHandler(tornado.web.RequestHandler): &nbsp; </div><div> &nbsp;&nbsp; def get(self): &nbsp; </div><div> &nbsp; &nbsp; &nbsp;&nbsp; greeting = self.get_argument(&lsquo;greeting&rsquo;, &rsquo;Hello&rsquo;) &nbsp; </div><div> &nbsp; &nbsp; &nbsp;&nbsp; self.write(greeting + &rsquo;, friendly user!&rsquo;)</div><div><br/></div><div>if __name__ == &rdquo;__main__&ldquo;: &nbsp; </div><div> &nbsp;&nbsp; tornado.options.parse_command_line() &nbsp; </div><div> &nbsp;&nbsp; app = tornado.web.Application(handlers=[(r&quot;/&quot;, IndexHandler)]) &nbsp; </div><div> &nbsp;&nbsp; http_server = tornado.httpserver.HTTPServer(app) &nbsp; </div><div> &nbsp;&nbsp; http_server.listen(options.port) &nbsp; </div><div> &nbsp;&nbsp; tornado.ioloop.IOLoop.instance().start()</div><div><span STYLE=\"-en-paragraph:true;\">实际上我们大部分的工作是使用tornado的接口去定义一个类来扩展tornado 的RequestHandler类，在这个例子中，我们将会定义一个简单的应用来监听从端口获得的请求，并且返回一个响应值。\n</span></div><div><span STYLE=\"-en-paragraph:true;\">你可以通过命令行去试着运行和测试你自己的代码：\n</span></div><div>$ python <a HREF=\"http://hello.py/\">hello.py</a> &ndash;port=8000</div><div><span STYLE=\"-en-paragraph:true;\">现在你可以通过浏览器访问</span><a HREF=\"http://localhost:8000/%EF%BC%8C%E6%88%96%E8%80%85%E5%9C%A8%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3%E4%BD%BF%E7%94%A8curl\" STYLE=\"-en-paragraph:true;\">http://localhost:8000/，或者在另外一个独立的命令行窗口使用curl</a><span STYLE=\"-en-paragraph:true;\">命令测试这个应用：\n</span></div><div>$ curl <a HREF=\"http://localhost:8000/\">http://localhost:8000/</a> &nbsp; </div><div>Hello, friendly user! &nbsp; </div><div>$ curl <a HREF=\"http://localhost:8000/?greeting=Salutations\">http://localhost:8000/?greeting=Salutations</a> &nbsp; </div><div>Salutations, friendly user!</div><div><span STYLE=\"-en-paragraph:true;\">让我们回到这个例子下，一步一步对它进行分析吧！\n</span></div><div>import tornado.httpserver &nbsp; </div><div>import tornado.ioloop &nbsp; </div><div>import tornado.options &nbsp; </div><div>import tornado.web</div><div><span STYLE=\"-en-paragraph:true;\">在程序的最上面，我们导入各种tornado的函数库，这里还包括更多的tornado函数库，但是在这个例子中你只需要导入四个函数库就可以运行了：\n</span></div><div>from tornado.options import define, options &nbsp; </div><div>define(&ldquo;port&rdquo;, default=8000, help=&rdquo;run on the given port&rdquo;, type=int)</div><div><span STYLE=\"-en-paragraph:true;\">tornado集成了一些有用的函数在tornado.options里面，在这里我们使用这个函数库来完成监听HTTP请求的应用，这些参数将会对所有对象生效，如果你是在命令行中输入&ndash;help，你将会看到所有的帮助信息及其定义。如果你没有输入一个值，那么default变量后面的参数将会作为默认值开始执行，假如你输入的是一个错误的类型，程序将会抛出一个错误，在这里允许使用一个整数型数据作为监听的端口，如果没有输入任何数据，程序将会使用默认端口8000。\n</span></div><div>class IndexHandler(tornado.web.RequestHandler): &nbsp; </div><div> &nbsp;&nbsp; def get(self): &nbsp; </div><div> &nbsp; &nbsp; &nbsp;&nbsp; greeting = self.get_argument(&lsquo;greeting&rsquo;, &rsquo;Hello&rsquo;) &nbsp; </div><div> &nbsp; &nbsp; &nbsp;&nbsp; self.write(greeting + &rsquo;, friendly user!&rsquo;)</div><div><span STYLE=\"-en-paragraph:true;\">这是一个tornado处理请求的类，当出现请求时，tornado实例将会调用这个类和方法。在这个例子中，我们只定义了一个get方法，这意味着程序只能处理HTTP GET的请求，在后面我们将会学习到如何使用更多接口去响应HTTP不同的请求。\n</span></div><div>greeting = self.get_argument(&lsquo;greeting&rsquo;, &rsquo;Hello&rsquo;)</div><div><span STYLE=\"-en-paragraph:true;\">tornado的请求类拥有很多有用的方法，比如</span><span STYLE=\"-en-paragraph:true;\">get_argument</span><span STYLE=\"-en-paragraph:true;\">，这个方法可以让我们获得请求字符串中的变量（如果请求中不包含字符串，tornado将会使用第二种方法替代get_argument，并使用默认值）\n</span></div><div>self.write(greeting + &apos;, friendly user!&apos;)</div><div><span STYLE=\"-en-paragraph:true;\">第二个方法是使用一个请求的方法，当请求中有字符串变量时，我们将会获取这个字符串，并且插入一个问候语响应这条请求。\n</span></div><div>if __name__ == &quot;__main__&quot;: &nbsp; </div><div> &nbsp;&nbsp; tornado.options.parse_command_line() &nbsp; </div><div> &nbsp;&nbsp; app = tornado.web.Application(handlers=[(r&quot;/&quot;, IndexHandler)])</div><div><span STYLE=\"-en-paragraph:true;\">tornado的应用将会从这里开始执行，首先我们通过tornado的options函数库去解析命令，当我们创建一个tornado应用类的实例的时候，所有导入的变量将会传送到类的 </span><span STYLE=\"-en-paragraph:true;\">__init__</span><span STYLE=\"-en-paragraph:true;\"> 方法中，这个方法将会告诉tornado需要调用哪一个handle ，我们将会在后面对此做详细的说明。\n</span></div><div>http_server = tornado.httpserver.HTTPServer(app) &nbsp; </div><div>http_server.listen(options.port) &nbsp; </div><div>tornado.ioloop.IOLoop.instance().start()</div><div><span STYLE=\"-en-paragraph:true;\">程序将从这里开始执行，创建一个实例，我们通过应用tornado的HTTPServer对象来监听指定的端口在命令行中获取的数据，然后我们创建一个tornado的IOLoop实例，最后这个程序将会开始接收HTTP请求。\n</span></div><div><span STYLE=\"font-weight: bold;-en-paragraph:true;\">操作的变量</span></div><div><span STYLE=\"-en-paragraph:true;\">让我们再回头看看helly.py这个例子的第一行：\n</span></div><div>app = tornado.web.Application(handlers=[(r&quot;/&quot;, IndexHandler)])</div><div><span STYLE=\"-en-paragraph:true;\">这个handlers非常重要，我们将会在后面对它进行更详细的解释，它是一个元组的列表，我们使用一个正则表达式将它与RequestHandler进行匹配，你可以添加更多的列表来指定更多需要匹配的RequestHandler\n</span></div><div><span STYLE=\"font-weight: bold;-en-paragraph:true;\">使用正则表达式来指定URL</span></div><div><span STYLE=\"-en-paragraph:true;\">tornado使用正则表达式来匹配URL的http请求（RequestHandler的类在URL后面，不包括主机名和查询字符串的片段），它们应该包含起始行和结束行。当一个正则表达式匹配一个HTTP请求时，匹配的内容将会作为参数传递给RequestHandler的类。我们将会在下一个例子了解到它是如何工作的。\n</span></div><h2><span STYLE=\"font-weight: bold;\">字符串服务\n</span></h2><div><span STYLE=\"-en-paragraph:true;\">我们将通过一个稍微复杂一些的例子1-2去介绍更多关于tornado的设计理念.\n</span></div><div><span STYLE=\"-en-paragraph:true;\">例1-2 Handling input: </span><a HREF=\"http://string_service.py/\" STYLE=\"-en-paragraph:true;\">string_service.py</a><span STYLE=\"-en-paragraph:true;\">\n</span></div><div>import textwrap&nbsp; </div><div>import tornado.httpserver &nbsp; </div><div>import tornado.ioloop &nbsp; </div><div>import tornado.options &nbsp; </div><div>import tornado.web &nbsp; </div><div>from tornado.options import define, options &nbsp; </div><div>define(&ldquo;port&rdquo;, default=8000, help=&rdquo;run on the given port&rdquo;, type=int) &nbsp; </div><div>class ReverseHandler(tornado.web.RequestHandler): &nbsp; </div><div> &nbsp;&nbsp; def get(self, input): &nbsp; </div><div> &nbsp; &nbsp; &nbsp;&nbsp; self.write(input[::-1])</div><div><br/></div><div>class WrapHandler(tornado.web.RequestHandler): &nbsp; </div><div> &nbsp;&nbsp; def post(self): &nbsp; </div><div> &nbsp; &nbsp; &nbsp;&nbsp; text = self.get_argument(&lsquo;text&rsquo;) &nbsp; </div><div> &nbsp; &nbsp; &nbsp;&nbsp; width = self.get_argument(&lsquo;width&rsquo;, 40) &nbsp; </div><div> &nbsp; &nbsp; &nbsp;&nbsp; self.write(textwrap.fill(text, width))</div><div><br/></div><div>if __name__ == &rdquo;__main__&ldquo;: &nbsp; </div><div> &nbsp;&nbsp; tornado.options.parse_command_line() &nbsp; </div><div> &nbsp;&nbsp; app = tornado.web.Application( &nbsp; </div><div> &nbsp; &nbsp; &nbsp;&nbsp; handlers=[ &nbsp; </div><div> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (r&quot;/reverse/(\\w+)&quot;, ReverseHandler), &nbsp; </div><div> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (r&quot;/wrap&quot;, WrapHandler) &nbsp; </div><div> &nbsp; &nbsp; &nbsp;&nbsp; ] &nbsp; </div><div> &nbsp;&nbsp; ) &nbsp; </div><div> &nbsp;&nbsp; http_server = tornado.httpserver.HTTPServer(app) &nbsp; </div><div> &nbsp;&nbsp; http_server.listen(options.port) &nbsp; </div><div> &nbsp;&nbsp; tornado.ioloop.IOLoop.instance().start()</div><div><span STYLE=\"-en-paragraph:true;\">和第一个例子一样，你可以像这样在命令行中运行它\n</span></div><div><span STYLE=\"-en-paragraph:true;\">$ python </span><a HREF=\"http://string_service.py/\" STYLE=\"-en-paragraph:true;\">string_service.py</a><span STYLE=\"-en-paragraph:true;\"> &ndash;port=8000\n</span></div><div><span STYLE=\"-en-paragraph:true;\">这个程序是一个用于处理字符串的基础web框架，现在你可以对它做两件事情。\n</span></div><div><span STYLE=\"-en-paragraph:true;\">第一：通过GET向 /reverse/string请求返回一个特定的字符串，类似这样的URL结构\n</span></div><div>$ curl <a HREF=\"http://localhost:8000/reverse/stressed\">http://localhost:8000/reverse/stressed</a> &nbsp; </div><div>desserts &nbsp; </div><div>$ curl <a HREF=\"http://localhost:8000/reverse/slipup\">http://localhost:8000/reverse/slipup</a> &nbsp; </div><div>pupils</div><div><span STYLE=\"-en-paragraph:true;\">第二：通过POST向/wrap提交请求，并将返回的字符串显示出来。这个请求包括一个无长度限制的字符串，在程序中，我们通过get_argument来接收这个字符串变量。你可以这么测试：\n</span></div><div>$ curl <a HREF=\"http://localhost:8000/wrap\">http://localhost:8000/wrap</a> &gt;&gt; &nbsp; </div><div>-d text=Lorem+ipsum+dolor+sit+amet,+consectetuer+adipiscing+elit.</div><div><span STYLE=\"-en-paragraph:true;\">结果 ：\n</span></div><div>Lorem ipsum dolor sit amet, consectetuer &nbsp; </div><div>adipiscing elit.</div><div><span STYLE=\"-en-paragraph:true;\">这个字符串服务的例子大部分代码和上一个例子是相同的，让我们将注意力集中到那些新增的不同代码中来，首先让我们来看看程序中传送给handlers的变量有什么不同：\n</span></div><div>app = tornado.web.Application(handlers=[ &nbsp; </div><div> &nbsp;&nbsp; (r&quot;/reverse/(\\w+)&quot;, ReverseHandler), &nbsp; </div><div> &nbsp;&nbsp; (r&quot;/wrap&quot;, WrapHandler) &nbsp; </div><div>])</div><div><span STYLE=\"-en-paragraph:true;\">在这个例子的代码中，我们可以看到有两个RequestHandlers实例化的类对Handlers进行处理，第一个tornado请求的地址按照下面的正则表达式进行匹配：\n</span></div><div>/reverse/(\\w+)</div><div><span STYLE=\"-en-paragraph:true;\">这个正则表达式告诉tornado，他将会匹配一个/reverse/后面跟着一个或多个数字、字母的字符串，括号的含义是告诉tornado，需要将括号中匹配的字符串作为RequestHandler的请求参数，我们可以查看ReverseHandler的定义去了解它是如何工作的：\n</span></div><div>class ReverseHandler(tornado.web.RequestHandler): &nbsp; </div><div> &nbsp;&nbsp; def get(self, input): &nbsp; </div><div> &nbsp; &nbsp; &nbsp;&nbsp; self.write(input[::-1])</div><div><span STYLE=\"-en-paragraph:true;\">你可以看到这个类中，get方法需要输入一个额外的参数，这个参数是在第一个正则表达式中，完全匹配括号内的表达式的一个字符串，（假如有多个括号分割的正则表达式，可以按照相同的顺序在get中添加接收的参数的变量）\n</span></div><div><span STYLE=\"-en-paragraph:true;\">现在，让我们来看看WrapHandler的定义：\n</span></div><div>class WrapHandler(tornado.web.RequestHandler): &nbsp; </div><div> &nbsp;&nbsp; def post(self): &nbsp; </div><div> &nbsp; &nbsp; &nbsp;&nbsp; text = self.get_argument(&lsquo;text&rsquo;) &nbsp; </div><div> &nbsp; &nbsp; &nbsp;&nbsp; width = self.get_argument(&lsquo;width&rsquo;, 40) &nbsp; </div><div> &nbsp; &nbsp; &nbsp;&nbsp; self.write(textwrap.fill(text, width))</div><div><span STYLE=\"-en-paragraph:true;\">WrapHandler的类会处理从请求中传过来的字符串。我们可以看到这个类只定义了一个post的方法，这意味着它只能接收HTTP post的方法。我们之前是用过这个RequestHandler对象来抓取从请求中传过来的字符串作为变量。现在我们可以使用同样的方法去抓取POST请求传过来的变量（tornado可以解析POST传过来的URL字符串或参数），一旦我们抓取到了字符串及其长度的参数，就可以使用python内置的textwrap函数库库去转换字符串，并且通过HTTP返回生成的字符串作为响应数据。\n</span></div><h2><span STYLE=\"font-weight: bold;\">更多RequestHandlers\n</span></h2><div><span STYLE=\"-en-paragraph:true;\">到目前为止，我们基于RequestHandler开发这些对象：如何通过HTTP获取参数（使用get_argument 获取GET和POST传递过来的参数）和如何编写HTTP相应信息（使用write方法）。在我们开始后面的章节学习之前，再给你介绍一些应用RequestHandler需要注意的地方，以及tornado如何去使用它。\n</span></div><div><span STYLE=\"font-weight: bold;-en-paragraph:true;\">http方法：</span></div><div><span STYLE=\"-en-paragraph:true;\">截止目前讨论的都是关于RequestHandler定义单个HTTP方法的问题，其实在一个类中，可以定义或使用多个 handler，绑定多个功能到一个类中是一种很好的管理方式，你可能会编写一个处理程序去获取参数，并且通过POST和GET对象改变数据库中一个特定ID的值，例如：用一个GET方法中将抓取请求的ID和参数，并且使用POST方法修改数据库中对应ID的值。\n</span></div><div><span STYLE=\"-en-paragraph:true;\">截止目前我们讨论的例子中只使用了GET 和 POST的方法，实际上tornado还支持更多的HTTP方法（GET,POST,PUT,DELETE,HEAD,OPTIONS）,在你编写的RequestHandler类中可以通过定义不同的方法去使用他们。在下面的虚拟案例中，我们将会使用HEAD方法去判断请求中的frob是否存在于数据库中，当存在时我们通过GET方法将frob对应的数据库信息返回给请求的客户端：\n</span></div><div># matched with (r&quot;/frob/(\\d+)&quot;, FrobHandler) &nbsp; </div><div>class FrobHandler(tornado.web.RequestHandler): &nbsp; </div><div> &nbsp;&nbsp; def head(self, frob_id): &nbsp; </div><div> &nbsp; &nbsp; &nbsp;&nbsp; frob = retrieve_from_db(frob_id) &nbsp; </div><div> &nbsp; &nbsp; &nbsp;&nbsp; if frob is not None: &nbsp; </div><div> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; self.set_status(200) &nbsp; </div><div> &nbsp; &nbsp; &nbsp;&nbsp; else: &nbsp; </div><div> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; self.set_status(404) &nbsp; </div><div> &nbsp;&nbsp; def get(self, frob_id): &nbsp; </div><div> &nbsp; &nbsp; &nbsp;&nbsp; frob = retrieve_from_db(frob_id) &nbsp; </div><div> &nbsp; &nbsp; &nbsp;&nbsp; self.write(frob.serialize())</div><div><span STYLE=\"font-weight: bold;-en-paragraph:true;\">HTTP状态码：</span></div><div><span STYLE=\"-en-paragraph:true;\">在上一个展示的例子中，你可以在你的RequestHandler使用set_status()设置HTTP状态码到客户端的相应信息中，下面是一些比较重要的状态码。tornado也可以根据你的相应自动去返回对应的状态码，在这里我们只列出比较常用的几个状态码：\n</span></div><ul><li><div>404 Not Found</div></li></ul><div><span STYLE=\"-en-paragraph:true;\">如果HTTP请求的路径不存在，tornado将会通过RequestHandler类自动将404(Not Found)返回给客户端\n</span></div><ul><li><div>400 Bad Request</div></li></ul><div><span STYLE=\"-en-paragraph:true;\">如果使用get_argument没有获取到默认的参数哦，或者没有找到定义的参数名，tornado将会自动将400(Bad Request)返回给客户端。\n</span></div><ul><li><div>405 Method Not Allowed</div></li></ul><div><span STYLE=\"-en-paragraph:true;\">如果通过HTTP传进来的请求没有找到RequestHandler类中对应的方法(例如使用POST请求，但是handler方法对应的类却是GET方法)tornado将会返回一个405（Method Not Allowed）给客户端。\n</span></div><ul><li><div>500 Internal Server Error</div></li></ul><div><span STYLE=\"-en-paragraph:true;\">当遇到任何应用服务异常退出的错误时，tornado将会返回500( Internal Server Error)给客户端，代码中任何意外退出都可能导致tornado返回一个500错误代码。\n</span></div><ul><li><div>200 OK</div></li></ul><div><span STYLE=\"-en-paragraph:true;\">如果请求成功完成了，并且没有设置其它相应代码，tornado默认将会自动返回一个200(OK)的响应给客户端。\n</span></div><div><span STYLE=\"-en-paragraph:true;\">如果请求成功完成了，并且没有设置其它相应代码，tornado默认将会自动返回一个200(OK)的响应给客户端。\n</span></div><div><span STYLE=\"-en-paragraph:true;\">当出现一个错误出现时，tornado默认将会发送一个包含错误代码和错误信息的html页面给客户端，如果你想要替换默认响应的错误信息成自定义的页面，你可以在你的RequestHandler中重写write_error方法，例子1-3将会向你展示我们修改的hello.py，让你了解如何将初始化的错误信息重新改写。\n</span></div><div>import tornado.httpserver &nbsp; </div><div>import tornado.ioloop &nbsp; </div><div>import tornado.options &nbsp; </div><div>import tornado.web &nbsp; </div><div>from tornado.options import define, options</div><div><br/></div><div>define(&quot;port&quot;, default=8000, help=&rdquo;run on the given port&rdquo;, type=int)</div><div><br/></div><div>class IndexHandler(tornado.web.RequestHandler): &nbsp; </div><div> &nbsp;&nbsp; def get(self): &nbsp; </div><div> &nbsp; &nbsp; &nbsp;&nbsp; greeting = self.get_argument(&lsquo;greeting&rsquo;, &rsquo;Hello&rsquo;) &nbsp; </div><div> &nbsp; &nbsp; &nbsp;&nbsp; self.write(greeting + &rsquo;, friendly user!&rsquo;) &nbsp; </div><div> &nbsp;&nbsp; def write_error(self, status_code, **kwargs): &nbsp; </div><div> &nbsp; &nbsp; &nbsp;&nbsp; self.write(&ldquo;Gosh darnit, user! You caused a %d error.&rdquo; % status_code)</div><div><br/></div><div>if __name__ == &rdquo;__main__&ldquo;: &nbsp; </div><div> &nbsp;&nbsp; tornado.options.parse_command_line() &nbsp; </div><div> &nbsp;&nbsp; app = tornado.web.Application(handlers=[(r&quot;/&quot;, IndexHandler)]) &nbsp; </div><div> &nbsp;&nbsp; http_server = tornado.httpserver.HTTPServer(app) &nbsp; </div><div> &nbsp;&nbsp; http_server.listen(options.port) &nbsp; </div><div> &nbsp;&nbsp; tornado.ioloop.IOLoop.instance().start()</div><div><span STYLE=\"-en-paragraph:true;\">在当我们使用POST向handler发送请求时，将会出现下面的响应，因为我们已经把tornado默认的错误响应重写了：\n</span></div><div>$ curl -d foo=bar <a HREF=\"http://localhost:8000/\">http://localhost:8000/</a> &nbsp; </div><div>Gosh darnit, user! You caused a 405 error.</div><div><br/></div></en-note>      ",
      "content_path": null,
      "diff_base_variant_id": null,
      "metadata": {
        "checksum": "58364d0fc47d1f23ba7ec4845ae5c815ef02ae483e150c886a0c27f307c4b383",
        "path": "backups/2023年6月/IT技术/Tornado：一个简单例.html"
      }
    },
    {
      "id": "6d77b25e-378e-4f2c-9f70-2af12dc06135",
      "note_id": "c414476c-7f9c-4048-9937-908bfdb2126b",
      "variant_type": "clean_text",
      "version": 1,
      "created_by": "evernote_ingest:v0",
      "created_at": "2025-11-10T15:43:31.336146Z",
      "content": "---\ntitle: Tornado：一个简单例\nupdated: 2019-09-27 08:47:55Z\ncreated: 2019-09-27 08:47:25Z\nauthor: tangyongfeng@gmail.com\n---\n\n简单的web services：\n\n现在我们将开始了解什么是tornado，tornado可以做什么。我们来通过分析tornado实现的一个简单web service 例子开始吧。\n\n安装\n\nsudo pip install tornado\nHello Tornado\n\ntornado 是一个可以处理http请求的框架，你的工作是作为一个程序员，编写一个handlers来响应一个标准的http请求。，下面是这个例子的所有代码：\n\n范例1:\nhello.py\n\nimport tornado.httpserver  \nimport tornado.ioloop  \nimport tornado.options  \nimport tornado.web  \nfrom tornado.options import define, options  \ndefine(“port”, default=8000, help=”run on the given port”, type=int)\nclass IndexHandler(tornado.web.RequestHandler):  \n    def get(self):  \n        greeting = self.get_argument(‘greeting’, ’Hello’)  \n        self.write(greeting + ’, friendly user!’)\nif __name__ == ”__main__“:  \n    tornado.options.parse_command_line()  \n    app = tornado.web.Application(handlers=[(r\"/\", IndexHandler)])  \n    http_server = tornado.httpserver.HTTPServer(app)  \n    http_server.listen(options.port)  \n    tornado.ioloop.IOLoop.instance().start()\n实际上我们大部分的工作是使用tornado的接口去定义一个类来扩展tornado 的RequestHandler类，在这个例子中，我们将会定义一个简单的应用来监听从端口获得的请求，并且返回一个响应值。\n\n你可以通过命令行去试着运行和测试你自己的代码：\n\n$ python\nhello.py\n –port=8000\n现在你可以通过浏览器访问\nhttp://localhost:8000/，或者在另外一个独立的命令行窗口使用curl\n命令测试这个应用：\n\n$ curl\nhttp://localhost:8000/\n  \nHello, friendly user!  \n$ curl\nhttp://localhost:8000/?greeting=Salutations\n  \nSalutations, friendly user!\n让我们回到这个例子下，一步一步对它进行分析吧！\n\nimport tornado.httpserver  \nimport tornado.ioloop  \nimport tornado.options  \nimport tornado.web\n在程序的最上面，我们导入各种tornado的函数库，这里还包括更多的tornado函数库，但是在这个例子中你只需要导入四个函数库就可以运行了：\n\nfrom tornado.options import define, options  \ndefine(“port”, default=8000, help=”run on the given port”, type=int)\ntornado集成了一些有用的函数在tornado.options里面，在这里我们使用这个函数库来完成监听HTTP请求的应用，这些参数将会对所有对象生效，如果你是在命令行中输入–help，你将会看到所有的帮助信息及其定义。如果你没有输入一个值，那么default变量后面的参数将会作为默认值开始执行，假如你输入的是一个错误的类型，程序将会抛出一个错误，在这里允许使用一个整数型数据作为监听的端口，如果没有输入任何数据，程序将会使用默认端口8000。\n\nclass IndexHandler(tornado.web.RequestHandler):  \n    def get(self):  \n        greeting = self.get_argument(‘greeting’, ’Hello’)  \n        self.write(greeting + ’, friendly user!’)\n这是一个tornado处理请求的类，当出现请求时，tornado实例将会调用这个类和方法。在这个例子中，我们只定义了一个get方法，这意味着程序只能处理HTTP GET的请求，在后面我们将会学习到如何使用更多接口去响应HTTP不同的请求。\n\ngreeting = self.get_argument(‘greeting’, ’Hello’)\ntornado的请求类拥有很多有用的方法，比如\nget_argument\n，这个方法可以让我们获得请求字符串中的变量（如果请求中不包含字符串，tornado将会使用第二种方法替代get_argument，并使用默认值）\n\nself.write(greeting + ', friendly user!')\n第二个方法是使用一个请求的方法，当请求中有字符串变量时，我们将会获取这个字符串，并且插入一个问候语响应这条请求。\n\nif __name__ == \"__main__\":  \n    tornado.options.parse_command_line()  \n    app = tornado.web.Application(handlers=[(r\"/\", IndexHandler)])\ntornado的应用将会从这里开始执行，首先我们通过tornado的options函数库去解析命令，当我们创建一个tornado应用类的实例的时候，所有导入的变量将会传送到类的\n__init__\n 方法中，这个方法将会告诉tornado需要调用哪一个handle ，我们将会在后面对此做详细的说明。\n\nhttp_server = tornado.httpserver.HTTPServer(app)  \nhttp_server.listen(options.port)  \ntornado.ioloop.IOLoop.instance().start()\n程序将从这里开始执行，创建一个实例，我们通过应用tornado的HTTPServer对象来监听指定的端口在命令行中获取的数据，然后我们创建一个tornado的IOLoop实例，最后这个程序将会开始接收HTTP请求。\n\n操作的变量\n让我们再回头看看helly.py这个例子的第一行：\n\napp = tornado.web.Application(handlers=[(r\"/\", IndexHandler)])\n这个handlers非常重要，我们将会在后面对它进行更详细的解释，它是一个元组的列表，我们使用一个正则表达式将它与RequestHandler进行匹配，你可以添加更多的列表来指定更多需要匹配的RequestHandler\n\n使用正则表达式来指定URL\ntornado使用正则表达式来匹配URL的http请求（RequestHandler的类在URL后面，不包括主机名和查询字符串的片段），它们应该包含起始行和结束行。当一个正则表达式匹配一个HTTP请求时，匹配的内容将会作为参数传递给RequestHandler的类。我们将会在下一个例子了解到它是如何工作的。\n\n字符串服务\n\n我们将通过一个稍微复杂一些的例子1-2去介绍更多关于tornado的设计理念.\n\n例1-2 Handling input:\nstring_service.py\n\nimport textwrap \nimport tornado.httpserver  \nimport tornado.ioloop  \nimport tornado.options  \nimport tornado.web  \nfrom tornado.options import define, options  \ndefine(“port”, default=8000, help=”run on the given port”, type=int)  \nclass ReverseHandler(tornado.web.RequestHandler):  \n    def get(self, input):  \n        self.write(input[::-1])\nclass WrapHandler(tornado.web.RequestHandler):  \n    def post(self):  \n        text = self.get_argument(‘text’)  \n        width = self.get_argument(‘width’, 40)  \n        self.write(textwrap.fill(text, width))\nif __name__ == ”__main__“:  \n    tornado.options.parse_command_line()  \n    app = tornado.web.Application(  \n        handlers=[  \n            (r\"/reverse/(\\w+)\", ReverseHandler),  \n            (r\"/wrap\", WrapHandler)  \n        ]  \n    )  \n    http_server = tornado.httpserver.HTTPServer(app)  \n    http_server.listen(options.port)  \n    tornado.ioloop.IOLoop.instance().start()\n和第一个例子一样，你可以像这样在命令行中运行它\n\n$ python\nstring_service.py\n –port=8000\n\n这个程序是一个用于处理字符串的基础web框架，现在你可以对它做两件事情。\n\n第一：通过GET向 /reverse/string请求返回一个特定的字符串，类似这样的URL结构\n\n$ curl\nhttp://localhost:8000/reverse/stressed\n  \ndesserts  \n$ curl\nhttp://localhost:8000/reverse/slipup\n  \npupils\n第二：通过POST向/wrap提交请求，并将返回的字符串显示出来。这个请求包括一个无长度限制的字符串，在程序中，我们通过get_argument来接收这个字符串变量。你可以这么测试：\n\n$ curl\nhttp://localhost:8000/wrap\n >>  \n-d text=Lorem+ipsum+dolor+sit+amet,+consectetuer+adipiscing+elit.\n结果 ：\n\nLorem ipsum dolor sit amet, consectetuer  \nadipiscing elit.\n这个字符串服务的例子大部分代码和上一个例子是相同的，让我们将注意力集中到那些新增的不同代码中来，首先让我们来看看程序中传送给handlers的变量有什么不同：\n\napp = tornado.web.Application(handlers=[  \n    (r\"/reverse/(\\w+)\", ReverseHandler),  \n    (r\"/wrap\", WrapHandler)  \n])\n在这个例子的代码中，我们可以看到有两个RequestHandlers实例化的类对Handlers进行处理，第一个tornado请求的地址按照下面的正则表达式进行匹配：\n\n/reverse/(\\w+)\n这个正则表达式告诉tornado，他将会匹配一个/reverse/后面跟着一个或多个数字、字母的字符串，括号的含义是告诉tornado，需要将括号中匹配的字符串作为RequestHandler的请求参数，我们可以查看ReverseHandler的定义去了解它是如何工作的：\n\nclass ReverseHandler(tornado.web.RequestHandler):  \n    def get(self, input):  \n        self.write(input[::-1])\n你可以看到这个类中，get方法需要输入一个额外的参数，这个参数是在第一个正则表达式中，完全匹配括号内的表达式的一个字符串，（假如有多个括号分割的正则表达式，可以按照相同的顺序在get中添加接收的参数的变量）\n\n现在，让我们来看看WrapHandler的定义：\n\nclass WrapHandler(tornado.web.RequestHandler):  \n    def post(self):  \n        text = self.get_argument(‘text’)  \n        width = self.get_argument(‘width’, 40)  \n        self.write(textwrap.fill(text, width))\nWrapHandler的类会处理从请求中传过来的字符串。我们可以看到这个类只定义了一个post的方法，这意味着它只能接收HTTP post的方法。我们之前是用过这个RequestHandler对象来抓取从请求中传过来的字符串作为变量。现在我们可以使用同样的方法去抓取POST请求传过来的变量（tornado可以解析POST传过来的URL字符串或参数），一旦我们抓取到了字符串及其长度的参数，就可以使用python内置的textwrap函数库库去转换字符串，并且通过HTTP返回生成的字符串作为响应数据。\n\n更多RequestHandlers\n\n到目前为止，我们基于RequestHandler开发这些对象：如何通过HTTP获取参数（使用get_argument 获取GET和POST传递过来的参数）和如何编写HTTP相应信息（使用write方法）。在我们开始后面的章节学习之前，再给你介绍一些应用RequestHandler需要注意的地方，以及tornado如何去使用它。\n\nhttp方法：\n截止目前讨论的都是关于RequestHandler定义单个HTTP方法的问题，其实在一个类中，可以定义或使用多个 handler，绑定多个功能到一个类中是一种很好的管理方式，你可能会编写一个处理程序去获取参数，并且通过POST和GET对象改变数据库中一个特定ID的值，例如：用一个GET方法中将抓取请求的ID和参数，并且使用POST方法修改数据库中对应ID的值。\n\n截止目前我们讨论的例子中只使用了GET 和 POST的方法，实际上tornado还支持更多的HTTP方法（GET,POST,PUT,DELETE,HEAD,OPTIONS）,在你编写的RequestHandler类中可以通过定义不同的方法去使用他们。在下面的虚拟案例中，我们将会使用HEAD方法去判断请求中的frob是否存在于数据库中，当存在时我们通过GET方法将frob对应的数据库信息返回给请求的客户端：\n\n# matched with (r\"/frob/(\\d+)\", FrobHandler)  \nclass FrobHandler(tornado.web.RequestHandler):  \n    def head(self, frob_id):  \n        frob = retrieve_from_db(frob_id)  \n        if frob is not None:  \n            self.set_status(200)  \n        else:  \n            self.set_status(404)  \n    def get(self, frob_id):  \n        frob = retrieve_from_db(frob_id)  \n        self.write(frob.serialize())\nHTTP状态码：\n在上一个展示的例子中，你可以在你的RequestHandler使用set_status()设置HTTP状态码到客户端的相应信息中，下面是一些比较重要的状态码。tornado也可以根据你的相应自动去返回对应的状态码，在这里我们只列出比较常用的几个状态码：\n\n404 Not Found\n如果HTTP请求的路径不存在，tornado将会通过RequestHandler类自动将404(Not Found)返回给客户端\n\n400 Bad Request\n如果使用get_argument没有获取到默认的参数哦，或者没有找到定义的参数名，tornado将会自动将400(Bad Request)返回给客户端。\n\n405 Method Not Allowed\n如果通过HTTP传进来的请求没有找到RequestHandler类中对应的方法(例如使用POST请求，但是handler方法对应的类却是GET方法)tornado将会返回一个405（Method Not Allowed）给客户端。\n\n500 Internal Server Error\n当遇到任何应用服务异常退出的错误时，tornado将会返回500( Internal Server Error)给客户端，代码中任何意外退出都可能导致tornado返回一个500错误代码。\n\n200 OK\n如果请求成功完成了，并且没有设置其它相应代码，tornado默认将会自动返回一个200(OK)的响应给客户端。\n\n如果请求成功完成了，并且没有设置其它相应代码，tornado默认将会自动返回一个200(OK)的响应给客户端。\n\n当出现一个错误出现时，tornado默认将会发送一个包含错误代码和错误信息的html页面给客户端，如果你想要替换默认响应的错误信息成自定义的页面，你可以在你的RequestHandler中重写write_error方法，例子1-3将会向你展示我们修改的hello.py，让你了解如何将初始化的错误信息重新改写。\n\nimport tornado.httpserver  \nimport tornado.ioloop  \nimport tornado.options  \nimport tornado.web  \nfrom tornado.options import define, options\ndefine(\"port\", default=8000, help=”run on the given port”, type=int)\nclass IndexHandler(tornado.web.RequestHandler):  \n    def get(self):  \n        greeting = self.get_argument(‘greeting’, ’Hello’)  \n        self.write(greeting + ’, friendly user!’)  \n    def write_error(self, status_code, **kwargs):  \n        self.write(“Gosh darnit, user! You caused a %d error.” % status_code)\nif __name__ == ”__main__“:  \n    tornado.options.parse_command_line()  \n    app = tornado.web.Application(handlers=[(r\"/\", IndexHandler)])  \n    http_server = tornado.httpserver.HTTPServer(app)  \n    http_server.listen(options.port)  \n    tornado.ioloop.IOLoop.instance().start()\n在当我们使用POST向handler发送请求时，将会出现下面的响应，因为我们已经把tornado默认的错误响应重写了：\n\n$ curl -d foo=bar\nhttp://localhost:8000/\n  \nGosh darnit, user! You caused a 405 error.",
      "content_path": null,
      "diff_base_variant_id": null,
      "metadata": {
        "language": "en",
        "length": 8871,
        "rule_count": 1,
        "applied_rules": [
          {
            "rule_id": "whitespace",
            "description": "Normalize whitespace",
            "note": "collapsed whitespace"
          }
        ]
      }
    }
  ],
  "extractions": [
    {
      "id": "439b3785-50a7-4835-a253-7461850952ae",
      "note_id": "c414476c-7f9c-4048-9937-908bfdb2126b",
      "extractor": "llm_enhance:v0#fallback",
      "payload": {
        "summary": "--- title: Tornado：一个简单例 updated: 2019-09-27 08:47:55Z created: 2019-09-27 08:47",
        "keywords": [
          "---",
          "title: Tornado：一个简单例",
          "updated: 2019-09-27 08:47:55Z",
          "created: 2019-09-27 08:47:25Z",
          "author: tangyongfeng@gmail.com"
        ],
        "action_items": [
          "无"
        ],
        "source": "fallback",
        "category_path": [
          "Education"
        ],
        "new_category_suggestion": null
      },
      "version": 1,
      "created_at": "2025-11-12T06:11:47.772451Z",
      "created_by": "llm_enhance:v0",
      "quality_score": 0.148
    }
  ],
  "journal": {
    "id": "b3f65701-ba91-416d-bda4-0935e9838a62",
    "note_id": "c414476c-7f9c-4048-9937-908bfdb2126b",
    "stage": "ingest",
    "agent_id": "evernote_ingest:v0",
    "started_at": "2025-11-10T15:43:31.336150Z",
    "finished_at": "2025-11-10T15:43:31.336151Z",
    "status": "success",
    "input_ref": {
      "task_id": "28df903a-b90b-4087-b092-b1f27e186efe",
      "source_path": "backups/2023年6月/IT技术/Tornado：一个简单例.html",
      "checksum": "58364d0fc47d1f23ba7ec4845ae5c815ef02ae483e150c886a0c27f307c4b383"
    },
    "output_ref": {
      "ingest_source": "617087e5-9ba6-4e74-8953-1fe451769757",
      "note": "c414476c-7f9c-4048-9937-908bfdb2126b",
      "variants": [
        "2dc817e7-1bb9-47b4-83bc-c350a024c754",
        "6d77b25e-378e-4f2c-9f70-2af12dc06135"
      ]
    },
    "error_detail": null
  },
  "llm": {
    "status": "fallback",
    "model": "fallback",
    "updated_at": "2025-11-12T06:11:47.771984Z",
    "latency_seconds": null,
    "attempts": 3,
    "summary": {
      "summary": "--- title: Tornado：一个简单例 updated: 2019-09-27 08:47:55Z created: 2019-09-27 08:47",
      "keywords": [
        "---",
        "title: Tornado：一个简单例",
        "updated: 2019-09-27 08:47:55Z",
        "created: 2019-09-27 08:47:25Z",
        "author: tangyongfeng@gmail.com"
      ],
      "action_items": [
        "无"
      ],
      "source": "fallback",
      "category_path": [
        "Education"
      ],
      "new_category_suggestion": null
    },
    "quality": {
      "score": 0.148,
      "metrics": {
        "input_chars": 8871.0,
        "input_lines": 201.0,
        "summary_chars": 80.0,
        "summary_coverage_ratio": 0.009,
        "keyword_hit_rate": 1.0,
        "action_item_count": 1.0,
        "unique_summary_sentences": 1.0,
        "estimated_read_seconds": 532.3
      }
    }
  }
}